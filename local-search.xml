<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法训练营day42 | {121.买卖股票的最佳时机, 122.买卖股票的最佳时机II, 123.买卖股票的最佳时机III}</title>
    <link href="/cn/day42_leetcode/"/>
    <url>/cn/day42_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第九章动态规划part08，<strong>股票问题</strong>是一个动态规划的系列问题。</p><span id="more"></span><h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机</a></li><li>文档讲解：<a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Xe4y1u77q/">动态规划之 LeetCode：121.买卖股票的最佳时机1</a></li><li>状态：股票买卖系列的题，用动态规划是通用的解法。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>定义一个dp数组，dp[j]表示在第j天卖出时，能得到的最大利润。依靠前面几天买入的最低价格做减法。</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>121. 买卖股票的最佳时机      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIn</span> <span class="hljs-operator">=</span> prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            minIn = Math.min(minIn, prices[i]);<br>            dp[i] = prices[i] &gt; minIn ? prices[i] - minIn : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">profit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : dp) &#123;<br>            profit = Math.max(p, profit);<br>        &#125;<br>        <span class="hljs-keyword">return</span> profit;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>我的解法，<code>dp[prices.size() - 1]</code>不是题目要求的解，还得再遍历一次dp数组，其实是贪心解法，不是dp。</p><h2 id="1-2-贪心解法"><a href="#1-2-贪心解法" class="headerlink" title="1.2 贪心解法"></a>1.2 贪心解法</h2><p>因为股票就买卖一次，那么贪心怎么贪？取最左最小值，取最右最大值，得到的差值就是最大利润。其实就是我上面的代码，精简一下，不需要记录dp数组，只需要维护一个当前的最大利润值：</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>121. 买卖股票的最佳时机      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">profit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIn</span> <span class="hljs-operator">=</span> prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            minIn = Math.min(minIn, prices[i]);<br>            profit = Math.max(profit, prices[i] - minIn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> profit;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="1-3-动态规划解法"><a href="#1-3-动态规划解法" class="headerlink" title="1.3 动态规划解法"></a>1.3 动态规划解法</h2><p>首先dp数组需要定义为一个二维的数组，因为每天所能获得的最大利润，均有持有和不持有两种状态，没法用一维数组来表示。其次，用“持有”来描述状态，比买入、卖出能包含更多情况。<strong>持有不代表就是当天买入，也有可能是昨天就买入了，今天保持持有的状态。</strong></p><p>DP五部曲：</p><ol><li>dp数组定义：<ul><li>dp[i][0] 表示第i天<strong>持有</strong>股票所得最多现金，一开始现金是0，持有股票之后可以是负数。</li><li>dp[i][1] 表示第i天<strong>不持有</strong>股票所得最多现金。</li></ul></li><li>递推公式：<ul><li>dp[i][0] 可以从下面两个状态转移过来。<ul><li>前一天已经持有 dp[i - 1][0]</li><li>今天买入并持有 -prices[i]</li></ul></li><li>dp[i][1] 可以从<ul><li>前一天已经不持有 dp[i - 1][1]</li><li>今天卖出并不持有 dp[i - 1][0] + prices[1]</li></ul></li></ul></li><li>dp数组初始化：<ul><li>dp[0][0] &#x3D; -prices[0]</li><li>dp[0][1] &#x3D; 0</li></ul></li><li>遍历顺序：从前往后</li><li>打印dp数组。</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>121. 买卖股票的最佳时机      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = - prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], -prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122. 买卖股票的最佳时机II"></a>122. 买卖股票的最佳时机II</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122.买卖股票的最佳时机II</a></li><li>文档讲解：<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1D24y1Q7Ls/">动态规划，股票问题第二弹 | LeetCode：122.买卖股票的最佳时机II</a></li><li>状态：之前这题是用贪心算法解决的，局部最优是取每天的正利润。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>和上一题的唯一的区别：股票买卖可以发生多次。（限制：最多持有一支股票）</p><h2 id="2-2-解题小结"><a href="#2-2-解题小结" class="headerlink" title="2.2 解题小结"></a>2.2 解题小结</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>122. 买卖股票的最佳时机II      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = - prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="123-买卖股票的最佳时机III"><a href="#123-买卖股票的最佳时机III" class="headerlink" title="123. 买卖股票的最佳时机III"></a>123. 买卖股票的最佳时机III</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123.买卖股票的最佳时机III</a></li><li>文档讲解：<a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">代码随想录</a></li><li>视频讲解：<a href="bilibili.com/video/BV1WG411K7AR/">动态规划，股票至多买卖两次，怎么求？ | LeetCode：123.买卖股票最佳时机III</a></li><li>状态：把至多买卖两次给<strong>拆解成5个状态</strong>，就和前两题一样了。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><p>一天一共有5个状态，拆解如下：</p><ul><li>0： 不操作</li><li>1： 第一次持有</li><li>2： 第一次不持有</li><li>3： 第二次持有</li><li>4： 第二次不持有</li></ul><hr><p>DP五部曲：</p><ol><li>dp数组定义：<ul><li>dp[i][j] i表示第i天 j表示状态[0-4]，dp[i][j]表示<strong>第i天状态j所剩最大现金</strong>。</li></ul></li><li>递推公式：<ul><li>dp[i][0] &#x3D; dp[i - 1][0] 不操作，延续前一天的状态</li><li>dp[i][1] &#x3D; max(dp[i - 1][1], dp[i - 1][0] - prices[i]) 其实第一个状态没有必要设置，第一次持有之前手里的现金就是0。</li><li>dp[i][2] &#x3D; max(dp[i - 1][2], dp[i - 1][1] + prices[i])</li><li>dp[i][3] &#x3D; max(dp[i - 1][3], dp[i - 1][2] - prices[i])</li><li>dp[i][4] &#x3D; max(dp[i - 1][4], dp[i - 1][3] + prices[i])</li></ul></li><li>dp数组初始化：<ul><li>dp[0][0] &#x3D; 0</li><li>dp[0][1] &#x3D; -prices[0]</li><li>dp[0][2] &#x3D; 0</li><li>dp[0][3] &#x3D; -prices[0]</li><li>dp[0][4] &#x3D; 0</li></ul></li><li>遍历顺序：从前往后</li><li>打印dp数组。</li></ol><h2 id="3-2-解题小结"><a href="#3-2-解题小结" class="headerlink" title="3.2 解题小结"></a>3.2 解题小结</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>123. 买卖股票的最佳时机III      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">5</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = - prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = - prices[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], <span class="hljs-number">0</span> - prices[i]);<br>            dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="4-今日收获"><a href="#4-今日收获" class="headerlink" title="4. 今日收获"></a>4. 今日收获</h1><ul><li>补打卡命好苦，买卖股票问题，关键是理解“持有”，拆解清楚状态。第一次接触，动态规划的dp数组定义、以及递推公式都不怎么容易想到。</li><li>学习时长：<span class="label label-primary">3.5小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day41 | {198.打家劫舍, 213.打家劫舍II, 337.打家劫舍III}</title>
    <link href="/cn/day41_leetcode/"/>
    <url>/cn/day41_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第九章动态规划part07，今天是<strong>打家劫舍</strong>的一天。</p><span id="more"></span><h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/house-robber/description/">198.打家劫舍</a></li><li>文档讲解：<a href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Te411N7SX/">动态规划，偷不偷这个房间呢？| LeetCode：198.打家劫舍</a></li><li>状态：当前的状态到底是偷还是不偷，自由度确实很高，一开始不知道怎么dp。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>当前房屋偷与不偷取决于<strong>前一个房屋和前两个房屋是否被偷了</strong>，所以感觉到当前状态和前面状态会有一种依赖关系，<strong>这种依赖关系就是动规的递推公式</strong>！</p><p>将大致思路进一步转化成动规五部曲分析：</p><ol><li>dp数组定义：dp[i]表示 考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。</li><li>递推公式：<ul><li>如果偷当前房屋 dp[i] &#x3D; dp[i - 2] + num[i]</li><li>如果不偷当前房屋 dp[i] &#x3D; dp[i - 1]</li><li>dp[i] &#x3D; MAX(dp[i - 2] + num[i], dp[i - 1])</li></ul></li><li>dp数组初始化：<ul><li>依赖于前两个状态，所以初始化dp[0] &#x3D; num[0]; dp[1] &#x3D; MAX(num[0], num[1])</li></ul></li><li>遍历顺序：从前往后遍历即可</li><li>打印dp数组。</li></ol><h2 id="1-2-解题小结"><a href="#1-2-解题小结" class="headerlink" title="1.2 解题小结"></a>1.2 解题小结</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>198. 打家劫舍      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="213-打家劫舍II"><a href="#213-打家劫舍II" class="headerlink" title="213. 打家劫舍II"></a>213. 打家劫舍II</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/house-robber-ii/description/">213.打家劫舍II</a></li><li>文档讲解：<a href="https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html">代码随想录</a></li><li>视频讲解：<a href="bilibili.com/video/BV1oM411B7xq/">动态规划，房间连成环了那还偷不偷呢？| LeetCode：213.打家劫舍II</a></li><li>状态：与上一题的区别是房间成环了，怎么<strong>解决环的问题</strong></li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>环形问题不好确定起始位置在哪里，终止位置在哪里，<strong>把环形展开成一个线形的一个结构</strong>，再单独去考虑首元素和尾元素选或不选，由此分析出三种情况：</p><ul><li>情况一：考虑不包含首尾元素</li><li>情况二：考虑包含首元素，不包含尾元素</li><li>情况三：考虑包含尾元素，不包含首元素</li></ul><p>注意这里的用词都是“考虑”，例如情况三中，考虑包含尾元素，但不是一定要偷尾部元素。情况二、三已经包含情况一了，分析到这里，本题剩下的部分就和198. 打家劫舍一样了。</p><h2 id="2-2-解题小结"><a href="#2-2-解题小结" class="headerlink" title="2.2 解题小结"></a>2.2 解题小结</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>213. 打家劫舍II      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> robRange(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> robRange(nums, <span class="hljs-number">1</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(result1, result2);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robRange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span> nums[start];<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[start] = nums[start];<br>        dp[start + <span class="hljs-number">1</span>] = Math.max(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">2</span>; i &lt;= end; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="337-打家劫舍III"><a href="#337-打家劫舍III" class="headerlink" title="337. 打家劫舍III"></a>337. 打家劫舍III</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/house-robber-iii/">337.打家劫舍III</a></li><li>文档讲解：<a href="https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1H24y1Q7sY/">动态规划，房间连成树了，偷不偷呢？| LeetCode：337.打家劫舍3</a></li><li>状态：树形dp的基础题目，需要熟悉二叉树的遍历。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><p>与前两个打家劫舍如出一辙，只不过这个换成了树，关键是要讨论当前节点抢还是不抢。</p><p>如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以<strong>考虑</strong>抢左右孩子。</p><h2 id="3-2-解题小结"><a href="#3-2-解题小结" class="headerlink" title="3.2 解题小结"></a>3.2 解题小结</h2><h3 id="3-2-1-暴力递归-记忆化递推"><a href="#3-2-1-暴力递归-记忆化递推" class="headerlink" title="3.2.1 暴力递归+记忆化递推"></a>3.2.1 暴力递归+记忆化递推</h3><p>因为递归涉及到重复计算，使用一个map把计算过的结果保存一下，这样如果计算过孙子，那么计算孩子的时候可以复用孙子节点的结果。这种解法属于自顶向下的树形DP。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(log n)</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>337. 打家劫舍III      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;TreeNode, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.val;<br>        <span class="hljs-keyword">if</span> (map.get(root) != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> map.get(root);<br>        <span class="hljs-comment">// 偷父节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val1</span> <span class="hljs-operator">=</span> root.val;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) val1 += rob(root.left.left) + rob(root.left.right);<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) val1 += rob(root.right.left) + rob(root.right.right);<br>        <span class="hljs-comment">// 不偷父节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val2</span> <span class="hljs-operator">=</span> rob(root.left) + rob(root.right);<br>        map.put(root, Math.max(val1, val2));<br>        <span class="hljs-keyword">return</span> Math.max(val1, val2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h3 id="3-2-2-动态规划"><a href="#3-2-2-动态规划" class="headerlink" title="3.2.2 动态规划"></a>3.2.2 动态规划</h3><p>动态规划使用状态转移容器来记录状态的变化，用一个长度为2的数组，记录当前节点偷与不偷所得到的最大金钱。不用向暴力递归一样，对一个节点偷与不偷得到的最大金钱没有记录，需要实时计算。</p><p>递归三部曲：</p><ol><li>返回值和形参：返回值是一个长度为2的数组，保存一个节点偷与不偷两个状态所得到的金钱。参数为当前节点。</li><li>递归的终止条件：当遍历到空节点时，返回 {0，0}</li><li>单层递归逻辑：分别计算偷当前节点能得到的最大金额，不偷当前节点能得到的最大值，以数组的形式返回。</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>337. 打家劫舍III      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = robTree(root);<br>        <span class="hljs-keyword">return</span> Math.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] robTree(TreeNode cur) &#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span>[] leftDp = robTree(cur.left);<br>        <span class="hljs-type">int</span>[] rightDp = robTree(cur.right);<br>        <span class="hljs-comment">// 偷父节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val1</span> <span class="hljs-operator">=</span> cur.val + leftDp[<span class="hljs-number">0</span>] + rightDp[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 不偷父节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val2</span> <span class="hljs-operator">=</span> Math.max(leftDp[<span class="hljs-number">0</span>], leftDp[<span class="hljs-number">1</span>]) + Math.max(rightDp[<span class="hljs-number">0</span>], rightDp[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;val2, val1&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>第一遍看视频，没想到的是不偷父节点的时候，<strong>左右孩子偷不偷仍然是考虑</strong>，隔着位置偷不一定是最好的。</p><h1 id="4-今日收获"><a href="#4-今日收获" class="headerlink" title="4. 今日收获"></a>4. 今日收获</h1><ul><li>打家劫舍，从线性数组、成环到一个二叉树形，关键是想清楚某一个节点偷与不偷，依赖于哪几个节点的状态，从而找到递推关系，使用dp解题。</li><li>学习时长：<span class="label label-primary">3小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day39 | {322. 零钱兑换, 279.完全平方数, 139.单词拆分, 4.多重背包}</title>
    <link href="/cn/day39_leetcode/"/>
    <url>/cn/day39_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第九章动态规划part06，<strong>背包问题</strong>结束，继续动态规划吧~</p><span id="more"></span><h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换</a></li><li>文档讲解：<a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV14K411R7yv/">动态规划之完全背包，装满背包最少的物品件数是多少？| LeetCode：322.零钱兑换</a></li><li>状态：完全背包。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>题目描述：给你一个整数数组coins，表示不同面额的硬币；以及一个整数amount，表示总金额。计算并返回可以凑成总金额所需的<strong>最少的硬币个数</strong>。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>DP五部曲：</p><ol><li>dp[j]数组定义：容量为j的背包最少需要dp[j]个硬币装满。</li><li>递推公式：<ul><li>dp[j] &#x3D; min(dp[j], dp[j - coins[i]] + 1)</li></ul></li><li>dp数组初始化：<ul><li>容量为0，需要0个硬币 dp[0] &#x3D; 0</li></ul></li><li>遍历顺序：均可</li><li>打印dp数组。</li></ol><h2 id="1-2-解题小结"><a href="#1-2-解题小结" class="headerlink" title="1.2 解题小结"></a>1.2 解题小结</h2><p>注意，加一个判断，当dp[j - coins[i]]能凑到时，再+1，否则不进行递推，以防止int溢出。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>322. 零钱兑换      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coins.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[i]; j &lt;= amount; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j - coins[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/perfect-squares/">279.完全平方数</a></li><li>文档讲解：<a href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">代码随想录</a></li><li>状态：和上一题的思路一样，比较简单。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>题目描述：给你一个整数n，返回<strong>和为n</strong>的完全平方数的最少数量 。</p><p>DP五部曲：</p><ol><li>dp[j]数组定义：容量为j的背包最少需要dp[j]个完全平方数装满。</li><li>递推公式： <ul><li>dp[j] &#x3D; min(dp[j], dp[j - nums[i] * nums[i]] + 1)</li></ul></li><li>dp数组初始化：<ul><li>容量为0，需要0个完全平方数 dp[0] &#x3D; 0</li><li>其他初始化为最大值。</li></ul></li><li>遍历顺序：均可</li><li>打印dp数组。</li></ol>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>279. 完全平方数      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i * i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> i * i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> num; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j - num] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - num] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n] == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/word-break/description/">139.单词拆分</a></li><li>文档讲解：<a href="https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1pd4y147Rh/">动态规划之完全背包，你的背包如何装满？| LeetCode：139.单词拆分</a></li><li>状态：先想明白回溯暴力搜索，再来用完全背包解题，回溯比较简单。</li></ul>          </div><h2 id="3-1-回溯搜索"><a href="#3-1-回溯搜索" class="headerlink" title="3.1 回溯搜索"></a>3.1 回溯搜索</h2><p>看成是一个切割字符串的问题，给定一个字符串s，能否切割成子串使得子串列表等于字符串列表wordDict。而切割字符串又能被抽象成一个<strong>组合问题</strong>。</p><p>回溯算法三部曲：</p><ol><li><strong>参数和返回值：</strong> 字符串s，子串列表wordDict，int型变量startIndex，用于记录本层for循环的起始下标。</li><li><strong>递归终止条件：</strong> 如果已经到达字符串的末尾，则说明有一个可行解，返回true结果，终止递归。</li><li><strong>单层递归逻辑：</strong></li></ol><ul><li>从当前位置开始，尝试截取不同长度的前缀，如果这个前缀在字典中存在，就递归处理剩下的子串；如果剩下的子串也能被成功拆分，继续向上返回true。</li><li>如果当前前缀匹配失败，就尝试下一个可能的前缀。（<strong>剪枝</strong>）</li></ul><p>以上暴力搜索会超时，原因是递归包含很多重复计算，需要增加一个<strong>记忆数组memo</strong>，记录每个start是否曾经被计算过。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>139. 单词拆分      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        Set&lt;String&gt; wordSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        Boolean[] memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>[s.length()];<br>        <span class="hljs-keyword">return</span> backtracking(s, wordSet, <span class="hljs-number">0</span>, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, Set&lt;String&gt; wordSet, <span class="hljs-type">int</span> startIndex, Boolean[] memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (startIndex == s.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (memo[startIndex] != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[startIndex];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> startIndex + <span class="hljs-number">1</span>; end &lt;= s.length(); end++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">subStr</span> <span class="hljs-operator">=</span> s.substring(startIndex, end);<br>            <span class="hljs-keyword">if</span> (!wordSet.contains(subStr)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (backtracking(s, wordSet, end, memo)) &#123;<br>                memo[startIndex] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        memo[startIndex] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="3-2-完全背包"><a href="#3-2-完全背包" class="headerlink" title="3.2 完全背包"></a>3.2 完全背包</h2><p>把字符串列表当作物品，字符串s当作背包，那么本题就是完全背包，dp[j]的含义是长度为j的字符串能够由wordSet中的物品组成，则为true，否则设为false。求dp[s.size()]是否为true。</p><p>DP五部曲：</p><ol><li>dp[j]数组定义：首先值是bool型的，长度为j的字符串是否能由wordSet中的单词组成。</li><li>递推公式： <ul><li>如果(i,j]这个区间的子串出现在wordSet中，并且dp[i]为true，则dp[j]为true</li></ul></li><li>dp数组初始化：<ul><li>全部初始化为false；除了空字符串dp[0] &#x3D; true</li></ul></li><li>遍历顺序：本题对子串有顺序要求，是<strong>排列数</strong>。</li><li>打印dp数组。</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>139. 单词拆分      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        Set&lt;String&gt; wordSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        <span class="hljs-keyword">return</span> knapsack(s, wordSet);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">knapsack</span><span class="hljs-params">(String s, Set&lt;String&gt; wordSet)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= s.length(); j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">subStr</span> <span class="hljs-operator">=</span> s.substring(i, j);<br>                <span class="hljs-keyword">if</span> (wordSet.contains(subStr) &amp;&amp; dp[i]) &#123;<br>                    dp[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="4-多重背包"><a href="#4-多重背包" class="headerlink" title="4. 多重背包"></a>4. 多重背包</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1066">56. 携带矿石资源</a></li><li>文档讲解：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85">代码随想录</a></li><li>状态：多重背包在面试中<strong>基本不会出现</strong>，只需要知道它是一种01背包，并能再01背包的基础上写出对应代码就可以了。</li></ul>          </div><h2 id="4-1-理论基础"><a href="#4-1-理论基础" class="headerlink" title="4.1 理论基础"></a>4.1 理论基础</h2><p>有$N$种物品和一个容量为$V$的背包。第i种物品最多有$M_i$件可用，每件耗费的空间是$C_i$，价值是$W_i$。求解将哪些物品装入背包可使这些物品耗费的空间总和不超过背包容量，且价值总和最大。多重背包和01背包是非常像的， 为什么和01背包像呢？</p><p>每件物品最多有$M_i$件可用，把$M_i$件摊开，其实就是一个01背包问题了。</p><h1 id="5-背包问题总结"><a href="#5-背包问题总结" class="headerlink" title="5. 背包问题总结"></a>5. 背包问题总结</h1><p>背包问题是动态规划里的非常重要的一部分，所以要把背包问题单独总结一下。<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html#%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F">确定递推公式和确定遍历顺序都具有规律性和代表性，从这两点出发回顾做过的01背包、完全背包题目。</a></p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day38 | {0.完全背包（纯）, 518.零钱兑换 II, 377.组合总和 Ⅳ, 70. 爬楼梯 （进阶）}</title>
    <link href="/cn/day38_leetcode/"/>
    <url>/cn/day38_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第九章动态规划part05，完全背包应用，注意组合数、排列数在遍历顺序上的区别。</p><span id="more"></span><h1 id="0-完全背包（纯）"><a href="#0-完全背包（纯）" class="headerlink" title="0. 完全背包（纯）"></a>0. 完全背包（纯）</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1052">52. 携带研究材料（第七期模拟笔试）</a></li><li>文档讲解：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1uK411o7c9/">带你学透完全背包问题！ 和 01背包有什么差别？遍历顺序上有什么讲究？</a></li><li>状态：与01背包的区别是，完全背包的每件物品<strong>可以使用无限次</strong>，01背包每个物品只能使用一次。</li></ul>          </div><h2 id="0-1-理论基础"><a href="#0-1-理论基础" class="headerlink" title="0.1 理论基础"></a>0.1 理论基础</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。对于不考虑应用场景的纯粹01背包问题，先遍历物品或是先遍历背包都是可以的。</p><h2 id="0-2-完全背包-二维数组"><a href="#0-2-完全背包-二维数组" class="headerlink" title="0.2 完全背包-二维数组"></a>0.2 完全背包-二维数组</h2><p>举个例子学习完全背包的DP五部曲（二维dp），例如背包最大重量为4，物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>每件商品都有无限个，问背包能背的物品最大价值是多少？</p><hr><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: <strong>dp[i][j]的定义：从下标为[0-i]的物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少。</strong></li><li>确定递推公式: dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])  </li><li>dp数组如何初始化: 从dp[i][j]的定义出发，如果背包容量j为0，dp[i][0] &#x3D; 0; 取物品0时，当j &lt; weight[0], dp[i][0] &#x3D; 0, <strong>当&gt;&#x3D; weight[0]时，就一直装，每一种物品就无限个。</strong></li><li>确定遍历顺序: 先遍历物品还是先遍历背包都是可以的。</li><li>举例推导dp数组: <img src="https://file1.kamacoder.com/i/algo/20241126113752.png" alt="二维dp数组递推模拟"></li></ol><p>注意事项：</p><ul><li>关于递推公式：不放物品i这里和01背包有区别了，空出物品i的容量之后，背包里原来仍有可能可以放物品i。</li><li>关于初始化：一定<strong>要和dp数组的定义吻合</strong>，否则到递推公式的时候就会越来越乱。</li><li>解题的时候，<code>j</code>的遍历起点错了，当j &lt; weight[i]时，没有给dp[i][j]赋值，但这些状态应该继承上一行 dp[i][j] &#x3D; dp[i - 1][j];</li><li>dp数组第一行的初始化不够通用，<strong>让递推统一处理更标准</strong>。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>完全背包-二维数组      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 物品个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 背包容量</span><br>        <span class="hljs-type">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] weight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>             weight[i] = scanner.nextInt();<br>             value[i] = scanner.nextInt();<br>        &#125;<br><br>        System.out.println(Main.knapsack(weight, value, n, v));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> v)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][v + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= v; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = (j &gt;= weight[<span class="hljs-number">0</span>]) ? dp[<span class="hljs-number">0</span>][j - weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= v; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= weight[i])<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - weight[i]] + value[i]);<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][v];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="0-3-完全背包-一维数组"><a href="#0-3-完全背包-一维数组" class="headerlink" title="0.3 完全背包-一维数组"></a>0.3 完全背包-一维数组</h2><p>将二维DP数组，压缩成一维DP数组，也就是将上一层拷贝到当前层。递推公式变为：</p><ul><li>dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i])<br>其实不管是dp数组定义、还是遍历顺序，在想的时候就和二维dp数组一样想，所以无所谓先遍历物品还是背包容量。</li></ul>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>完全背包-一维数组      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 物品个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 背包容量</span><br>        <span class="hljs-type">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] weight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>             weight[i] = scanner.nextInt();<br>             value[i] = scanner.nextInt();<br>        &#125;<br><br>        System.out.println(Main.knapsack(weight, value, n, v));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> v)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[v + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[i]; j &lt;= v; j++) &#123;<br>                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[v];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II</a></li><li>文档讲解：<a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1KM411k75j/">动态规划之完全背包，装满背包有多少种方法？组合与排列有讲究！| LeetCode：518.零钱兑换II</a></li><li>状态：完全背包应用题开始了，注意组合数是不考虑硬币的顺序的。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>硬币的价值就是硬币的重量，题目要求背包容量为amount，把背包装满有几种方案？不考虑硬币放入背包的顺序。每一种面值的硬币有无限个，典型的完全背包问题，dp数组的定义是关于方案个数的。</p><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: dp[i][j]的定义：从下标为[0~i]的硬币中任取无限次，容量为j的背包有dp[i][j]种装满的方式。</li><li>确定递推公式: <span style="color:red">dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - coins[i]]</span></li><li>dp数组如何初始化: <ul><li>第一列dp[i][0]: 当背包容量为0时，因为硬币coin[i]面值不可能为0，只有一种组合方案，就是不装，所以dp[i][0] &#x3D; 1</li><li><span style="color:red">第一行dp[0][j]: 当放硬币coin[0]时，如果 j能被coin[0]整除，那有1种方案，否则没有。</span></li></ul></li><li>确定遍历顺序: 求组合数应该先遍历物品再正序遍历背包。</li><li>举例推导dp数组:</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>518. 零钱兑换 II（二维dp）      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][amount + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= amount; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = (j % coins[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= amount; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= coins[i])<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j -coins[i]];<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><hr><p>压缩物品的维度，考虑一维dp数组。</p><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: dp[j]的定义：从下标为[0~i]的硬币中任取无限次，容量为j的背包有dp[j]种装满的方式。</li><li>确定递推公式: <span style="color:red">dp[j] &#x3D; dp[j] + dp[j - coins[i]]</span></li><li>dp数组如何初始化: <ul><li>背包容量为0时，有1种方法装满，就是不装，dp[0] &#x3D; 1</li><li>其他位置，因为要累加所以全部初始化为0</li></ul></li><li>确定遍历顺序: 求组合数应该先遍历物品再正序遍历背包。</li><li>举例推导dp数组:</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>518. 零钱兑换 II（一维dp）      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[i]; j &lt;= amount; j++) &#123;<br>                dp[j] += dp[j - coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a>377. 组合总和 Ⅳ</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ</a></li><li>文档讲解：<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1V14y1n7B6/">动态规划之完全背包，装满背包有几种方法？求排列数？| LeetCode：377.组合总和IV</a></li><li>状态：每个元素可以使用无限次，仍是完全背包问题，但dp数组本题要求记录<strong>排列数</strong>。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>DP五部曲：</p><ol><li>dp[j]数组定义：顺序不同，算不同方案，dp的语义必须是凑成j的排列数有dp[j]种</li><li>递推公式： <ul><li>也就是说最后一个数是谁，是重要信息，假设最后一个数是num</li><li>dp[j] +&#x3D; dp[j - num]</li></ul></li><li>dp数组初始化：<ul><li>dp[0] &#x3D; 1</li></ul></li><li>遍历顺序：因为是求排列数，先遍历背包，再遍历物品</li><li>打印dp数组。</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>377. 组合总和 Ⅳ      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= target; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>                <span class="hljs-keyword">if</span> (j - num &gt;= <span class="hljs-number">0</span>)<br>                    dp[j] += dp[j - num];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="70-爬楼梯-（进阶）"><a href="#70-爬楼梯-（进阶）" class="headerlink" title="70. 爬楼梯 （进阶）"></a>70. 爬楼梯 （进阶）</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1067">70. 爬楼梯 （进阶）</a></li><li>文档讲解：<a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">代码随想录</a></li><li>状态：之前做爬楼梯这题，在动规入门，还没有涉及到背包问题。</li></ul>          </div><h2 id="2-1-解题分析-1"><a href="#2-1-解题分析-1" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬至多m (1 &lt;&#x3D; m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ </p><p>你有一个背包容量为n，有物品重量从1到m，无限个，请问凑到容量n的排列数是几种？问题转化为完全背包的排列数。同样的，在维度1不能锁定物品出现的顺序，否则就是在算组合数。</p><p>DP五部曲：</p><ol><li>dp[j]数组定义：顺序不同，算不同方案，dp的语义必须是凑成j的排列数有dp[j]种</li><li>递推公式： <ul><li>也就是说最后一个数是谁，是重要信息，假设最后一个数是num</li><li>dp[j] +&#x3D; dp[j - num]</li></ul></li><li>dp数组初始化：<ul><li>dp[0] &#x3D; 1</li></ul></li><li>遍历顺序：因为是求排列数，先遍历背包，再遍历物品</li><li>打印dp数组。</li></ol><h2 id="2-2-解题小结"><a href="#2-2-解题小结" class="headerlink" title="2.2 解题小结"></a>2.2 解题小结</h2><p>和377. 组合总和 Ⅳ是一模一样的。</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>70. 爬楼梯 （进阶）      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            nums[i] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        System.out.println(Main.knapsack(nums, n));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j&lt;= target; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>                <span class="hljs-keyword">if</span> (j - num &gt;= <span class="hljs-number">0</span>) dp[j] += dp[j - num];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day37 | {1049.最后一块石头的重量 II, 494.目标和, 474.一和零}</title>
    <link href="/cn/day37_leetcode/"/>
    <url>/cn/day37_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第九章动态规划part04，01背包的应用题，不同的题目dp数组的<strong>含义一直在变化</strong>。</p><span id="more"></span><h1 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a>1049. 最后一块石头的重量 II</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></li><li>文档讲解：<a href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV14M411C7oV/">动态规划之背包问题，这个背包最多能装多少？LeetCode：1049.最后一块石头的重量II</a></li><li>状态：重新开始做背包问题（应用），本题和<strong>416.分割等和子集</strong>解题思路基本一致。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>问题转化：尽可能把石头<strong>分成重量相等的两堆</strong>，这样粉碎后剩余的重量就是最小的。每块石头的重量就是石头的价值，每块石头只能使用一次，问题转化为01背包问题。</p><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: dp[j]的定义：从下标为[0~i]的物品任意取，容量为j的背包所背的最大价值。</li><li>确定递推公式: dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i])</li><li>dp数组如何初始化: 容量为0时 dp[0]&#x3D;0</li><li>确定遍历顺序: 只能先遍历物品，保持dp数组语义，并倒序遍历背包容量防止覆盖。</li><li>举例推导dp数组: <code>stones = [2,7,4,1,8,1]</code></li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>1049. 最后一块石头的重量 II      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> Arrays.stream(stones).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxVol</span> <span class="hljs-operator">=</span> total / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> knapsack(stones, maxVol);<br>        <span class="hljs-keyword">return</span> total - target * <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones, <span class="hljs-type">int</span> w)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[w + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stones.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> w; j &gt;= stones[i]; j--) &#123;<br>                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[w];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/target-sum/description/">494. 目标和</a></li><li>文档讲解：<a href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1o8411j73x/">动态规划之背包问题，装满背包有多少种方法？| LeetCode：494.目标和</a></li><li>状态：没用代码随想录的转化解法。dp数组定义是直观枚举目标值。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: dp[i][j]的定义: <strong>取i个数，运算结果等于j的方式有dp[i][j]种</strong></li><li>确定递推公式: num &#x3D; nums[i - 1]是第i个数  dp[i][j] &#x3D; dp[i - 1][j - num] + dp[i - 1][j + num]</li><li>dp数组如何初始化: dp[0][0] &#x3D; 1 ; dp[0][j !&#x3D; 0] &#x3D; 0</li><li>确定遍历顺序: <span style="color:red">先枚举用了几个数，再枚举所有可能的和。</span></li><li>举例推导dp数组: <code>nums = [1,1,1,1,1], target = 3</code></li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>494. 目标和      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">OFFSET</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span> (total &lt; Math.abs(target)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][OFFSET * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br><br>        dp[<span class="hljs-number">0</span>][OFFSET] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -total; j &lt;= total; j++) &#123;<br>                dp[i][j + OFFSET] = dp[i - <span class="hljs-number">1</span>][j - num + OFFSET] + dp[i - <span class="hljs-number">1</span>][j + num + OFFSET];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][target + OFFSET];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a>474. 一和零</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/ones-and-zeroes/description/">474.一和零</a></li><li>文档讲解：<a href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1rW4y1x7ZQ/">动态规划之背包问题，装满这个背包最多用多少个物品？| LeetCode：474.一和零</a></li><li>状态：dp数组的含义又有变化了，这次是装满二维维度的背包<strong>最多能放几个物品</strong>。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><ul><li>因为背包既有个数0的限制(m)，也有个数1的限制(n)，字符串数组的个数(k)三个变量，需要用二维数组来定义。</li><li>另外，第i个物品 0的个数设为x，1的个数设为y，作为物品重量。</li></ul><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: dp[i][j]的定义: 0的个数为i、1的个数为j的背包最多能放下<code>dp[i][j]</code>个物品。</li><li>确定递推公式: dp[i][j] &#x3D; max(dp[i - x][j - y] <span style="color:red">+ 1</span>, dp[i][j])</li><li>dp数组如何初始化: dp[0][0] &#x3D; 0; 其他位置为0</li><li>确定遍历顺序: 01背包问题都是先遍历物品，再<strong>倒序</strong>遍历背包。</li><li>举例推导dp数组:</li></ol><ul><li>第一遍解题的时候，递推公式没写对，然后没有考虑背包容量是两个维度的时候，如果不省略物品这个维度，其实dp数组是三维的，遍历背包的容量仍然需要后序遍历，防止多次计数。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>474. 一和零      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; len; k++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cntZero(strs[k]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> strs[k].length() - x;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &gt;=x; i--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= y; j--) &#123;<br>                    dp[i][j] = Math.max(dp[i][j], dp[i - x][j - y] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cntZero</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (str.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>) cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="4-今日收获"><a href="#4-今日收获" class="headerlink" title="4. 今日收获"></a>4. 今日收获</h1><ul><li>01背包的应用题挺难啊，有DP五部曲分析起来也比较困难，难点在于问题转化不好想，以及dp数组含义一直随题目目标在变动。</li><li>学习时长：<span class="label label-primary">4小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day36 | {1.01背包问题（二维）, 2.01背包问题（一维）, 416.分割等和子集}</title>
    <link href="/cn/day36_leetcode/"/>
    <url>/cn/day36_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第九章动态规划part03，正式开始背包问题。</p><span id="more"></span><h1 id="1-01背包问题（二维）"><a href="#1-01背包问题（二维）" class="headerlink" title="1. 01背包问题（二维）"></a>1. 01背包问题（二维）</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1046">46. 携带研究材料</a></li><li>文档讲解：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1cg411g7Y6/">带你学透0-1背包问题！| 关于背包问题，你不清楚的地方，这里都讲了！| 动态规划经典问题 | 数据结构与算法</a></li><li>状态：</li></ul>          </div><h2 id="1-1-理论基础"><a href="#1-1-理论基础" class="headerlink" title="1.1 理论基础"></a>1.1 理论基础</h2><p>对于面试的话，掌握<strong>01背包和完全背包</strong>，就够用了，而完全背包又是01背包稍作变化而来，所以背包问题的理论基础重中之重是01背包。力扣上没有纯粹的01背包的问题，都是01背包应用方面的题目，也就是需要转化为01背包问题。<br><img src="https://file1.kamacoder.com/i/algo/20210117171307407.png" alt="几种背包问题"></p><h2 id="1-2-01背包"><a href="#1-2-01背包" class="headerlink" title="1.2 01背包"></a>1.2 01背包</h2><p>有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><ul><li>首先，暴力解法可以想到用<strong>回溯</strong>，穷举每件物品取或不取，搜索出所有情况，时间复杂度为O(2^n)，n为物品数量。</li></ul><p>回溯算法三部曲：</p><ol><li><strong>参数和返回值是什么？</strong> 参数包括weight数组、value数组、背包容量w、物品数量n，以及遍历的物品个数index，当前已放置的重量curWeight，已获得的价值curValue。</li><li><strong>确定递归的终止条件。</strong> 让所有物品都遍历完之后，收割结果，终止本层递归。</li><li><strong>确定单层搜索的过程。</strong> 原本是for循环用于横向遍历，但在01背包中一个节点只有两种状态，即不选当前物品，或选中当前物品；递归用于纵向遍历，注意和回溯配合使用。</li></ol><p>剪枝优化：<strong>选中当前物品的前提是背包还能装</strong>，如果超过限制，则不继续递归。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>01背包-回溯暴力解法      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> w)</span> &#123;<br>        backtracking(weight, value, w, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> maxValue;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> curWeight, <span class="hljs-type">int</span> curValue)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == weight.length) &#123;<br>            maxValue = Math.max(maxValue, curValue);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        backtracking(weight, value, w, index + <span class="hljs-number">1</span>, curWeight, curValue);<br><br>        <span class="hljs-keyword">if</span> (curWeight + weight[index] &lt;= w) &#123;<br>            backtracking(weight, value, w, index + <span class="hljs-number">1</span>,<br>                    curWeight + weight[index], curValue + value[index]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li>下面举一个例子：背包最大重量为4。物品如下，问背包能背的物品最大价值是多少？</li></ul><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><h2 id="1-3-二维dp数组01背包"><a href="#1-3-二维dp数组01背包" class="headerlink" title="1.3 二维dp数组01背包"></a>1.3 二维dp数组01背包</h2><p>依然用动规五部曲分析一波。动规五部曲：</p><ol><li>确定dp数组以及下标的含义: <strong>dp[i][j]的定义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</strong></li><li>确定递推公式: dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) </li><li>dp数组如何初始化: dp[i][j]依赖于左上方和正上方，所以需要初始化第一行（假设列为物品，行为背包重量）；第一列，当背包最大重量为0时，自然的赋值为0；其他位置取值任意，不影响。</li><li>确定遍历顺序: 先遍历物品后遍历背包；或者先遍历背包后遍历物品均可以。</li><li>举例推导dp数组:<br>   <img src="https://s2.loli.net/2026/01/22/fGpzAbqSUsvLVeg.png" alt="dp数组的数值推导"></li></ol><ul><li>再次强调，当<code>j &lt; weight[i]</code>，意味着第i个物品装不下，无论如何都不能被选，所有合法的方法都只能来自 0 ~ i-1 的物品。而dp[i-1][j]已经是在容量j下，前i-1个物品的最优，除非引入第i个物品。</li><li>DP的每一个状态，本质上都是在回答：在这个约束下，我还能做得比过去更好吗？</li></ul>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>01背包-dp二维数组      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 物品数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 背包最大重量</span><br>        <span class="hljs-type">int</span>[] weight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-type">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            weight[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            value[i] = scanner.nextInt();<br>        &#125;<br><br>        System.out.println(Main.knapsack(weight, value, m, n));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (weight[<span class="hljs-number">0</span>] &lt;= j) dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= weight[i])<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="2-01背包问题（一维）"><a href="#2-01背包问题（一维）" class="headerlink" title="2. 01背包问题（一维）"></a>2. 01背包问题（一维）</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1046">46. 携带研究材料</a></li><li>文档讲解：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1BU4y177kY/">带你学透01背包问题（滚动数组篇） | 从此对背包问题不再迷茫！</a></li><li>状态：01背包的滚动数组，把二维dp降为一维。</li></ul>          </div><h2 id="2-1-一维dp数组01背包"><a href="#2-1-一维dp数组01背包" class="headerlink" title="2.1 一维dp数组01背包"></a>2.1 一维dp数组01背包</h2><p>对于背包问题状态都是可以压缩的。在使用二维数组的时候，递推公式如上，完全可以把dp[i - 1]那一层拷贝到dp[i]上，进一步，与其拷贝，不如只用一个一维数组<code>dp[j]</code>。</p><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: dp[j]的定义：在“只考虑前 i 个物品”的前提下，容量为j背包所背的最大价值。</li><li>确定递推公式: dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i])</li><li>dp数组如何初始化: 背包容量为0时，dp[0]&#x3D;0; 其他位置数字只要比物品最低价值小即可，保证会被覆盖。</li><li>确定遍历顺序: 只能先遍历物品，后遍历背包，并且背包是<strong>从后往前遍历的</strong>。</li><li>举例推导dp数组: 一维dp，分别用物品0，物品1，物品2来遍历背包，结果如下：<br><img src="https://s2.loli.net/2026/01/22/xaEjSe5fdPY6UQZ.png" alt="一维滚动数组模拟"></li></ol>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>01背包-dp一维数组      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 物品数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 背包最大重量</span><br>        <span class="hljs-type">int</span>[] weight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-type">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            weight[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            value[i] = scanner.nextInt();<br>        &#125;<br><br>        System.out.println(Main.knapsack(weight, value, m, n));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= weight[i])<br>                    dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>关于为什么只能先遍历物品，其实很好理解，看一维dp数组dp[j]的语义，关键词<strong>只考虑前i个物品</strong>，外层是物品，状态转移才是合理有意义的。</p><h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416.分割等和子集</a></li><li>文档讲解：<a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1rt4y1N7jE/">动态规划之背包问题，这个包能装满吗？| LeetCode：416.分割等和子集</a></li><li>状态：看到子集，想到可以用回溯暴力搜索，但是树太深了复杂度过高。或转化为0-1背包。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><p>问题转化：假设数组元素的总和为total，那么一半则为total&#x2F;2（可以看出total为奇数时无解）。假设背包容量为total&#x2F;2，数组元素相当于物品，元素值就是value，能否找到一种情况让这个背包价值最大并且刚好装满？若最后剩余容量为0，返回true。</p><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: dp[j]的定义：[0~i]的物品任意取，容量为j的背包所背的最大价值。</li><li>确定递推公式: dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i])</li><li>dp数组如何初始化: 容量为0时 dp[0]&#x3D;0</li><li>确定遍历顺序: 只能先遍历物品，保持dp数组语义，并倒序遍历背包容量防止覆盖。</li><li>举例推导dp数组: <code>nums = [1,5,11,5]</code><br>   <img src="https://s2.loli.net/2026/01/22/VwzNgleuL9naETZ.png" alt="dp数组模拟"></li></ol><h2 id="3-2-解题小结"><a href="#3-2-解题小结" class="headerlink" title="3.2 解题小结"></a>3.2 解题小结</h2>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>416. 分割等和子集      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> knapsack(nums, nums.length, total / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (maxValue != total / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= nums[i])<br>                    dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);<br>                <span class="hljs-keyword">if</span> (dp[j] == n) <span class="hljs-keyword">return</span> n;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>但是在模拟的过程中，我发现了上面的思路虽然正确，但是效率不是很高，也许可以进一步对数组排序，从大的开始塞，这样能更早触发剪枝。</p><ul><li>时间复杂度O(n^2)，</li><li>空间复杂度O(n)。</li></ul><h1 id="4-今日收获"><a href="#4-今日收获" class="headerlink" title="4. 今日收获"></a>4. 今日收获</h1><ul><li>0-1背包问题，反复接触好几遍了，今天重新梳理了一遍二维dp数组、和一维dp数组的理论情况。感觉重点是一定始终要清楚dp数组的含义。</li><li>对dp[i][j]，i是物品，j是容量，dp[i][j]表示<strong>任意取物品[0~i]，容量为j的背包所背的最大价值总和。</strong></li><li>对dp[j]，j是容量，dp[j]表示<strong>只考虑前i个物品</strong>，容量为j的背包所背的最大价值总和。前半句话是隐含的。</li><li>学习时长：<span class="label label-primary">4小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小型支付商城 | {DDD重构}</title>
    <link href="/cn/pay_mall_ddd/"/>
    <url>/cn/pay_mall_ddd/</url>
    
    <content type="html"><![CDATA[<p>小型支付商城的DDD重构，对比MVC和DDD两种分层架构的设计思想，学习<strong>领域驱动的分层方式</strong>。</p><span id="more"></span><h1 id="0-理论基础"><a href="#0-理论基础" class="headerlink" title="0. 理论基础"></a>0. 理论基础</h1><p>DDD（Domain Driven Design）分层架构是一种理论上的<strong>设计思想</strong>，具体到落地，有洋葱架构、<strong>六边形架构</strong>等。其主要目标是<strong>以领域服务为核心，隔离内部实现与外部资源调用</strong>，解耦两者，最终能让程序员更关心项目自身业务的开发。<br><img src="https://bugstack.cn/images/roadmap/tutorial/ddd-easy-guide-03-03.png" alt="DDD工程架构设计方法"></p><p>我们以六边形的DDD分层架构为例，可以将一个工程拆分为：</p><ol><li>api层：用于接口定义，统一入参（Response）对外暴露；好处是对外提供接口描述信息，结合RPC框架（底层是Socket通信+动态代理+反射机制）可实现微服务之间的高效通信，就好像在调用自己定义的实例对象一样。以及规范了响应参数的处理。</li><li>app层：负责config配置和应用启动。这一层可以类比于MVC架构的web（controller层）：<br> <img src="https://s2.loli.net/2026/01/21/U4YPiJoK2RhbFzs.png" alt="MVC与DDD的应用启动对比"><ul><li>但在MVC中，web层不仅要负责配置config和yml，要启动项目，也要写<strong>controller</strong>，都写在这里，如果需要版本迭代，体量增大之后难以维护。</li><li>在DDD架构中，配置和启动交给了app层，而controller则写在trigger层。</li></ul></li><li>domain层：DDD思想的核心，依据业务逻辑分为不同的领域，每个领域是所谓的“充血模型”，即有自己的衣帽间，包含：<ol><li><strong>模型对象</strong>：model，充血对象</li><li><strong>仓储服务</strong>：repository，调用数据库的接口</li><li><strong>外部api接口调用定义</strong>：port，仅定义接口，满足自己领域中业务逻辑的需要，实现下放到infrastructure层</li><li><strong>领域服务</strong>：service，此处的领域服务仅关注自身核心业务功能的接口定义与实现<br> <img src="https://s2.loli.net/2026/01/21/drz1whxK5GgNTbU.png" alt="image.png"></li></ol><ul><li>类比于MVC中的domain层，定义了VO、PO、Req、Res、Dto等用于POJO对象，所有业务的POJO都放在一起，没有自己的衣帽间，部分对象可能由于被共享，添加了两个口袋、一个补丁等进去，使得属性增多。这里的domain层，没有业务逻辑，称之为“贫血模型”。</li></ul></li><li>infrastructure层：用于承接外部资源的调用。具体地，负责定义http、rpc接口，调用外部。<br> <img src="https://s2.loli.net/2026/01/21/69FKDgjWAic2ZOy.png" alt="image.png"></li><li>trigger层：本身提供到外部的放在这里，用于向外部提供服务。<br> <img src="https://s2.loli.net/2026/01/21/vVHW2LOyIxEo9G4.png" alt="image.png"></li><li>types层：用于存放通用信息，包括枚举、工具类、全局异常。相当于之前的common包。</li></ol><h2 id="0-2-六边形工程架构"><a href="#0-2-六边形工程架构" class="headerlink" title="0.2 六边形工程架构"></a>0.2 六边形工程架构</h2><p>参考<a href="https://bugstack.cn/md/road-map/ddd-guide-03.html">xiaofuge的DDD工程模型路书</a>，再次明确六边形架构的特点，会把本身提供到外部的放到trigger，让接口调用、消息监听、任务调度，都可以统一一个入口处理。而对于需要调用外部同类的能力统一放到 infrastructure 基础设施层，包括；数据库、缓存、配置、调用其他方的接口。<br><img src="https://bugstack.cn/images/roadmap/tutorial/ddd-easy-guide-03-05.png" alt="六边形架构"></p><h2 id="0-3-领域模型设计"><a href="#0-3-领域模型设计" class="headerlink" title="0.3 领域模型设计"></a>0.3 领域模型设计</h2><ol><li><p>model 模型对象：</p><ul><li>entity：实体对象。大多数情况下，实体对象Entity与数据库持久化对象PO是1v1的关系。如雇员用户的基本信息、订单信息、配送信息。</li><li>valobj：值对象，用于描述实体对象信息。如一个人，这个雇员的基本level枚举值对象、这个人居住地四级地址对象。这些对象不具有唯一性，也就不具有生命特征，就像你，之后你的衣服，你的胡子。</li><li>aggregate：聚合对象，当我们要写一笔订单入口的时候，需要做事务，事务如果需要一组对象，订单记录、账户记录、库存记录等，这些实体对象+值对象，写入到聚合对象内，一起提交过去。</li></ul></li><li><p>repository 仓储服务：从数据库等数据源中获取数据，传递的对象可以是聚合对象、实体对象，返回的结果可以是实体对象、值对象。</p></li><li><p>service 服务设计：这里要注意，聚合对象更应该注重的是和本对象相关的单一简单封装场景，而把一些重核心业务方法到service里实现。</p></li></ol><h2 id="0-4-对象定义小结"><a href="#0-4-对象定义小结" class="headerlink" title="0.4 对象定义小结"></a>0.4 对象定义小结</h2><p>在 DDD 领域驱动架构下，对象的使用场景结合<strong>各层</strong>小结如下。</p><h3 id="0-4-1-domain领域层"><a href="#0-4-1-domain领域层" class="headerlink" title="0.4.1 domain领域层"></a>0.4.1 domain领域层</h3><div class="note note-info">            <ul><li>entity、vo、aggregate对象，以前的 MVC 下的 XxxVo、XxxReq、XxxRes，现在被领域细分成各个模块下的，实体、聚合、值对象了。</li></ul>          </div><h3 id="0-4-2-infrastructure基础设施层"><a href="#0-4-2-infrastructure基础设施层" class="headerlink" title="0.4.2 infrastructure基础设施层"></a>0.4.2 infrastructure基础设施层</h3><div class="note note-info">            <ul><li>po数据库持久化对象，用于映射数据库表字段，只提供数据库数据。</li><li>dto数据传输对象，这个对象也会在infrastructure层出现，用于与外部的接口对接，比如rpc接口、http接口，出入参的对象，都叫DTO。命名为 XxxRequestDTO、XxxResponseDTO 支付宝的sdk包里就是这样命名的。</li></ul>          </div><h3 id="0-4-3-api层"><a href="#0-4-3-api层" class="headerlink" title="0.4.3 api层"></a>0.4.3 api层</h3><div class="note note-info">            <ul><li>dto对象，接口的出入参，数据传输对象。命名为XxxRequestDTO、XxxResponseDTO</li><li>response&lt;?&gt;对象，包装结果对象，提供code、info、data，准确描述错误码以及data数据，data数据是泛型，用于包装 XxxResponseDTO 结果。</li></ul>          </div><h3 id="0-4-4-case层"><a href="#0-4-4-case层" class="headerlink" title="0.4.4 case层"></a>0.4.4 case层</h3><div class="note note-info">            <p>这一层承接 web 的接口编排动作，串联 domain 领域流程。通常2个方案，一个是引入 api 层，定义的对象。另外一个就是多一层转换，在一层定义 api 层对应的 XxxRequestDTO -&gt; XxxRequest、XxxResponseDTO -&gt; XxxResponse</p>          </div><h2 id="0-5-关于DDD建模方法"><a href="#0-5-关于DDD建模方法" class="headerlink" title="0.5 关于DDD建模方法"></a>0.5 关于DDD建模方法</h2><p>DDD的建模过程，是以<strong>一个用户为起点，通过行为命令，发起行为动作，串联整个业务。</strong>最初来自于用例图的分析，用例图是<strong>用户与系统交互的最简表示形式</strong>，展现了用户和与他相关的用例之间的关系。通过用例图，我们可以分析出所有的行为动作。</p><p>我们将在DDD中用于完成用户行为命令和动作分析的过程，称之为“四色建模”。如下图所示，通过寻找领域事件，发起事件命令，完成领域事件的过程，完成DDD工程建模。<br><img src="https://bugstack.cn/images/article/project/big-market/roadmap-ddd-stc-08.png" alt="整个四色建模的指导图"></p><div class="note note-success">            <ul><li>蓝色 - 决策命令，是用户发起的行为动作，如：开始签到、开始抽奖、查看额度等。</li><li>黄色 - 领域事件，过去时态描述。如：签到完成、抽奖完成、奖品发放完成。<strong>它所阐述的都是这个领域要完成的终态。</strong></li><li>粉色 - 外部系统，如你的系统需要调用外部的接口完成流程。</li><li>红色 - 业务流程，用于串联决策命令到领域事件，所实现的业务流程。一些简单的场景则直接由决策命令到领域事件就可以了。</li><li>绿色 - 只读模型，做一些读取数据的动作，没有写库的操作。</li><li>棕色 - 领域对象，每个决策命令的发起，都是含有一个对应的领域对象。</li></ul>          </div><p>上图左下部分的示意图表达的是：“一个用户，通过一个策略命令，使用领域对象，通过业务流程，完成2个领域事件，调用1次外部接口”的过程。我们在整个 DDD 建模过程中，就是在寻找这些节点。</p><ul><li>关于业务案例分析，见<a href="https://bugstack.cn/md/road-map/ddd-guide-02.html">xiaofuge路书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>小型支付商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day35 | {62.不同路径, 63.不同路径 II, 343.整数拆分, 96.不同的二叉搜索树}</title>
    <link href="/cn/day35_leetcode/"/>
    <url>/cn/day35_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第九章动态规划part02，<strong>找到子状态之间的规律、递推关系</strong>很关键。</p><span id="more"></span><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/unique-paths/description/">62.不同路径</a></li><li>文档讲解：<a href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1ve4y1x7Eu/">动态规划中如何初始化很重要！| LeetCode：62.不同路径</a></li><li>状态：之前已经做过了。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: dp[i][j]的定义：从坐标(0, 0)到达(i, j)一共有dp[i][j]种不同的走法。</li><li>确定递推公式: dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</li><li>dp数组如何初始化: dp[0][?] 第一行都只有1种走法; dp[?][0] 第一列也只有1种走法</li><li>确定遍历顺序: 因为依赖左边和上面的dp值，所以从上到下，从左到右遍历</li><li>举例推导dp数组: 3行7列<br><img src="https://s2.loli.net/2026/01/20/4TU6Gs72yoiBPSu.png" alt="image.png"></li></ol>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>62.不同路径      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II</a></li><li>文档讲解：<a href="https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Ld4y1k7c6/">动态规划，这次遇到障碍了| LeetCode：63. 不同路径 II</a></li><li>状态：重点仍然是想清楚dp数组及其下标的含义、<strong>怎么初始化</strong>。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: dp[i][j]的定义：从坐标(0, 0)到达(i, j)一共有dp[i][j]种不同的走法。</li><li>确定递推公式: dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]</li><li>dp数组如何初始化: dp[0][?] 第一行都只有1种走法; dp[?][0] 第一列也只有1种走法；<span style="color:red">如果遇到障碍物，则后面的都不到，设为0种走法</span></li><li>确定遍历顺序: 从上到下，从左到右遍历</li><li>举例推导dp数组: <code>obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</code><br><img src="https://s2.loli.net/2026/01/20/TZDbB8mKJUd91XL.png" alt="image.png"></li></ol>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>63. 不同路径 II      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = obstacleGrid[i][j] == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分</a></li><li>文档讲解：<a href="https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Mg411q7YJ/">动态规划，本题关键在于理解递推公式！| LeetCode：343. 整数拆分</a></li><li>状态：本题将正整数拆分成尽可能大小相似的数，再相乘乘积才尽可能大。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><ul><li><p>如何用DP？比如拆正整数10，会用到正整数为2、4、6、8时的最大乘积值，依赖于上一个状态。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span> <span class="hljs-params">(<span class="hljs-number">8</span>)</span>-&gt;</span><br>   <span class="hljs-number">2</span> <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">6</span>)</span>-&gt;</span><br>      <span class="hljs-number">2</span>  (<span class="hljs-number">4</span>)...<br></code></pre></td></tr></table></figure></li><li><p>dp[i]最大乘积是怎么得到的？其实可以从1遍历j，又两种渠道得到dp[i]:</p><ol><li>j * (i - j)</li><li>j * dp[i - j]</li></ol></li><li><p>为什么j不用拆分？j是从1开始遍历的，拆分j的情况，再遍历j的过程中已经计算过了，因此可以推出递推公式。</p></li><li><p>优化：拆分一个数n使之乘积最大，那么<strong>一定是拆分成m个近似相同的子树相乘</strong>才是最大的。例如 6 拆成 3 * 3， 10 拆成 3 * 3 * 4。100的话 也是拆成m个近似数组的子数 相乘才是最大的。只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，<span style="color:red">既然m大于等于2，也就是<strong>最差也应该是拆成两个相同的</strong>可能是最大值。</span></p><ul><li>因此，j遍历只需要遍历到<code>n/2</code>就可以，后面没有必要继续遍历了，因为一定不是最大值。</li></ul></li></ul><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: <strong>dp[i]的定义：拆分数字i，可以得到的最大乘积为dp[i]</strong></li><li>确定递推公式: dp[i] &#x3D; max(j * (i - j), j * dp[i - j])</li><li>dp数组如何初始化: dp[0] 和 dp[1]都没有意义，不应该初始化。 dp[2] &#x3D; 1</li><li>确定遍历顺序: dp[i]是依赖于dp[i - j]的状态的，因此遍历i是从前往后遍历</li><li>举例推导dp数组: n &#x3D; 10<br>   <img src="https://file1.kamacoder.com/i/algo/20210104173021581.png" alt="n=10 模拟dp数组值"></li></ol><h2 id="3-2-解题小结"><a href="#3-2-解题小结" class="headerlink" title="3.2 解题小结"></a>3.2 解题小结</h2><p>第一遍解题时dp[i]的递推公式写错了，我只计算了当前j下的拆法最优的结果，而不是<code>dp[i] = max(之前所有 j 的最优结果, 当前 j 的最优结果)</code>。导致覆盖了历史最优解。举个例子，<code>n=10</code>，我的代码的执行过程：</p><ul><li>i &#x3D; 10 当j &#x3D; 3 时:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">dp[<span class="hljs-number">10</span>] = max(<span class="hljs-number">3</span> * <span class="hljs-number">7</span>, <span class="hljs-number">3</span> * dp[<span class="hljs-number">7</span>]) = max(<span class="hljs-number">21</span>, <span class="hljs-number">36</span>) = <span class="hljs-number">36</span><br></code></pre></td></tr></table></figure></li><li>已经算对了，但是继续循环，当j &#x3D; 5时： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">dp[<span class="hljs-number">10</span>] = max(<span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">5</span> * dp[<span class="hljs-number">5</span>]) = max(<span class="hljs-number">25</span>, <span class="hljs-number">30</span>) = <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure> 36被覆盖成了30。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>343. 整数拆分      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp [<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i/ <span class="hljs-number">2</span>; j++) &#123;<br>                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">96. 不同的二叉搜索树</a></li><li>文档讲解：<a href="https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1eK411o7QA/">动态规划找到子状态之间的关系很重要！| LeetCode：96.不同的二叉搜索树</a></li><li>状态：本题需要先画图举例，找到递推关系之后，才能用DP解题。</li></ul>          </div><h2 id="4-1-解题分析"><a href="#4-1-解题分析" class="headerlink" title="4.1 解题分析"></a>4.1 解题分析</h2><p>假设dp[n]定义：1到n为节点组成的BST树的个数为dp[n]，来分析n&#x3D;3的情况。dp[3]，就是<strong>元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</strong>。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量<br>元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量<br>元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量<br><br>有2个元素的搜索树数量就是dp<span class="hljs-comment">[2]</span>。<br>有1个元素的搜索树数量就是dp<span class="hljs-comment">[1]</span>。<br>有0个元素的搜索树数量就是dp<span class="hljs-comment">[0]</span>。<br><br>所以dp<span class="hljs-comment">[3]</span> = dp<span class="hljs-comment">[2]</span> * dp<span class="hljs-comment">[0]</span> + dp<span class="hljs-comment">[1]</span> * dp<span class="hljs-comment">[1]</span> + dp<span class="hljs-comment">[0]</span> * dp<span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure><p><img src="https://file1.kamacoder.com/i/algo/20210107093226241.png" alt="n=3模拟"></p><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义: dp[i]定义：1到i节点组成的二叉搜索树的个数为dp[i]</li><li>确定递推公式: dp[i] +&#x3D; dp[j - 1] * dp[i - j] 其中 j从1遍历到i，模拟不同的元素作为头节点的情况</li><li>dp数组如何初始化: dp[0] &#x3D; 1 空树也是一个BST树；dp[1] &#x3D; 1 </li><li>确定遍历顺序: 因为节点数为i的状态dp[i]是依赖i之前的节点数的状态，所以从小到大遍历</li><li>举例推导dp数组: 模拟n&#x3D;3时，共有5个不同的BST，分别以1、2、3为头节点。</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dfb167e8" role="button" aria-expanded="false" aria-controls="collapse-dfb167e8">        <div class="fold-arrow">▶</div>96. 不同的二叉搜索树      </div>      <div class="fold-collapse collapse" id="collapse-dfb167e8">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="4-今日收获"><a href="#4-今日收获" class="headerlink" title="4. 今日收获"></a>4. 今日收获</h1><ul><li>今天的后面两题，因为没有找到子状态之间的递推关系，都没什么思路。多思考<strong>规律</strong>在哪里，然后用<strong>动态规划五部曲来系统分析一次</strong>吧。</li><li>学习时长：<span class="label label-primary">3.5小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day33 | {509.斐波那契数, 70.爬楼梯, 746.使用最小花费爬楼梯}</title>
    <link href="/cn/day33_leetcode/"/>
    <url>/cn/day33_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第九章动态规划part01，用<strong>动态五部曲</strong>分析问题，打通雾霭。</p><span id="more"></span><h1 id="0-理论基础"><a href="#0-理论基础" class="headerlink" title="0. 理论基础"></a>0. 理论基础</h1><p>动态规划（Dynamic Programming），简称DP，用DP解决问题是<strong>从前一个状态推导出来的</strong>，而贪心是局部直接选最优的。</p><h2 id="0-1-动态规划五部曲"><a href="#0-1-动态规划五部曲" class="headerlink" title="0.1 动态规划五部曲"></a>0.1 动态规划五部曲</h2><ol><li>确定<strong>dp数组以及下标的含义</strong></li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="0-2-动态规划debug"><a href="#0-2-动态规划debug" class="headerlink" title="0.2 动态规划debug"></a>0.2 动态规划debug</h2><p>做动规的题目，写代码之前一定要把状态转移在dp数组上模拟一遍，心中有数是想要的结果；然后写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样：</p><ul><li>如果不一样那就是代码实现细节有问题；</li><li>如果一样，那就是自己的递推公式、初始化或者遍历顺序出问题了。</li></ul><h2 id="0-3-动态规划刷题大纲"><a href="#0-3-动态规划刷题大纲" class="headerlink" title="0.3 动态规划刷题大纲"></a>0.3 动态规划刷题大纲</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ecef54a" role="button" aria-expanded="false" aria-controls="collapse-6ecef54a">        <div class="fold-arrow">▶</div>DP刷题大纲      </div>      <div class="fold-collapse collapse" id="collapse-6ecef54a">        <div class="fold-content">          <p><img src="https://file1.kamacoder.com/i/algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg" alt="DP刷题"></p>        </div>      </div>    </div><h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数</a></li><li>文档讲解：<a href="https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1f5411K7mo/">手把手带你入门动态规划 | LeetCode：509.斐波那契数</a></li><li>状态：掌握做题方法。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义：dp[i]的定义为下标为i的斐波那契数列数值是dp[i]</li><li>确定递推公式：dp[i] &#x3D; dp[i - 1] + dp[i - 2]</li><li>dp数组如何初始化: dp[0] &#x3D; 0, dp[1] &#x3D; 1 </li><li>确定遍历顺序: 因为dp[i]依赖dp[i - 1]和dp[i - 2]，所以从前往后遍历</li><li>举例推导dp数组: 0 1 1 2 3 5 8 13 …</li></ol>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>509. 斐波那契数      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>进一步，因为本题只要求dp[n]，可以进行<strong>状态压缩</strong>，只维护两个数值就可以了，不需要记录整个序列。</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>509. 斐波那契数      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>];;<br>            dp[<span class="hljs-number">1</span>] = sum; <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯</a></li><li>文档讲解：<a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV17h411h7UH/">带你学透动态规划-爬楼梯（对应力扣70.爬楼梯）| 动态规划经典入门题目</a></li><li>状态：依旧用动规五部曲分析。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义：dp[i]的定义为爬到第i层楼梯有dp[i]种不同的方法</li><li>确定递推公式：dp[i] &#x3D; dp[i - 1] + dp[i - 2]</li><li>dp数组如何初始化: dp[1] &#x3D; 1, dp[2] &#x3D; 2 </li><li>确定遍历顺序: 因为dp[i]依赖dp[i - 1]和dp[i - 2]，所以从前往后遍历</li><li>举例推导dp数组: 1 2 3 5 8 13 …</li></ol>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>70. 爬楼梯      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746. 使用最小花费爬楼梯</a></li><li>文档讲解：<a href="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV16G411c7yZ/">动态规划开更了！| LeetCode：746. 使用最小花费爬楼梯</a></li><li>状态：题目意思是在某一节台阶上往上跳要花费费用。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><p>动规五部曲：</p><ol><li>确定dp数组以及下标的含义：dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]</li><li>确定递推公式：dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</li><li>dp数组如何初始化: dp[0] &#x3D; 0 dp[1] &#x3D; 0 </li><li>确定遍历顺序: 因为dp[i]依赖dp[i - 1]和dp[i - 2]，所以从前往后遍历</li><li>举例推导dp数组: 例如cost[]数组<code>[10,15,20]</code>：0 0 10 15</li></ol>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>746. 使用最小花费爬楼梯      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cost.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= cost.length; i++) &#123;<br>            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.length];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小型支付商城 | {Docker构建与部署}</title>
    <link href="/cn/docker_depoly/"/>
    <url>/cn/docker_depoly/</url>
    
    <content type="html"><![CDATA[<p>通过Maven、Docker实现工程构建和部署。</p><span id="more"></span><h1 id="1-Maven操作"><a href="#1-Maven操作" class="headerlink" title="1. Maven操作"></a>1. Maven操作</h1><p>处理项目版本问题，Maven编译使用的JDK也需要是JDK8，否则编译失败。其次，为了避免不必要的干扰，或者修改后端的任意代码&#x2F;配置了之后，需要执行<code>clean</code>操作，随后<code>install</code>重新打成jar包到target目录下。</p><h1 id="2-工程构建"><a href="#2-工程构建" class="headerlink" title="2. 工程构建"></a>2. 工程构建</h1><h2 id="2-1-Docker脚本"><a href="#2-1-Docker脚本" class="headerlink" title="2.1 Docker脚本"></a>2.1 Docker脚本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-comment"># 基础镜像</span><br>FROM openjdk:8-jre-slim<br><br><span class="hljs-comment"># 作者</span><br>MAINTAINER jing<br><br><span class="hljs-comment"># 配置</span><br><span class="hljs-comment"># 运行参数环境变量，定义一个环境变量 PARAMS，默认空，将来运行容器时可以通过它给Java程序追加启动参数，比如 --spring.profiles.active=dev</span><br>ENV PARAMS=<span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># 时区</span><br><span class="hljs-comment"># 设置时区为中国(PRC) 保证容器内时间是北京时间</span><br>ENV TZ=PRC<br>RUN <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/<span class="hljs-variable">$TZ</span> /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$TZ</span> &gt; /etc/timezone<br><br><span class="hljs-comment"># 添加应用</span><br><span class="hljs-comment"># 拷贝应用jar进镜像。将你项目打包生成的 target/s-pay-mall-mvc-app.jar 拷贝到镜像内的根目录  /s-pay-mall-mvc-app.jar</span><br>ADD target/s-pay-mall-mvc-app.jar /s-pay-mall-mvc-app.jar<br><br><span class="hljs-comment"># 启动命令，用java -jar启动这个jar</span><br>ENTRYPOINT [<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;java -jar <span class="hljs-variable">$JAVA_OPTS</span> /s-pay-mall-mvc-app.jar <span class="hljs-variable">$PARAMS</span>&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="2-2-build-sh"><a href="#2-2-build-sh" class="headerlink" title="2.2 build.sh"></a>2.2 build.sh</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SH"><span class="hljs-comment"># 依据前面提供的dockerfile，构建一个本工程的镜像，给其打标签为 tj/...</span><br>docker build -t tj/s-pay-mall-mvc-app:1.0 -f ./Dockerfile .<br></code></pre></td></tr></table></figure><h1 id="3-环境部署"><a href="#3-环境部署" class="headerlink" title="3. 环境部署"></a>3. 环境部署</h1><ul><li>执行命令<code>docker-compose -f docker-compose-environment.yml up -d</code>部署。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>部署工程需要的开发环境      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-comment"># 命令执行 docker-compose up -d</span><br><span class="hljs-comment"># 云服务器；https://618.gaga.plus</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.9&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0.32</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;13306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./sql:/docker-entrypoint-initdb.d</span><br>    <span class="hljs-attr">healthcheck:</span><br>      <span class="hljs-attr">test:</span> [ <span class="hljs-string">&quot;CMD&quot;</span>, <span class="hljs-string">&quot;mysqladmin&quot;</span> ,<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span> ]<br>      <span class="hljs-attr">interval:</span> <span class="hljs-string">5s</span><br>      <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><br>      <span class="hljs-attr">retries:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">start_period:</span> <span class="hljs-string">15s</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my-network</span><br><br>  <span class="hljs-comment"># phpmyadmin https://hub.docker.com/_/phpmyadmin</span><br>  <span class="hljs-attr">phpmyadmin:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">phpmyadmin:5.2.1</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">phpmyadmin</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">phpmyadmin</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8899</span><span class="hljs-string">:80</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PMA_HOST=mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PMA_PORT=3306</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=123qwe!@#QWE</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-attr">mysql:</span><br>        <span class="hljs-attr">condition:</span> <span class="hljs-string">service_healthy</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my-network</span><br><br>  <span class="hljs-comment"># Redis</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:6.2</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">16379</span><span class="hljs-string">:6379</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./redis/redis.conf:/usr/local/etc/redis/redis.conf</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">/usr/local/etc/redis/redis.conf</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my-network</span><br>    <span class="hljs-attr">healthcheck:</span><br>      <span class="hljs-attr">test:</span> [ <span class="hljs-string">&quot;CMD&quot;</span>, <span class="hljs-string">&quot;redis-cli&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span> ]<br>      <span class="hljs-attr">interval:</span> <span class="hljs-string">10s</span><br>      <span class="hljs-attr">timeout:</span> <span class="hljs-string">5s</span><br>      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span><br><br>  <span class="hljs-comment"># RedisAdmin https://github.com/joeferner/redis-commander</span><br>  <span class="hljs-comment"># 账密 admin/admin</span><br>  <span class="hljs-attr">redis-admin:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">spryker/redis-commander:0.8.0</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis-admin</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">redis-commander</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8081</span><span class="hljs-string">:8081</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REDIS_HOSTS=local:redis:6379</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">HTTP_USER=admin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">HTTP_PASSWORD=admin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LANG=C.UTF-8</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LANGUAGE=C.UTF-8</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LC_ALL=C.UTF-8</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my-network</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-attr">redis:</span><br>        <span class="hljs-attr">condition:</span> <span class="hljs-string">service_healthy</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">my-network:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="4-项目部署"><a href="#4-项目部署" class="headerlink" title="4. 项目部署"></a>4. 项目部署</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>部署前后端工程      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-comment"># /usr/local/bin/docker-compose -f /docs/dev-ops/environment/environment-docker-compose-2.4.yml up -d</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><span class="hljs-comment"># docker-compose -f docker-compose-app.yml up -d</span><br><span class="hljs-comment"># 你需要修改system（tj）为你自身系统的仓库名</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-comment"># 部署前端项目</span><br>  <span class="hljs-attr">nginx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.25.1</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;443:443&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;80:80&#x27;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./nginx/html:/usr/share/nginx/html</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 部署后端项目</span><br>  <span class="hljs-attr">s-pay-mall:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">tj/s-pay-mall-mvc-app:1.0</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">s-pay-mall</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">on-failure</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:8080&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=PRC</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SERVER_PORT=8080</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./log:/data/log</span><br>    <span class="hljs-attr">logging:</span><br>      <span class="hljs-attr">driver:</span> <span class="hljs-string">&quot;json-file&quot;</span><br>      <span class="hljs-attr">options:</span><br>        <span class="hljs-attr">max-size:</span> <span class="hljs-string">&quot;10m&quot;</span><br>        <span class="hljs-attr">max-file:</span> <span class="hljs-string">&quot;3&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my-network</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">my-network:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="5-如果修改前端html"><a href="#5-如果修改前端html" class="headerlink" title="5. 如果修改前端html"></a>5. 如果修改前端html</h1><p>因为是简单的静态页面，无需重新构建镜像和部署。</p><h1 id="6-如果修改后端的文件"><a href="#6-如果修改后端的文件" class="headerlink" title="6. 如果修改后端的文件"></a>6. 如果修改后端的文件</h1><p>需要重新走一遍流程</p><ol><li>从Maven开始，<code>mvn clean install</code></li><li>用build.sh重新构建镜像，用的是Maven打出来的新jar</li><li>用docker-compose重启后端容器，到 docs&#x2F;dev-ops 目录，执行：   <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD">docker-compose -f docker-compose-app.yml up -d s-pay-mall<br></code></pre></td></tr></table></figure>   这一步会让s-pay-mall服务的容器基于刚才新构建的镜像<strong>重新创建并启动</strong>。</li></ol><h1 id="7-Other"><a href="#7-Other" class="headerlink" title="7. Other"></a>7. Other</h1><ul><li><p><code>docker-compose up -d</code>会根据某个docker-compose.yml（你这里是 docs&#x2F;dev-ops&#x2F;docker-compose-environment.yml） </p><ul><li>拉取这一组服务需要的镜像</li><li>按配置创建并启动多个容器（mysql、redis、redis-admin 等）</li></ul></li><li><p>这些容器默认会被放到同一个compose项目的网络里： </p><ul><li>你自己显式定义了<code>my-network</code>，所有service都加入了这个网络</li><li><strong>在这个网络里可以用服务名&#x2F;容器名互相访问，比如mysql:3306、redis:6379</strong></li><li><strong>在网络之外，则只能通过IP地址+外部的映射端口号进行访问。</strong></li></ul></li><li><p>关于项目名为什么是<code>dev-ops</code>?</p><ul><li>由于文件路径是 docs&#x2F;dev-ops&#x2F;docker-compose-environment.yml。Docker Desktop 默认会用所在目录名（这里是 dev-ops）当作这一组服务的Project name。所以dev-ops代表这一套环境。<br><img src="https://s2.loli.net/2026/01/19/VQhjYn3ywitTR8l.png" alt="小型支付商城的Docker部署环境"></li></ul></li><li><p>关于不同的项目之间<strong>如何隔离</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">不同 compose 项目名 + 不同网络名（推荐）<br>比如现在这一套叫 dev-ops，网络是 <span class="hljs-keyword">my</span>-network。<br>第二套用 docker-compose -p dev-ops<span class="hljs-number">-2</span> 或放在另一个目录（比如 dev-ops<span class="hljs-number">-2</span>），并在 networks 里写 <span class="hljs-keyword">my</span>-network<span class="hljs-number">-2</span>。<br>这样两套是完全网络隔离的： <br>  - 第一套容器只能解析 mysql（在 <span class="hljs-keyword">my</span>-network 里） <br>  - 第二套容器只能解析它自己网络里的 mysql（<span class="hljs-keyword">my</span>-network<span class="hljs-number">-2</span>）<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day32 | {56.合并区间, 738.单调递增的数字, 968.监控二叉树}</title>
    <link href="/cn/day32_leetcode/"/>
    <url>/cn/day32_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第八章贪心算法part05，继续练习贪心算法，找出局部最优。</p><span id="more"></span><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/merge-intervals/description/">56. 合并区间</a></li><li>文档讲解：<a href="https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1wx4y157nD/">贪心算法，合并区间有细节！LeetCode：56.合并区间</a></li><li>状态：依旧是判断重叠区间，先排序，然后比较左右边界。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>56. 合并区间      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> intervals;<br>        Arrays.sort(intervals, (o1, o2)-&gt;Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]));<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<br>                intervals[i][<span class="hljs-number">0</span>] = Math.min(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">0</span>]);<br>                intervals[i][<span class="hljs-number">1</span>] = Math.max(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                list.add(intervals[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        list.add(intervals[intervals.length - <span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span>[][] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            result[i] = list.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a>738. 单调递增的数字</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">738.单调递增的数字</a></li><li>文档讲解：<a href="https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Kv4y1x7tP/">贪心算法，思路不难想，但代码不好写！LeetCode:738.单调自增的数字</a></li><li>状态：例如n&#x3D;32，因为30+不可能是单调递增的，十位数字必须减1，接着个位数字要尽可能的大。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>本题的贪心，贪在哪里比较好想，但是有两个细节问题需要注意：</p><ol><li>考虑遍历顺序，只有从后向前遍历才能<strong>重复利用上次比较结果</strong>。</li><li>要使用一个flag变量记录最近的需要变为9的位置，并且为了达到最大，其后所有位置都要变成9.</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>738. 单调递增的数字      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[] num = String.valueOf(n).toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> num.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> num.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (num[i - <span class="hljs-number">1</span>] &gt; num[i]) &#123;<br>                num[i - <span class="hljs-number">1</span>]--;<br>                flag = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> flag; i &lt; num.length; i++) &#123;<br>            num[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(num));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a>968. 监控二叉树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/binary-tree-cameras/description/">968.监控二叉树</a></li><li>文档讲解：<a href="https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html">代码随想录</a></li><li>视频讲解：<a href="bilibili.com/video/BV1SA411U75i/">贪心算法，二叉树与贪心的结合，有点难…… LeetCode:968.监督二叉树</a></li><li>状态：每个监控摄像头要尽可能地覆盖更大的范围。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><p>摄像头可以覆盖上中下三层，放在叶子节点就浪费了一层的覆盖范围，同时叶子节点是指数级别的多，能节省的更多。因此<strong>从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少。</strong>局部最优推出全局最优，且找不出反例，那么按照贪心来。</p><p>确定了<strong>后序遍历</strong>的都遍历顺序后，本题的难点还在于实现<strong>如何隔两个节点放一个摄像头</strong>？</p><ul><li>此时需要状态转移的公式，注意就是单纯的状态转移！每个节点可能有如下三个状态，分别用三个数字来表示：<ul><li>0：本节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul></li><li>空节点是什么状态？遍历树都过程中，遇到空节点，应该返回<strong>有覆盖</strong>状态。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>968. 监控二叉树      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCameraCover</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (postOrder(root) == <span class="hljs-number">0</span>) &#123;<br>            result++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> postOrder(node.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> postOrder(node.right);<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123;<br>            result++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="4-贪心总结"><a href="#4-贪心总结" class="headerlink" title="4. 贪心总结"></a>4. 贪心总结</h1><ul><li>究竟什么题目是贪心呢？如果找出局部最优并且可以推出全局最优，就是贪心，如果局部最优都没找出来，就不是贪心，可能是单纯的模拟。不过最终会解题就行了。</li><li><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E7%AF%87.html">18道贪心题目罗列&amp;总结</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day31 | {452.用最少数量的箭引爆气球, 435.无重叠区间, 763.划分字母区间}</title>
    <link href="/cn/day31_leetcode/"/>
    <url>/cn/day31_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第八章贪心算法part04，都是重叠区间问题。</p><span id="more"></span><h1 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">452.用最少数量的箭引爆气球</a></li><li>文档讲解：<a href="https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1SA41167xe/">贪心算法，判断重叠区间问题 | LeetCode：452.用最少数量的箭引爆气球</a></li><li>状态：直观上在重叠区间最多的地方射箭，就是贪心所在，代码怎么实现？</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>难点在于如何模拟气球被射爆的过程，例如如何判断两个气球重叠，如何判断下一个气球也重叠？</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>452. 用最少数量的箭引爆气球      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-keyword">if</span> (points.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(points, (o1, o2)-&gt;Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; points.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) result++;<br>            <span class="hljs-keyword">else</span> &#123;<br>                points[i][<span class="hljs-number">1</span>] = Math.min(points[i][<span class="hljs-number">1</span>], points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li>Java Comparator 写法要注意 int溢出问题，<code>Integer.compare(a, b)</code>是正确的写法，因为它的实现逻辑等价于：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (a &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ul><p>不做减法，永不溢出，关于排序推荐使用<code>Integer.compare(a, b)</code>或<code>Long.compare(a, b)</code>。</p><h1 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/non-overlapping-intervals/description/">435.无重叠区间</a></li><li>文档讲解：<a href="https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1A14y1c7E1/">贪心算法，依然是判断重叠区间 | LeetCode：435.无重叠区间</a></li><li>状态：和上一题差不多，按左边界排序后，遇到重叠区间，<strong>记录一下</strong>要删一个就行，不用真删除。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>435. 无重叠区间      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(intervals, (o1, o2)-&gt;Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<br>                result++;<br>                intervals[i][<span class="hljs-number">1</span>] = Math.min(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a>763. 划分字母区间</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/partition-labels/description/">763.划分字母区间</a></li><li>文档讲解：<a href="https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV18G4y1K7d5/">贪心算法，寻找最远的出现位置！ LeetCode：763.划分字母区间</a></li><li>状态：没什么思路，记录每个字母最远位置的做法很妙。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><p>题目要求同一个字母最多出现在一个片段中，怎么能把同一个字母圈在同一个区间中呢？<strong>需要记录每一个字母的最远位置。</strong></p><p>具体地，解题思路分为两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点。</li></ul><p><img src="https://s2.loli.net/2026/01/17/ul1K7TeUokcxOmB.png" alt="统计字母最远出现的位置"></p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>763. 划分字母区间      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            hash[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            right = Math.max(right, hash[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == right) &#123;<br>                result.add(right - left + <span class="hljs-number">1</span>);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day30 | {134.加油站, 135.分发糖果, 860.柠檬水找零, 406.根据身高重建队列}</title>
    <link href="/cn/day30_leetcode/"/>
    <url>/cn/day30_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第八章贪心算法part03，遇到两个维度同时要比较的题目，必须先确定一边，再确定另一边。</p><span id="more"></span><h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></li><li>文档讲解：<a href="https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1jA411r7WX/">贪心算法，得这么加油才能跑完全程！LeetCode ：134.加油站</a></li><li>状态：想到一个时间复杂度O(n2)的暴力解法。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>暴力解法，先计算每个站点的净收益，然后枚举起点，从该起点出发绕一圈，油量不为0。</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>134. 加油站      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span>[] profit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[gas.length];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; profit.length; i++) &#123;<br>            profit[i] = gas[i] - cost[i];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; profit.length; i++) &#123; <span class="hljs-comment">// 枚举起点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">for</span> (; j &lt; i + profit.length; j++) &#123;<br>                sum += profit[j % profit.length];<br>                <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == i + profit.length) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li>换一种思路，首先如果总油量减去总消耗&gt;&#x3D;0那么一定是可以跑完一圈的。</li><li>其次，这题贪心在哪里？<strong>如果从i出发，在j位置油量变成负数，那么<code>i~j</code>之间的任意一个点，都不可能成为起点。</strong></li><li>为什么？假设从i到j的累计和是负数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">profit[i] + profit[i+<span class="hljs-number">1</span>] + ... + profit[j] &lt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>那你如果从i+1、i+2出发，只会更少油，更不可能成功。<strong>所以一旦失败，可以跳过一段区间。</strong> 只用遍历一遍数组，时间复杂度降低为O(n)。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>134. 加油站      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 总收益</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 当前油箱</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gas.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> gas[i] - cost[i];<br>            total += diff;<br>            cur += diff;<br><br>            <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) &#123;<br>                start = i + <span class="hljs-number">1</span>;<br>                cur = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> total &gt;= <span class="hljs-number">0</span> ? start : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/candy/description/">135. 分发糖果</a></li><li>文档讲解：<a href="https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1ev4y1r7wN/">贪心算法，两者兼顾很容易顾此失彼！LeetCode：135.分发糖果</a></li><li>状态：没做出来。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>题目要求：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>但这道题<strong>如果两边一起考虑一定会顾此失彼</strong>，必须要确定一边之后，再确定另一边。明确解题的顺序。</p><p>例如<strong>先确定右边评分大于左边的情况（从前往后遍历）</strong>。此时局部最优，只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果。局部最优可以推出全局最优。<strong>再确定左边大于右边的情况（从后往前遍历）</strong>，类似的贪心分析方法，不过此时要保证第i个孩子的糖果数量既比大于左边孩子的，又大于右边孩子的，要取最值。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>135. 分发糖果      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span>[] candy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ratings.length];<br>        Arrays.fill(candy, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 1. 右边的孩子比左边孩子糖果多</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; candy.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candy[i] = candy[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2. 左边的孩子比右边孩子糖果多</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> candy.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>]) &#123;<br>                candy[i] = Math.max(candy[i], candy[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : candy) &#123;<br>            result += c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a>860. 柠檬水找零</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/lemonade-change/description/">860.柠檬水找零</a></li><li>文档讲解：<a href="https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV12x4y1j7DD/">贪心算法，看上去复杂，其实逻辑都是固定的！LeetCode：860.柠檬水找零</a></li><li>状态：柠檬水这题，贪心在贪什么？</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><p>题目要求在每一步，都能正确找零，保证是合法的；<strong>贪心的关键是优先用10元找零</strong>，因为5元是万能货币，10元只能给20元找零。并且只能事前决策，不能事后补救。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>860. 柠檬水找零      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">lemonadeChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bills)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">five</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ten</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) &#123;<br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>) five++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">if</span> (five == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                five--;<br>                ten++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span> &amp;&amp; five &gt; <span class="hljs-number">0</span>) &#123;<br>                    ten--;<br>                    five--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt;= <span class="hljs-number">3</span>) &#123;<br>                    five -= <span class="hljs-number">3</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a>406. 根据身高重建队列</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406.根据身高重建队列</a></li><li>文档讲解：<a href="https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html">代码随想录</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1EA411675Y/">贪心算法，不要两边一起贪，会顾此失彼 | LeetCode：406.根据身高重建队列</a></li><li>状态：同时要比较身高和排序两个维度，先确定一边再调整另一边。</li></ul>          </div><h2 id="4-1-解题分析"><a href="#4-1-解题分析" class="headerlink" title="4.1 解题分析"></a>4.1 解题分析</h2><p>这题的难点不在想贪心怎么落地，在于Java API，比如二维数组排序、ArrayList怎么转为二维数组。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>406. 根据身高重建队列      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        Arrays.sort(people, (o1, o2)-&gt; &#123;<br>            <span class="hljs-keyword">if</span> (o1[<span class="hljs-number">0</span>] != o2[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">return</span> o2[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];<br>        &#125;);<br><br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : people) &#123;<br>            list.add(p[<span class="hljs-number">1</span>], p);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[][] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[people.length][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            result[i] = list.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="5-JAVA-API小结"><a href="#5-JAVA-API小结" class="headerlink" title="5. JAVA API小结"></a>5. JAVA API小结</h1><ul><li><code>Arrays.fill(arr, 1)</code>：快速对数组赋初始值。</li><li>数组排序，一维数组、二维数组，都可以用<code>Arrays.sort</code>配合自定义比较器的方式。关于比较器Comparetor的固定规则，涉及到<strong>升序还是降序</strong>：<ul><li>返回 &lt; 0 : o1 比 o2 小，o1放前面</li><li>返回 &gt; 0 : o1 比 o2 大，o1放后面</li></ul></li><li><code>List&lt;int[]&gt;</code>转<code>int[][]</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[][] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[people.length][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    result[i] = list.get(i);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day29 | {122.买卖股票的最佳时机II, 55.跳跃游戏, 45.跳跃游戏II, 1005.K次取反后最大化的数组和}</title>
    <link href="/cn/day29_leetcode/"/>
    <url>/cn/day29_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第八章贪心算法part02，贪心的思路，局部最优贪在哪里。</p><span id="more"></span><h1 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122. 买卖股票的最佳时机II"></a>122. 买卖股票的最佳时机II</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122.买卖股票的最佳时机II</a></li><li>文档讲解：<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html">代码随想录–122.买卖股票的最佳时机II</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1ev4y1C7na/">贪心算法也能解决股票问题！LeetCode：122.买卖股票最佳时机II</a></li><li>状态：贪在哪里呢？想不到怎么贪。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>本题如果想到最终利润是可以分解的，那就容易了（只收集正利润，局部最优推出全局最优）。如何分解？<br>假设第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]，相当于 (price[3] - price[2]) + (price[2] - price[1]) + (price[1] - price[0])，此时就把利润分解为每天为单位的维度，不用从第0天到第3天整体去考虑。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>122. 买卖股票的最佳时机II      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            result += Math.max(prices[i] - prices[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/jump-game/description/">55. 跳跃游戏</a></li><li>文档讲解：<a href="https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html">代码随想录–55. 跳跃游戏</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1VG4y1X7kB/">贪心算法，怎么跳跃不重要，关键在覆盖范围 | LeetCode：55.跳跃游戏</a></li><li>状态：关键在于覆盖范围，每次贪最远的覆盖范围。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p><strong>Jump Game 不是“从 cover 再跳”，而是“枚举所有能站到的位置 i，从 i 再跳”。</strong></p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>55. 跳跃游戏      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cover</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= cover; i++) &#123;<br>           cover = Math.max(cover, i + nums[i]);<br>           <span class="hljs-keyword">if</span> (cover &gt;= nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="45-跳跃游戏II"><a href="#45-跳跃游戏II" class="headerlink" title="45. 跳跃游戏II"></a>45. 跳跃游戏II</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/jump-game-ii/description/">45.跳跃游戏II</a></li><li>文档讲解：<a href="https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html">代码随想录–45.跳跃游戏II</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Y24y1r7XZ/">贪心算法，最少跳几步还得看覆盖范围 | LeetCode： 45.跳跃游戏II</a></li><li>状态：和55.思路相似，贪心的思路是当前可覆盖范围内，尽可能多走，如果还没到终点，步数再加一。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>45. 跳跃游戏II      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            next = Math.max(next, i + nums[i]);<br>            <span class="hljs-keyword">if</span> (i == cur) &#123;<br>                result++;<br>                cur = next;<br>                <span class="hljs-keyword">if</span> (cur &gt;= nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="1005-K次取反后最大化的数组和"><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005. K次取反后最大化的数组和"></a>1005. K次取反后最大化的数组和</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations//">1005.K次取反后最大化的数组和</a></li><li>文档讲解：<a href="https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html">代码随想录–1005.K次取反后最大化的数组和</a></li><li>视频讲解：<a href="bilibili.com/video/BV138411G7LY/">贪心算法，这不就是常识？还能叫贪心？LeetCode：1005.K次取反后最大化的数组和</a></li><li>状态：贪在先对最大的负数取反，如果没有负数，对0取反消耗次数，0也没有，对最小的一个正数取反。</li></ul>          </div><h2 id="4-1-解题分析"><a href="#4-1-解题分析" class="headerlink" title="4.1 解题分析"></a>4.1 解题分析</h2><p>培养用贪心的思考方式（局部最优，全局最优）来解题。局部最优：让绝对值最大的负数变为正数。</p><ul><li>注意第一遍写的时候，k还有剩并且是奇数的情况下，反转绝对值最小的数，因为一开始没有按照绝对值大小来排序，所以还得再排序一次。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>1005. K次取反后最大化的数组和      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length &amp;&amp; k &gt; <span class="hljs-number">0</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;<br>                nums[i] = -nums[i];<br>                k--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (Math.abs(nums[i]) &lt; Math.abs(nums[minIndex])) minIndex = i;<br>            &#125;<br>            nums[minIndex] = -nums[minIndex];<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(nums).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day28 | {455.分发饼干, 376.摆动序列, 53.最大子序和}</title>
    <link href="/cn/day28_leetcode/"/>
    <url>/cn/day28_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第八章贪心算法part01，想清楚贪在哪里，能否举出反例。</p><span id="more"></span><h1 id="0-理论基础"><a href="#0-理论基础" class="headerlink" title="0. 理论基础"></a>0. 理论基础</h1><p>贪心算法<strong>没有固定的规律或套路</strong>，说白了就是常识性推导加上举反例。唯一的难点就是如何通过局部最优，推出整体最优。总之，刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，<strong>而且想不到反例，那么就试一试贪心。</strong><br><img src="https://file1.kamacoder.com/i/algo/20210917104315.png" alt="题目分类"></p><h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a>455. 分发饼干</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/assign-cookies/description/">455.分发饼干</a></li><li>文档讲解：<a href="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html">代码随想录–455.分发饼干</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1MM411b7cq/">贪心算法，你想先喂哪个小孩？| LeetCode：455.分发饼干</a></li><li>状态：简单题，优先考虑胃口，或优先考虑饼干。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>455. 分发饼干      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] g, <span class="hljs-type">int</span>[] s)</span> &#123;<br>        <span class="hljs-comment">// 优先考虑胃口，先喂饱大胃口</span><br>        Arrays.sort(g);<br>        Arrays.sort(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> g.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; s[start] &gt;= g[i]) &#123;<br>                start--;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>455. 分发饼干      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] g, <span class="hljs-type">int</span>[] s)</span> &#123;<br>        <span class="hljs-comment">// 优先考虑饼干，小饼干先喂饱小胃口</span><br>        Arrays.sort(g);<br>        Arrays.sort(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length &amp;&amp; start &lt; g.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= g[start]) &#123;<br>                cnt++;<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> start;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/wiggle-subsequence/description/">376. 摆动序列</a></li><li>文档讲解：<a href="https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html">代码随想录–376. 摆动序列</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV17M411b7NS/">贪心算法，寻找摆动有细节！| LeetCode：376.摆动序列</a></li><li>状态：没思路。看了视频，画<strong>坡度图</strong>才能看出来。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>正常情况下判断有没有摆动：prediff &lt; 0 &amp;&amp; curdiff &gt; 0  或者 prediff &gt; 0 &amp;&amp; curdiff &lt; 0<br><img src="https://file1.kamacoder.com/i/algo/20201124174327597.png" alt="正常情况"></p><p>局部最优：删除单一坡度上的节点，让峰值尽可能的保持峰值。局部最优推出全局最优，并且举不出反例，试试贪心。但本题要考虑3种情况：</p><ol><li>上下坡有平坡</li><li>数组只有首尾两个元素</li><li>单调坡中有平坡</li></ol><ul><li><p>情况1：上下坡中平坡<br><img src="https://file1.kamacoder.com/i/algo/20230106170449.png" alt="例如 [1,2,2,2,2,1]这样的数组"><br>如图，该数组的最长摆动序列是3，可以统一规则，删除左边的三个2，那么当 prediff &#x3D; 0 &amp;&amp; curdiff !&#x3D; 0时也要记录一个峰值，因此判断条件变为：</p><ul><li>prediff &lt;&#x3D; 0 &amp;&amp; curdiff &gt; 0  或者 prediff &gt;&#x3D; 0 &amp;&amp; curdiff &lt; 0</li><li>result初始为1（默认数组的最右边的元素是一个峰值）。</li></ul></li><li><p>情况2：数组有首尾两个元素<br>和情况一统一，假设第一个元素前还有一个一样的元素。</p></li><li><p>情况3：单调坡中有平坡<br><img src="https://file1.kamacoder.com/i/algo/20230108171505.png" alt="单调坡度有平坡"><br>这种情况下可以看出，我们不能实时更新prediff，只需要在这个坡度 摆动变化时才更新prediff。</p></li></ul><h2 id="2-2-解题小结"><a href="#2-2-解题小结" class="headerlink" title="2.2 解题小结"></a>2.2 解题小结</h2><p>本题画出坡度图，分析出要计算prediff和curdiff之后，还需要进一步考虑有平坡的情况，包括上下中间有平坡、单调有平坡的情况。</p><ul><li>贪心算法    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>376. 摆动序列      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preDiff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curDiff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            curDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-keyword">if</span> (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span> || preDiff &lt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &gt; <span class="hljs-number">0</span>) &#123;<br>                result++;<br>                preDiff = curDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><p>todo：动态规划解法</p><h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子序和</a></li><li>文档讲解：<a href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html">代码随想录–53. 最大子序和</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1aY4y1Z7ya/">贪心算法的巧妙需要慢慢体会！LeetCode：53. 最大子序和</a></li><li>状态：暴力枚举两层for循环。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><p>贪心算法，<strong>怎么想清楚贪的是哪里？局部最优在哪里？</strong></p><ul><li>如果 -2 1 在一起，计算起点的时候，一定是从 1 开始计算，因为<strong>负数只会拉低总和，这就是贪心贪的地方！</strong></li><li>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</li><li>全局最优：选取最大“连续和”</li></ul><h2 id="3-2-解题小结"><a href="#3-2-解题小结" class="headerlink" title="3.2 解题小结"></a>3.2 解题小结</h2><ul><li>贪心算法    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>53. 最大子序和      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            count += nums[i];<br>            <span class="hljs-keyword">if</span> (count &gt; result) result = count;<br>            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) count = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><p>todo：动态规划</p><h1 id="4-今日收获"><a href="#4-今日收获" class="headerlink" title="4. 今日收获"></a>4. 今日收获</h1><ul><li>贪心算法难点在于想清楚怎么贪，贪在哪里，局部最优在哪里吧，经过53.最大子序和有一些感触了。</li><li>学习时长：<span class="label label-primary">3小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day26 | {491.递增子序列, 46.全排列, 47.全排列II, 51.N皇后, 37.解数独}</title>
    <link href="/cn/day26_leetcode/"/>
    <url>/cn/day26_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第七章回溯算法part4，解决排列问题、棋盘问题，还是要抽象出树形结构好解题。</p><span id="more"></span><h1 id="491-非递减子序列"><a href="#491-非递减子序列" class="headerlink" title="491. 非递减子序列"></a>491. 非递减子序列</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491.非递减子序列</a></li><li>文档讲解：<a href="https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html">代码随想录–491.递增子序列</a></li><li>视频讲解：<a href="bilibili.com/video/BV1EG4y1h78v/">回溯算法精讲，树层去重与树枝去重 | LeetCode：491.递增子序列</a></li><li>状态：依旧是子集问题，但本题的去重和<strong>90.子集II</strong>是有区别的。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p>因为对给定的整数数组<strong>不能排序</strong>，所以相同的元素不一定相邻，本题<strong>需要用一个set集合来记录元素之前是否出现过</strong>，用以实现同一树层上的去重；同时，因为set集合仅表示同一树层的状态，不是全局路径级的，所以不需要回溯。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>491. 非递减子序列      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() &gt;= <span class="hljs-number">2</span>) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        &#125;<br>        Set&lt;Integer&gt; used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!path.isEmpty() &amp;&amp; nums[i] &lt; path.getLast()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span> (used.contains(nums[i])) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 去重</span><br><br>            path.add(nums[i]);<br>            used.add(nums[i]); <br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/permutations/description/">46.全排列</a></li><li>文档讲解：<a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">代码随想录–46.全排列</a></li><li>视频讲解：<a href="bilibili.com/video/BV19v4y1S79W/">组合与排列的区别，回溯算法求解的时候，有何不同？| LeetCode：46.全排列</a></li><li>状态：题本身比较简单，排列问题集合中的元素是有顺序的。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><ul><li><p>排列问题和之前的组合问题不同，排列问题是不需要定义startIndex的，体会这一点。</p></li><li><p>分析回溯算法三部曲：</p><ol><li><strong>参数和返回值是什么？</strong> <strong>排列问题需要一个used数组</strong>，用以记录哪些元素已经被选取过。</li><li><strong>确定递归的终止条件。</strong> 到达叶子节点时收割结果。</li><li><strong>确定单层搜索的过程。</strong> 与组合问题不同，for循环这里每次从0开始搜索，用used数组控制每个元素只能使用一次；递归纵向遍历，与回溯配合使用。</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>46. 全排列      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length]);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] used)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtracking(nums, used);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/permutations-ii/description/">47.全排列 II</a></li><li>文档讲解：<a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录–47.全排列 II</a></li><li>状态：本题 就是我们讲过的 40.组合总和II 去重逻辑 和 46.全排列 的结合。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><p>排列问题的去重也是一样的套路，注意去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了。</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>47. 全排列 II      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        backtracking(nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length]);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] used)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 去重</span><br>            <br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtracking(nums, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/n-queens/description/">51. N皇后</a></li><li>文档讲解：<a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html">代码随想录–51. N皇后</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Rd4y1c7Bq/">这就是传说中的N皇后？ 回溯算法安排！| LeetCode：51.N皇后</a></li><li>状态：怎么抽象出一个树形结构呢？难点在于本题要<strong>处理一个二维数组</strong>的回溯搜索。</li></ul>          </div><h2 id="4-1-解题分析"><a href="#4-1-解题分析" class="headerlink" title="4.1 解题分析"></a>4.1 解题分析</h2><p>之前说过，回溯搜索并不高效，其实就是通过递归来帮我们控制for循环嵌套的层数，对于一个4x4的棋盘，暴力搜索应该怎么做？4层for循环嵌套，每层去枚举该层的摆放位置对吧，回溯算法也是一样的。<br><img src="https://file1.kamacoder.com/i/algo/20210130182532303.jpg" alt="二维数组树形结构"></p><ul><li><p>分析回溯算法三部曲：</p><ol><li><strong>参数和返回值是什么？</strong> 定义全局变量result记录结果集；参数n是棋盘的大小，row表示递归到第几行了，chessBoard表示当前的二维数组棋盘。</li><li><strong>确定递归的终止条件。</strong> 当递归到棋盘的最底层，到达叶子节点，记录结果并终止本层递归。 </li><li><strong>确定单层搜索的过程。</strong> for循环横向遍历，每次都从当前行的起始位置开始选择（和暴力搜索一模一样），然后需要判断是否合法，不合法就剪枝；递归纵向遍历，和回溯配合使用。</li></ol></li><li><p>chessboard最好先**定义为char[][]**，方便回溯更改选择，String是不可变的。</p></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>51. N皇后      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;String&gt;&gt; result =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[][] chessboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            Arrays.fill(chessboard[i], <span class="hljs-string">&#x27;.&#x27;</span>);<br>        &#125;<br>        backtracking(chessboard, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chessboard, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            result.add(construct(chessboard));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!isValid(chessboard, row, i)) <span class="hljs-keyword">continue</span>;<br>            chessboard[row][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            backtracking(chessboard, row + <span class="hljs-number">1</span>, n);<br>            chessboard[row][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chessboard, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-comment">// 1.检查列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2.检查左上角</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 3.检查右上角</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; chessboard.length; i--, j++) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">construct</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(board[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>至此解决了<strong>棋盘问题</strong>的第一道题目，明确for循环的长度就是棋盘的宽度，递归的深度就是棋盘的高度，本题就能够抽象出树形结构，用回溯算法求解。</p><h1 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/sudoku-solver/description/">37.解数独</a></li><li>文档讲解：<a href="https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html">代码随想录–37.解数独</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1TW4y1471V/">回溯算法二维递归？解数独不过如此！| LeetCode：37. 解数独</a></li><li>状态：本题和N皇后是类似的，区别在于解数独这道题，棋盘的每一个位置都要确定数字，而不是每一行确定一个，因此解数独的树形结构要更宽，需要用到<strong>二维循环+递归</strong>。</li></ul>          </div><h2 id="5-1-解题分析"><a href="#5-1-解题分析" class="headerlink" title="5.1 解题分析"></a>5.1 解题分析</h2><p><img src="https://file1.kamacoder.com/i/algo/2020111720451790-20230310131816104.png" alt="解数独树形结构"></p><ul><li>分析回溯算法三部曲：<ol><li><strong>参数和返回值是什么？</strong> 返回值是boolean类型，找到一个可行的解就理解返回；参数就是输入的数独表。</li><li><strong>确定递归的终止条件。</strong> 不需要终止条件，把表填满，就到达了叶子节点，就会返回true。</li><li><strong>确定单层搜索的过程。</strong> 二层for循环确定数独表中的一个位置，对这个位置递归枚举数字1-9，如果都不合法返回false；有合法的则进入下一层递归，注意和回溯配合使用。</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>37. 解数独      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solveSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        backtracking(board);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; board[i].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; k++) &#123;<br>                        <span class="hljs-keyword">if</span> (isValid(board, i, j, k)) &#123;<br>                            board[i][j] = k;<br>                            <span class="hljs-keyword">if</span> (backtracking(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                            board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> k)</span> &#123;<br>        <span class="hljs-comment">// 1.检查行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; board[row].length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[row][j] == k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2.检查列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][col] == k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 3.检查3x3方块</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">startRow</span> <span class="hljs-operator">=</span> row / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startCol</span> <span class="hljs-operator">=</span> col / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="6-回溯算法总结"><a href="#6-回溯算法总结" class="headerlink" title="6. 回溯算法总结"></a>6. 回溯算法总结</h1><ul><li><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html">回溯总结篇</a></li><li>回溯是递归的副产品，只要有递归就会有回溯，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。<strong>回溯法就是暴力搜索</strong>，并不是什么高效的算法，最多再剪枝一下。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day25 | {93.复原IP地址, 78.子集, 90.子集II}</title>
    <link href="/cn/day25_leetcode/"/>
    <url>/cn/day25_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第七章回溯算法part03，分割问题、子集问题。分割问题要注意合法终止条件的判断。</p><span id="more"></span><h1 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/restore-ip-addresses/description/">93. 复原 IP 地址</a></li><li>文档讲解：<a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html">代码随想录–93. 复原 IP 地址</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1XP4y1U73i/">回溯算法如何分割字符串并判断是合法IP？| LeetCode：93.复原IP地址</a></li><li>状态：和昨天的分割字符串大体上是一样的，但是对于终止条件我想错了，以及没有剪枝。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><ul><li><p>分析回溯算法三部曲：</p><ol><li><strong>参数和返回值是什么？</strong> 需要一个startIndex，记录当前切割到哪里了</li><li><strong>确定递归的终止条件。</strong> 当遍历到字符串末尾，<span style="color:red">并且正好是4段字符串，</span>说明找到了一个可行解，加入到result中，本层递归终止；</li><li><strong>确定单层搜索的过程。</strong> for循环横向遍历，负责切割字符串，并且在这里判断数字是否符合ip地址的要求，递归纵向遍历，与回溯配合使用。</li></ol></li><li><p>第一遍做错的点：</p><ol><li>终止条件不完整，IP段数没限制，IP地址必须是4段，不能少，也不能多。</li><li>前导0判断逻辑是错的，把单个’0’这种情况判定为false；</li><li>剪枝晚了，对于超过3位数的数字串，不应该切割出来；</li><li>缺少剪枝1：当IP地址段数已经超过4段时，应该终止本层递归；</li><li>缺少剪枝2：当剩余的字符数量不合理时，也没有必要继续递归，应该提前终止。</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>93. 复原IP地址      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; result =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        backtracking(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() &gt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 剪枝</span><br>        <span class="hljs-keyword">if</span>(path.size() == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">if</span> (startIndex == s.length()) result.add(String.join(<span class="hljs-string">&quot;.&quot;</span>, path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remain</span> <span class="hljs-operator">=</span> s.length() - startIndex;  <span class="hljs-comment">// 剪枝：剩余字符数不合理</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> - path.size();<br>        <span class="hljs-keyword">if</span> (remain &lt; need || remain &gt; need * <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; s.length() &amp;&amp; i &lt; startIndex + <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(startIndex, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (!isSuit(sub)) <span class="hljs-keyword">continue</span>;<br>            <br>            path.add(sub);<br>            backtracking(s, i + <span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSuit</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 前导0判断</span><br>        <span class="hljs-keyword">if</span> (s.length() &gt; <span class="hljs-number">1</span> &amp;&amp; s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(s) &lt;= <span class="hljs-number">255</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/subsets/description/">78.子集</a></li><li>文档讲解：<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">代码随想录–78.子集</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1U84y1q7Ci/">回溯算法解决子集问题，树上节点都是目标集和！ | LeetCode：78.子集</a></li><li>状态：<strong>不需要任何剪枝</strong>，因为是收集树形结构中，每一个节点的结果。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><p>子集问题，和组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是<strong>收集树的叶子节点</strong>，而子集问题是<strong>找树的所有节点</strong>。子集问题也是一种组合问题，因为它的集合是无序的，子集{1,2}和子集{2,1}是一样的，因此，取过的元素不会重复取，需要startIndex控制遍历开始的位置。</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>78. 子集      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">private</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        <span class="hljs-keyword">if</span> (startIndex == nums.length) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123;<br>            path.add(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90. 子集II"></a>90. 子集II</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/subsets-ii/description/">90.子集II</a></li><li>文档讲解：<a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">代码随想录–90.子集II</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1vm4y1F71J/">回溯算法解决子集问题，如何去重？| LeetCode：90.子集II</a></li><li>状态：给的整数数组可能包含重复元素，<strong>要求去重</strong>。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><ul><li>和组合问题的去重一样，要先对整数数组排序，然后定义一个used数组，同一树层的元素如果一致要进行去重。</li></ul>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>90. 子集II      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        backtracking(nums, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length]);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">boolean</span>[] used)</span> &#123;<br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtracking(nums, i + <span class="hljs-number">1</span>, used);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li>但在本题中，实现同一树层的去重，实际上并不需要使用used数组，在同一层中，如果当前值和前一个值相同，跳过即可：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day24 | {39.组合总和, 40.组合总和II, 131.分割回文串}</title>
    <link href="/cn/day24_leetcode/"/>
    <url>/cn/day24_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第七章回溯算法part02，继续回溯法解决组合问题，思考问题之间限制条件的区别，以及考虑剪枝优化。</p><span id="more"></span><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/combination-sum/description/">39. 组合总和</a></li><li>文档讲解：<a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">代码随想录–39. 组合总和</a></li><li>视频讲解：<a href="bilibili.com/video/BV1KT4y1M7HJ/">带你学透回溯算法-组合总和（对应「leetcode」力扣题目：39.组合总和）| 回溯法精讲！</a></li><li>状态：本题的特点是节点是同一个集合，但集合中的元素可以重复选取，<strong>but需要控制for循环遍历的起始位置</strong>。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><p><span style="color: red">本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex？</span></p><ul><li><p>如果是一个集合来求组合的话，就需要startIndex</p></li><li><p>如果是多个集合求组合，各个集合之间互不影响，那就不用startIndex。</p></li><li><p>分析回溯算法三部曲：</p><ol><li><strong>参数和返回值是什么？</strong> 定义全局变量path、result列表；形参包括整数数组candidates、目标整数target（做减法），<span style="color:red">startIndex记录起始遍历下标</span></li><li><strong>确定递归的终止条件。</strong> 当target &lt;&#x3D; 0时就要返回了，如果正好等于0，则找到了一个可行解，记录到result中；</li><li><strong>确定单层搜索的过程。</strong> for循环用于横向遍历，从startIndex开始遍历集合中的每个元素；递归用于纵向遍历，注意和回溯配合使用。</li></ol></li><li><p>分析剪枝：在for循环的搜索范围上做文章，<strong>对总集合排序之后</strong>，如果下一层的target已经小于0，就没要进入下一层递归，结束本for循环遍历。</p></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>39. 组合总和      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) results.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; candidates.length &amp;&amp; target - candidates[i] &gt;= <span class="hljs-number">0</span>; i++) &#123;<br>            path.add(candidates[i]);<br>            backtracking(candidates, target - candidates[i], i);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40. 组合总和II"></a>40. 组合总和II</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/combination-sum-ii/">40.组合总和II</a></li><li>文档讲解：<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">代码随想录–40.组合总和II</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV12V4y1V73A/">回溯算法中的去重，树层去重树枝去重，你弄清楚了没？| LeetCode:40.组合总和II</a></li><li>状态：难点是怎么去重呢？解集中不能包含重复的组合。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><ul><li>本题的难点在于集合有重复元素，但还不能有重复的组合。如何去重？</li><li>所谓去重，其实就是<strong>使用过的元素</strong>不能重复选取。都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，<strong>一个维度是同一树枝上使用过，一个维度是同一树层上使用过。</strong>对于本题，应该在同一数层上去重。</li><li><strong>树层去重的话，需要对数组排序。</strong></li></ul><p><img src="https://file1.kamacoder.com/i/algo/20221021163812.png" alt="第一个1搜索之后已经包含了第二个1能搜索到的所有结果，所以在树层上应该去重"></p><ul><li><p>参数与上一题的区别在于：多使用了一个used数组，用来记录同一树枝上的元素是否使用过，而同一树层，used数组是<strong>回溯过去的</strong>。</p></li><li><p>单层搜索的逻辑，最大的不同就是要<strong>去重</strong>，要判断同一树层上相同的元素是否已经被使用过。</p></li><li><p>关于<strong>剪枝优化</strong>，在组合和已经超过目标target的情况下立即停止递归，而不是只在递归开始时检查target，从而减少不必要的递归调用和计算。</p></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>40. 组合总和II      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);  <span class="hljs-comment">// 排序是去重和剪枝的基础</span><br>        backtracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) results.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 去重</span><br>            <span class="hljs-keyword">if</span> (target &lt; candidates[i]) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 剪枝</span><br>            path.add(candidates[i]);<br>            backtracking(candidates, target - candidates[i], i + <span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串</a></li><li>文档讲解：<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">代码随想录–131.分割回文串</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1c54y1e7k6/">带你学透回溯算法-分割回文串（对应力扣题目：131.分割回文串）| 回溯法精讲！</a></li><li>状态：给一套分割方案，要让每个字串都是回文串，就算是暴力枚举也很难写。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><p>切割问题可以抽象为组合问题，也可以抽象为一棵树形结构，难点在于切割线在代码中如何体现？–在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。</p><p><img src="https://file1.kamacoder.com/i/algo/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="分割回文串-抽象为树形结构"></p><ul><li>分析回溯算法三部曲：<ol><li><strong>参数和返回值是什么？</strong> 定义全局变量path数组存放切割后的回文的子串，result数组存放结果集。形参还需要startIndex，已经切割过的地方不能重复切割。</li><li><strong>确定递归的终止条件。</strong> 切割线切到了字符串末尾，说明找到了一种切割方法，本层递归终止。</li><li><strong>确定单层搜索的过程。</strong> 判断这个子串是不是回文，放在单层递归中进行判断，for循环横向遍历时，截取子串。和回溯配合使用，纵向递归。</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>131. 分割回文串      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; path;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;String&gt;&gt; result;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtracking(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span>(startIndex == s.length()) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(startIndex, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (!isHuiWen(sub)) <span class="hljs-keyword">continue</span>;<br>            path.add(sub);<br>            backtracking(s, i + <span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHuiWen</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day23 | {77.组合, 216.组合总和III, 17.电话号码的字母组合}</title>
    <link href="/cn/day23_leetcode/"/>
    <url>/cn/day23_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第七章回溯算法part01，把问题抽象成树形结构，用回溯三部曲分析。</p><span id="more"></span><h1 id="0-理论基础"><a href="#0-理论基础" class="headerlink" title="0. 理论基础"></a>0. 理论基础</h1><h2 id="0-1-什么是回溯"><a href="#0-1-什么是回溯" class="headerlink" title="0.1 什么是回溯"></a>0.1 什么是回溯</h2><ul><li>回溯法也可以叫做<strong>回溯搜索法</strong>，它是一种搜索的方式。之前在二叉树系列题目中，提到过回溯是递归的副产品，有递归就会有回溯。</li></ul><h2 id="0-2-回溯法的效率"><a href="#0-2-回溯法的效率" class="headerlink" title="0.2 回溯法的效率"></a>0.2 回溯法的效率</h2><ul><li>虽然回溯法很难，但并不是什么高效的算法，<strong>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>。如果想让回溯法高效一些，可以加一些剪枝的操作，但也改变不了回溯法就是穷举的本质。</li><li>一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</li></ul><h2 id="0-3-回溯法解决的问题"><a href="#0-3-回溯法解决的问题" class="headerlink" title="0.3 回溯法解决的问题"></a>0.3 回溯法解决的问题</h2><ol><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20210219192050666.png" alt="题目分类"></p><h2 id="0-4-如何理解回溯法"><a href="#0-4-如何理解回溯法" class="headerlink" title="0.4 如何理解回溯法"></a>0.4 如何理解回溯法</h2><ul><li><strong>回溯法解决的问题都可以抽象为树形结构</strong>，用图形去理解它，所有的回溯法的问题都可以抽象为树形结构。</li><li>递归就要有终止条件，所有必然是一棵高度有限的树（N叉树）。</li></ul><h2 id="0-5-回溯法模板"><a href="#0-5-回溯法模板" class="headerlink" title="0.5 回溯法模板"></a>0.5 回溯法模板</h2><p>回溯法的函数起名字一般为<code>backtracking</code>，列出回溯三部曲：</p><ol><li>回溯函数的返回值以及参数</li></ol><ul><li>在回溯算法中，函数返回值一般为void。再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>回溯函数的终止条件<ul><li>既然是树形结构，和二叉树递归一样，遍历树形结构一定要有终止条件。什么时候到达了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就<strong>找到了满足条件的一条答案，</strong>把这个答案存放起来，并结束本层递归。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">if</span> (终止条件) &#123;<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>回溯搜索的遍历过程（单层搜索的逻辑）</li></ol><ul><li>回溯法一般是在集合中递归搜索，集合的大小构成了树的高度，递归的深度构成树的深度。<br>  <img src="https://file1.kamacoder.com/i/algo/20210130173631174.png" alt="我特意举例集合大小和孩子的数量是相等的！"></li><li>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</li><li>backtracking这里自己调用自己，实现递归。</li><li>从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，</strong>这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</li></ul><p>因此，回溯算法模板框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/combinations/">77. 组合</a></li><li>文档讲解：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">代码随想录–77. 组合</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1ti4y1L7cv/">带你学透回溯算法-组合问题（对应力扣题目：77.组合）| 回溯法精讲！</a></li><li>状态：单层搜索的逻辑中，往往是for循环+递归的，这个跟以前不一样啊。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><ul><li><p>本题直接的解法，是用for循环解决，比如当n&#x3D;4，k&#x3D;2时，可以用两个for循环，输出和示例中一样的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是当n&#x3D;20，k&#x3D;10时，就是10层for循环，虽然思路是这样的，但是写10层嵌套for循环也太不优雅了。怎么办呢？<strong>用回溯搜索法</strong>。</p></li><li><p>看了题解之后，可以发现回溯法和上面的嵌套for循环本质上是一样的，同样是穷举暴力搜索，区别是，暴力写法需要嵌套10层for循环，而回溯法用递归来解决嵌套层数的问题。递归来做层叠嵌套，每一次的递归中嵌套一个for循环，相当于开k层for循环。</p></li><li><p>回溯法解决的问题都可以抽象为抽象树形结构，将组合问题抽象为如下树形结构，直观看到回溯搜索和for循环一样都是暴力穷举：<br><img src="https://file1.kamacoder.com/i/algo/20201123195223940.png" alt="组合问题树形结构"></p></li><li><p>分析回溯算法三部曲：</p><ol><li><strong>参数和返回值是什么？</strong> 返回值为void，参数包括给定的整数n、k，当前遍历存储的path列表，存储所有结果的result列表。<span style="color:red">还需要一个参数int型变量startIndex，这个参数用于记录本层递归当中，集合从哪里开始遍历。</span></li><li><strong>确定递归的终止条件。</strong> 如果path的大小已经达到k，说明我们找到了一个子集大小为k的组合，找到了一个可行解，终止本层递归。并把结果保存道result列表里。</li><li><strong>确定单层搜索的过程。</strong> for循环是用来横向遍历的，遍历集合中的元素，用startIndex来控制起始遍历点，对于剪枝，也要通过for循环这里控制，对没有可能找到解的子节点直接剪掉；递归用来纵向遍历，和回溯配合使用。</li></ol></li><li><p>回溯搜索法–无剪枝</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>77. 组合      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtracking(n, k, <span class="hljs-number">1</span>, path, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= n; i++) &#123;<br>            path.add(i);<br>            backtracking(n, k, i + <span class="hljs-number">1</span>, path, result);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><p>关于<code>path</code>和<code>result</code>数组设置为形参还是全局变量：path不是每一层递归各自独立的副本，它是一条被不断修改、不断回退的同一条路径，两种写法都用的是同一个path对象、用的是同一个result容器，回溯逻辑不受影响，所以是等价的。不过path代表当前递归层正在处理什么，放在参数中是很适合的。</p><ul><li>回溯搜索法–剪枝优化</li></ul><p>如果for循环选择的起始位置之后的元素个数，已经不足以构成k个数了，那么就没有必要继续搜索，应该剪枝。</p><ol><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>77. 组合      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtracking(n, k, <span class="hljs-number">1</span>, path, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="hljs-number">1</span>; i++) &#123;<br>            path.add(i);<br>            backtracking(n, k, i + <span class="hljs-number">1</span>, path, result);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216. 组合总和III"></a>216. 组合总和III</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/combination-sum-iii/description/">216.组合总和III</a></li><li>文档讲解：<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">代码随想录–216.组合总和III</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1wg411873x/">和组合问题有啥区别？回溯算法如何剪枝？| LeetCode：216.组合总和III</a></li><li>状态：这题画图之后还是简单的。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><ul><li><p>分析回溯算法三部曲：</p><ol><li><strong>参数和返回值是什么？</strong> 返回值为void，参数包括n、k，一个startIndex，用于记录当前递归层，集合从哪里开始遍历，同时把path列表和result列表定义为全局变量，提高可读性，<span style="color:red">sum也要作为递归的参数传入！</span></li><li><strong>确定递归的终止条件。</strong> 如果path的大小已经达到了k，终止本层递归。如果path中元素的sum正好等于n，那么找到了一个可行解，在终止前把结果保存到result中。</li><li><strong>确定单层搜索的过程。</strong> for循环用于横向遍历，从startIndex开始，遍历当前节点的孩子（1-9）；递归用于纵向遍历，和回溯配合使用。</li></ol></li><li><p>第一遍写时犯的错误</p><ul><li>这题的核心状态是什么？我们在递归中，其实只关心三件事：</li><li><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>path.size()</td><td>已经选了几个数</td></tr><tr><td>sum</td><td>当前和是多少</td></tr><tr><td>startIndex</td><td>下一次能从哪个数开始选</td></tr><tr><td>所以<code>sum</code>必须是递归状态的一部分，而不是我需要的时候再从path里算出来。</td><td></td></tr></tbody></table></li><li>第二点，终止条件写错了，不管sum是不是n，达到个数了都必须要return，否则会继续往下选。</li></ul></li><li><p>关于<strong>剪枝</strong></p><ol><li>和已经超了，没必要继续搜索；</li><li>数量不可能凑够了。</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-738764b7" role="button" aria-expanded="false" aria-controls="collapse-738764b7">        <div class="fold-arrow">▶</div>216. 组合总和III      </div>      <div class="fold-collapse collapse" id="collapse-738764b7">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br><br>        backtracking(k, n, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sum &gt; n) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 剪枝 和已经超了</span><br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            <span class="hljs-keyword">if</span> (sum == n) result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.size()) + <span class="hljs-number">1</span>; i++) &#123;<br>            path.add(i);<br>            backtracking(k, n, i + <span class="hljs-number">1</span>, sum + i);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="2-2-题解总结"><a href="#2-2-题解总结" class="headerlink" title="2.2 题解总结"></a>2.2 题解总结</h2><ul><li>关于回溯三部曲，看了代码随想录之后，有了新的观点。<ul><li>首先，确定递归函数参数，这里sum这个参数也可以省略，每次targetSum减去选取的元素数值，做减法，如果targetSum &lt; 0了，那同样说明和已经超了。并且强调，<strong>回溯法中的递归函数参数很难一次性确定下来，一般先写逻辑，需要啥参数了，填什么参数。</strong></li><li>和已经超了这个剪枝，也可以放在 调用递归 之前，只不过和我想的不一样，还需要做回溯操作，代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 剪枝</span><br>    sum += i; <span class="hljs-comment">// 处理</span><br>    path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理</span><br>    <span class="hljs-keyword">if</span> (sum &gt; targetSum) &#123; <span class="hljs-comment">// 剪枝操作</span><br>        sum -= i; <span class="hljs-comment">// 剪枝之前先把回溯做了</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 剪枝之前先把回溯做了</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 注意i+1调整startIndex</span><br>    sum -= i; <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17.电话号码的字母组合</a></li><li>文档讲解：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">代码随想录–17.电话号码的字母组合</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1yV4y1V7Ug/">还得用回溯算法！| LeetCode：17.电话号码的字母组合</a></li><li>状态：暴力的for循环好想出来，但是怎么抽象成一个树形结构呢？？每个节点是 <strong>不同的集合</strong></li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><ul><li><p>将问题抽象为树形结构：<br><img src="https://file1.kamacoder.com/i/algo/20201123200304469.png" alt="输入：&quot;23&quot;，抽象为树形结构"></p></li><li><p>分析回溯算法三部曲：</p><ol><li><strong>参数和返回值是什么？</strong> 定义全局变量，一个stringbuilder s来记录当前结果，一个列表result记录所有可行解；形参包括给定的digits，一个int型变量index，是用来遍历digits的，记录遍历到第几个数字了。</li><li><strong>确定递归的终止条件。</strong> 当每个数字都被遍历过了，就收集结果，结束本层递归。</li><li><strong>确定单层搜索的过程。</strong> 首先取到index指向的数字，并且找到对应的字符集，返回for循环来处理这个字符集，注意递归和回溯配合。</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-5d5d193e" role="button" aria-expanded="false" aria-controls="collapse-5d5d193e">        <div class="fold-arrow">▶</div>17. 电话号码的字母组合      </div>      <div class="fold-collapse collapse" id="collapse-5d5d193e">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    String[] digitMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        backtracking(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            result.add(s.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> digits.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; digitMap[digit].length(); i++) &#123;<br>            s.append(digitMap[digit].charAt(i));<br>            backtracking(digits, index + <span class="hljs-number">1</span>);<br>            s.deleteCharAt(s.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li>和前两题不同，本题是多个集合求组合，所以抽象出的树形结构是上图所示的，相应的，回溯函数的形参中index所表示的含义也不一样。</li></ul><h1 id="4-今日收获"><a href="#4-今日收获" class="headerlink" title="4. 今日收获"></a>4. 今日收获</h1><ul><li>又开始新的知识点了，回溯算法实际上就是一种穷举的暴力搜索算法，解决此类问题要会把问题抽象成一个树形结构，在此基础上去分析参数、终止条件、以及单层搜索的逻辑。</li><li>学习时长：<span class="label label-primary">4小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day22 | {669.修剪二叉搜索树, 108.将有序数组转换为二叉搜索树, 538. 把二叉搜索树转换为累加树}</title>
    <link href="/cn/day22_leetcode/"/>
    <url>/cn/day22_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第六章二叉树part08，二叉搜索树的修改和改造。</p><span id="more"></span><h1 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a>669. 修剪二叉搜索树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></li><li>文档讲解：<a href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">代码随想录–669. 修剪二叉搜索树</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV17P41177ud/">你修剪的方式不对，我来给你纠正一下！| LeetCode：669. 修剪二叉搜索树</a></li><li>状态：和上题不同的是可能需要删除不止一个节点，判断遍历到的每个节点是否在区间内。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><ul><li><p>本题的重点也在讨论节点的终止条件上，不过和上一题不同，需要完整遍历一整个树，不能遇到要删除的节点就返回。相反，要利用二叉搜索树的价值，<strong>能在当前节点就判断整棵子树的命运，实现剪枝。</strong></p></li><li><p>分析递归三步曲：</p><ol><li><strong>参数和返回值是什么？</strong> 形参就是父递归给子递归的约束，然后返回修剪后的树的根节点。</li><li><strong>确定递归的终止条件。</strong> 如果当前遍历到了根节点，则返回null；如果遇到要删除的节点，<strong>继续递归判断</strong>可能符合区间条件的子树。</li><li><strong>确定单层递归的逻辑。</strong> 前序遍历，中左右，其实没有中的处理逻辑，重点在终止条件的处理上。</li></ol></li><li><p>前序遍历-递归法</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>669. 修剪二叉搜索树      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root.val &lt; low) <span class="hljs-keyword">return</span> trimBST(root.right, low, high);<br>        <span class="hljs-keyword">if</span> (root.val &gt; high) <span class="hljs-keyword">return</span> trimBST(root.left, low, high);<br>        root.left = trimBST(root.left, low, high);<br>        root.right = trimBST(root.right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a>108. 将有序数组转换为二叉搜索树</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108.将有序数组转换为二叉搜索树</a></li><li>文档讲解：<a href="https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">代码随想录–108.将有序数组转换为二叉搜索树</a></li><li>状态：构造一个BST，必须先构造根节点，适合采用前序遍历的方式。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><ul><li><p>数组的区间下标左闭右闭。</p></li><li><p>分析递归三步曲：</p><ol><li><strong>参数和返回值是什么？</strong> 需要传入一个升序的整数数组，构造树的数组起始下标，终止下标，返回一个TreeNode；</li><li><strong>确定递归的终止条件。</strong> 当数组起始下标 &gt; 终止下标时，返回null。</li><li><strong>确定单层递归的逻辑。</strong> 前序遍历，中左右，当前数组的长度&#x2F;2 即为根节点元素所在位置，以此为分割线，划分左子树区间和右子树区间。</li></ol></li><li><p>前序遍历-递归法</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>108. 将有序数组转换为二叉搜索树      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> buildBST(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[rootIndex]);<br>        root.left = buildBST(nums, left, rootIndex - <span class="hljs-number">1</span>);<br>        root.right = buildBST(nums, rootIndex + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538. 把二叉搜索树转换为累加树</a></li><li>文档讲解：<a href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html">代码随想录–538. 把二叉搜索树转换为累加树</a></li><li>状态：想象二叉搜索树 中序遍历之后是一个有序递增数组，这题就简单了。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><ul><li><p>暴力的方法是先遍历一遍获取一个树的totalSum，接着再中序遍历一遍，本轮的cuSum重新开始累加，然后遍历到哪个节点，就更新它的值为（totalSum - curSum）。</p></li><li><p>能不能只遍历一遍呢？那必须从后往前遍历，也就是<strong>右中左</strong>，并且<strong>反中序遍历</strong>这个二叉树，然后顺序累加即可。</p></li><li><p>分析递归三步曲：</p><ol><li><strong>参数和返回值是什么？</strong> 形参需要传入一个根节点，无需返回值，此外需要定义一个全局变量整数型pre，用于记录前一个结点的值。</li><li><strong>确定递归的终止条件。</strong> 如果当前遍历到空节点，则返回null。</li><li><strong>确定单层递归的逻辑。</strong> 反中序遍历，右中左，中：如果pre没有被赋值，给pre赋值，否则给pre加上当前值，然后更新当前节点的值。</li></ol></li><li><p>反中序遍历-递归法</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>538. 把二叉搜索树转换为累加树      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        reverseInOrder(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseInOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        reverseInOrder(node.right);<br>        pre += node.val;<br>        node.val = pre;<br>        reverseInOrder(node.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="4-二叉树章节总结"><a href="#4-二叉树章节总结" class="headerlink" title="4. 二叉树章节总结"></a>4. 二叉树章节总结</h1><ul><li><p><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0">二叉树：总结篇！（需要掌握的二叉树技能都在这里了）</a></p></li><li><p>33道题目，包含普通二叉树、二叉搜索树，可以看看打卡的博客回顾一下这8天做过的题目。</p><ul><li>什么样的题目适合什么遍历方式？</li><li>递归三步曲如何分析？</li><li>递归函数什么时候需要返回值，什么时候不需要？</li><li>递归函数什么需要回溯，什么时候不需要？</li><li>递归函数什么时候需要定义全局变量，什么时候不需要？</li></ul></li><li><p>涉及构造一个二叉树，无论是普通的二叉树还是二叉搜索树，一定是前序遍历，先构造根节点。</p></li><li><p>求普通二叉树的属性，一般是后序遍历，一般要通过递归函数的返回值做计算。</p></li><li><p>求二叉搜索树的属性，一定是中序遍历，不然浪费有序的特性。</p></li><li><p>学习时长：<span class="label label-primary">2小时</span></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>二叉搜索树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day21 | {235.二叉搜索树的最近公共祖先, 701.二叉搜索树中的插入操作, 450.删除二叉搜索树中的节点}</title>
    <link href="/cn/day21_leetcode/"/>
    <url>/cn/day21_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第六章二叉树part07，找二叉搜索树的最近公共祖先原来是前序遍历。</p><span id="more"></span><h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235. 二叉搜索树的最近公共祖先</a></li><li>文档讲解：<a href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">代码随想录–235. 二叉搜索树的最近公共祖先</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Zt4y1F7ww/">二叉搜索树找祖先就有点不一样了！| 235. 二叉搜索树的最近公共祖先</a></li><li>状态：左子树节点的值一定小于根节点的值，根节点的值又一定比右子树节点的值小。</li></ul>          </div><h2 id="1-1-递归法"><a href="#1-1-递归法" class="headerlink" title="1.1 递归法"></a>1.1 递归法</h2><ul><li><p>本题其实和在<strong>一个二叉搜索树中查找指定的值</strong>思路一样，也适合用<strong>前序遍历</strong>，当发现一个节点刚好在节点p和节点q时，它必定是两节点的公共祖先，同时也是最近祖先。</p></li><li><p>分析递归三步曲：</p><ol><li><strong>参数和返回值是什么？</strong> 要传入一个根节点，指定的节点p、节点q；返回值是找到的祖先节点</li><li><strong>确定递归的终止条件。</strong> 如果当前节点为空节点，则返回。</li><li><strong>确定单层递归的逻辑。</strong> 前序遍历，中左右，很简单的比较吧~</li></ol></li><li><p>前序遍历–递归</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>235. 二叉搜索树的最近公共祖先      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(Math.min(p.val, q.val) &lt;= root.val &amp;&amp; root.val &lt;= Math.max(p.val, q.val)) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Math.max(p.val, q.val) &lt; root.val) <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h2 id="1-2-迭代法"><a href="#1-2-迭代法" class="headerlink" title="1.2 迭代法"></a>1.2 迭代法</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>235. 二叉搜索树的最近公共祖先      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightVal</span> <span class="hljs-operator">=</span> Math.max(p.val, q.val);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftVal</span> <span class="hljs-operator">=</span> Math.min(p.val, q.val);<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (leftVal &lt;= root.val &amp;&amp; root.val &lt;= rightVal) <span class="hljs-keyword">return</span> root;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightVal &lt; root.val) root = root.left;<br>            <span class="hljs-keyword">else</span> root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701.二叉搜索树中的插入操作</a></li><li>文档讲解：<a href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html">代码随想录–701.二叉搜索树中的插入操作</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Et4y1c78Y/">原来这么简单？ | LeetCode：701.二叉搜索树中的插入操作</a></li><li>状态：这题用迭代法最简单。因为不是平衡二叉树，不用保持高度绝对值差的性质，直接找叶子节点就好了。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><ul><li>迭代法    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>701.二叉搜索树中的插入操作      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            pre = cur;<br>            <span class="hljs-keyword">if</span> (val &lt; cur.val) cur = cur.left;<br>            <span class="hljs-keyword">else</span> cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre.val &gt; val) pre.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-keyword">else</span> pre.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a>450. 删除二叉搜索树中的节点</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450.删除二叉搜索树中的节点</a></li><li>文档讲解：<a href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">代码随想录–450.删除二叉搜索树中的节点</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1tP41177us/?share_source=copy_web">调整二叉树的结构最难！| LeetCode：450.删除二叉搜索树中的节点</a></li><li>状态：考研过的思路都会吧，先查找树中是否存在给定要删除的key节点，如果是叶子节点，直接删除，如果是非叶子节点，为保持特性还要分情况讨论一下。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><ul><li><p>遍历只要保证左右就可以了，前序遍历</p></li><li><p>本题不需要遍历整个树，找到要删除的节点删除后就终止了，以下是终止情况的讨论：</p><ol><li>没找到要删除的key节点</li><li>要删除的节点是叶子节点</li><li>要删除的节点 左不空，右空</li><li>要删除的节点 左空，右不空</li><li>要删除的节点 左不空，右也不空</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>450. 删除二叉搜索树中的节点      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.right;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>                <span class="hljs-keyword">while</span> (cur.left != <span class="hljs-literal">null</span>) cur = cur.left;<br>                cur.left = root.left;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (key &lt; root.val) root.left = deleteNode(root.left, key);<br>        <span class="hljs-keyword">if</span> (key &gt; root.val) root.right = deleteNode(root.right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>注意左不空，右也不空时，还是和平衡二叉树的删除不太一样的，那个还要中序遍历找最近的节点，并且左旋右旋。本题比较暴力，不过题不要做复杂了。</p><h1 id="5-今日收获"><a href="#5-今日收获" class="headerlink" title="5. 今日收获"></a>5. 今日收获</h1><ul><li>继续二叉搜索树的练习，多思考、多利用二叉搜索树的特性解题。</li><li>学习时长：<span class="label label-primary">2小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day20 | {530.二叉搜索树的最小绝对差, 501.二叉搜索树中的众数, 236.二叉树的最近公共祖先}</title>
    <link href="/cn/day20_leetcode/"/>
    <url>/cn/day20_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第六章二叉树part06，二叉搜索树经过中序遍历之后是一个有序的递增序列，要利用好这一点。</p><span id="more"></span><h1 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a>530. 二叉搜索树的最小绝对差</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530.二叉搜索树的最小绝对差</a></li><li>文档讲解：<a href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">代码随想录–530.二叉搜索树的最小绝对差</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1DD4y11779/">二叉搜索树中，需要掌握如何双指针遍历！| LeetCode：530.二叉搜索树的最小绝对差</a></li><li>状态：即便提示了<strong>双指针</strong>，在利用二叉搜索树的有序递增特性上还是不熟练。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><ul><li>本题是一个二叉搜索树，遇到在BST上求最值、差值之类的问题，把它想成<strong>一个有序数组上求最值、求差值</strong>，这样就简单多了。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>530. 二叉搜索树的最小绝对差      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> result;<br>        result = Math.min(result, getMinimumDifference(root.left));<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>) result = Math.min(result, root.val- pre.val);<br>        pre = root;<br>        <span class="hljs-keyword">return</span> Math.min(result, getMinimumDifference(root.right));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a>501. 二叉搜索树中的众数</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501.二叉搜索树中的众数</a></li><li>文档讲解：<a href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html">代码随想录–501.二叉搜索树中的众数</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1fD4y117gp/">不仅双指针，还有代码技巧可以惊艳到你！ | LeetCode：501.二叉搜索树中的众数</a></li><li>状态：普通二叉树遍历一遍用map保存；二叉搜索树用中序遍历解决也简单的。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><ul><li><p>分析递归三步曲：</p><ol><li><strong>参数和返回值是什么？</strong> 要传入一个根节点，全局变量需要定义一个count记录出现次数，初始为0，一个最大出现次数maxCount，一个pre指针记录开始计数的位置；不需要返回值。</li><li><strong>确定递归的终止条件。</strong> 如果当前遍历到空节点了，就返回。</li><li><strong>确定单层递归的逻辑。</strong> 中序遍历，左中右，保证是一个非递减的遍历，注意当maxCount迎来更新时，要把目前暂存的“众数”结果全部弹出，再进行存入。</li></ol></li><li><p>注意这边就用到了昨天总结的<strong>关于递归函数什么时候需要定义全局变量？什么时候不需要？</strong></p><ol><li>当需要左右子树共享信息时，需要定义全局变量；</li><li>当每次递归是一个个独立的子问题时，不需要全局变量。</li></ol></li><li><p>再次强调形参的语义：<strong>形参&#x3D;父问题给子问题的约束</strong>。</p></li></ul>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>530. 二叉搜索树的最小绝对差      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    List&lt;TreeNode&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findMode(TreeNode root) &#123;<br>        getMode(root);<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>            result[i] = ans.get(i).val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMode</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        getMode(node.left);<br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">null</span>) count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre.val == node.val) count++;<br>        <span class="hljs-keyword">else</span> count = <span class="hljs-number">1</span>;<br>        pre = node;<br>        <span class="hljs-keyword">if</span> (count &gt;= maxCount) &#123;<br>            <span class="hljs-keyword">if</span> (count &gt; maxCount) &#123;<br>                <span class="hljs-keyword">while</span> (!ans.isEmpty()) ans.removeLast();<br>            &#125;<br>            ans.add(node);<br>            maxCount = count;<br>        &#125;<br>        getMode(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先</a></li><li>文档讲解：<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">代码随想录–236. 二叉树的最近公共祖先</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1jd4y1B7E2/">自底向上查找，有点难度！ | LeetCode：236. 二叉树的最近公共祖先</a></li><li>状态：一看就适合用<strong>后序遍历</strong>的方式解决。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><ul><li><p>审题，本题的二叉树中，所有节点的值均不相同，所以节点p或q的值不可能在树中出现两次。</p></li><li><p>分析递归三步曲：</p><ol><li><strong>参数和返回值是什么？</strong> 要传入一个根节点，指定的节点p、节点q；返回值是TreeNode</li><li><strong>确定递归的终止条件。</strong> 如果当前遍历到空节点，则返回null；如果当前遍历到q节点或p节点，则直接返回该节点。</li><li><strong>确定单层递归的逻辑。</strong> 后序遍历，左右中，情况1，如果左子树和右子树返回的结果均不为空，那么当前节点就是最近的公共祖先；情况2，如果左子树或右子树其中一个为空，另一个不为空，继续向上返回不为空的结果，此种情况最好结合画图理解。<br><img src="https://file1.kamacoder.com/i/algo/20210204151125844.png" alt="情况2示例图"></li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>530. 二叉搜索树的最小绝对差      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">leftRes</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightRes</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-keyword">if</span> (leftRes != <span class="hljs-literal">null</span> &amp;&amp; rightRes != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftRes == <span class="hljs-literal">null</span> &amp;&amp; rightRes != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> rightRes;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftRes != <span class="hljs-literal">null</span> &amp;&amp; rightRes == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> leftRes;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="5-今日收获"><a href="#5-今日收获" class="headerlink" title="5. 今日收获"></a>5. 今日收获</h1><ul><li>对于一个二叉搜索树，第一时间要想到它中序遍历之后是一个递增的有序序列的特性。接着将求最值、求差值问题，自然地转化为一个有序数组中求最值&#x2F;差值的问题。</li><li>继续巩固了<strong>关于递归函数什么时候需要定义全局变量？什么时候不需要</strong>的问题，能够掌握了。</li><li>学习时长：<span class="label label-primary">2.5小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>二叉搜索树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day18 | {654.最大二叉树, 617.合并二叉树, 700.二叉搜索树中的搜索, 98.验证二叉搜索树}</title>
    <link href="/cn/day18_leetcode/"/>
    <url>/cn/day18_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第六章二叉树part05，利用二叉搜索树的特性分析递归三步曲。</p><span id="more"></span><h1 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/maximum-binary-tree/">654.最大二叉树</a></li><li>文档讲解：<a href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html">代码随想录–654.最大二叉树</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1MG411G7ox/">又是构造二叉树，又有很多坑！| LeetCode：654.最大二叉树</a></li><li>状态：与106类似，递归的时候<strong>没有必要构造新数组</strong>，建议操作下标。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><ul><li><p>分析递归三步曲：</p><ol><li><strong>参数和返回值是什么？</strong> 要传入一个nums数组，当前递归区间的起点&amp;终点，返回一个当前子树的根节点TreeNode。</li><li><strong>确定递归的终止条件。</strong> 如果当前区间长度&#x3D;&#x3D;0，return null; 如果当前区间长度&#x3D;&#x3D;1，return 构造好的节点；</li><li><strong>确定单层递归的逻辑。</strong> 构造二叉树的题目，必须采用中左右的顺序，先构造出根节点（<strong>适合前序遍历语义</strong>）。</li></ol></li><li><p>前序遍历–递归法（数组区间左闭右闭）</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>654. 最大二叉树      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> construct(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">construct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[left]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxVal</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; maxVal) &#123;<br>                maxVal = nums[i];<br>                maxIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(maxVal);<br>        root.left = construct(nums, left, maxIndex - <span class="hljs-number">1</span>);<br>        root.right = construct(nums, maxIndex + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树</a></li><li>文档讲解：<a href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html">代码随想录–617.合并二叉树</a></li><li>视频讲解：<a href="bilibili.com/video/BV1m14y1Y7JK/">一起操作两个二叉树？有点懵！| LeetCode：617.合并二叉树</a></li><li>状态：感觉适合自顶向下的操作，前序遍历。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><ul><li><p>注意：</p><ul><li>同步遍历过程中，如果其中有一个节点已经遍历到null，此时return的是另一个二叉树的结点（<strong>带它的子树</strong>），且作为终止条件。</li><li>直接操作tree1 或 重新定义一个二叉树，第一种方式空间复杂度更低。</li></ul></li><li><p>前序遍历–递归法</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>617. 合并二叉树      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span>(root2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root1;<br>        root1.val += root2.val;<br>        root1.left = mergeTrees(root1.left, root2.left);<br>        root1.right = mergeTrees(root1.right, root2.right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a>700. 二叉搜索树中的搜索</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700.二叉搜索树中的搜索</a></li><li>文档讲解：<a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">代码随想录–700.二叉搜索树中的搜索</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1wG411g7sF/">不愧是搜索树，这次搜索有方向了！| LeetCode：700.二叉搜索树中的搜索</a></li><li>状态：Binary Search Tree，二叉搜索树是一个有序树，符合<strong>左&lt;根&lt;右</strong>的特性。</li></ul>          </div><h2 id="3-1-递归法"><a href="#3-1-递归法" class="headerlink" title="3.1 递归法"></a>3.1 递归法</h2><ul><li>分析递归三步曲：<ol><li><strong>参数和返回值是什么？</strong> 参数和leetcode给的一样，返回找到的节点；</li><li><strong>确定递归的终止条件。</strong> 如果当前遍历到的节点为空，或者找到了目标值对应的节点，return该节点；</li><li><strong>确定单层递归的逻辑。</strong> 本题如果采用递归法，属于有返回值的递归函数，那么父递归要基于子递归返回的结果进行判断，需定义一个临时变量接住这个结果。</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>700. 二叉搜索树中的搜索      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> || root.val == val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(val &lt; root.val) result = searchBST(root.left, val);<br>        <span class="hljs-keyword">if</span>(val &gt; root.val) result = searchBST(root.right, val);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="3-2-迭代法"><a href="#3-2-迭代法" class="headerlink" title="3.2 迭代法"></a>3.2 迭代法</h2><p>二叉搜索树的迭代法比普通二叉树要简单很多，因为本身就是一个有序树，不需要回溯的过程，节点的有序性已经帮我们确定了搜索的方向。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>700. 二叉搜索树中的搜索      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root.val == val) <span class="hljs-keyword">return</span> root;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; val) root = root.left;<br>            <span class="hljs-keyword">else</span> root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></li><li>文档讲解：<a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">代码随想录–98.验证二叉搜索树</a></li><li>视频讲解：<a href=""></a></li><li>状态：在<strong>中序遍历</strong>下，输出的二叉搜索树节点的数值是有序序列。</li></ul>          </div><h2 id="4-1-解题分析"><a href="#4-1-解题分析" class="headerlink" title="4.1 解题分析"></a>4.1 解题分析</h2><ul><li><p>利用BST中序遍历后有序递增的特性，验证一个树是否是有效二叉搜索树可以转化为<strong>判断中序遍历后的元素是否严格递增</strong>。</p></li><li><p>分析递归三步曲：</p><ol><li><strong>参数和返回值是什么？</strong> 要传入一个根节点，返回boolean类型。此外还需要<strong>一个全局的变量</strong>不断更新最大值，和目前递归到的元素进行比较。</li><li><strong>确定递归的终止条件。</strong> 遍历到节点为空时，返回true</li><li><strong>确定单层递归的逻辑。</strong> 中序遍历，左中右，父递归要接住子递归的返回值，并且如果为false，不用再继续遍历了。当前层操作是比较遍历到的节点值是否比maxVal大。</li></ol></li><li><p>中序遍历-递归（有全局变量）</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>98. 验证二叉搜索树      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Long</span> <span class="hljs-variable">maxVal</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!isValidBST(root.left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.val &lt;= maxVal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        maxVal = (<span class="hljs-type">long</span>) root.val;<br>        <span class="hljs-keyword">return</span> isValidBST(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。这启示我们可以定义一个递归函数<code>helper(root, lower, upper)</code>来递归判断，函数表示以root为根的子树，判断子树中所有节点的值是否都在(l, r)的范围内。符合前序遍历的语义。</p></li><li><p>前序遍历-递归（无全局变量）</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>98. 验证二叉搜索树      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(Long.MIN_VALUE, root, Long.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">long</span> lower, TreeNode root, <span class="hljs-type">long</span> upper)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!(lower &lt; root.val &amp;&amp; root.val &lt; upper)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!helper(lower, root.left, root.val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> helper(root.val, root.right, upper);<br>    &#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h2 id="4-2-关于递归函数什么时候需要一个全局变量"><a href="#4-2-关于递归函数什么时候需要一个全局变量" class="headerlink" title="4.2 关于递归函数什么时候需要一个全局变量"></a>4.2 关于递归函数什么时候需要一个全局变量</h2><ul><li><p>这道BST题，为什么需要全局变量？</p><ol><li>因为通过中序遍历验证BST的正确性，本质上是把一个树拉平成一个递增序列，我在做的是<strong>一次线性扫描</strong>，而不是<strong>独立的子问题</strong>。</li><li>换句话说，序列的前一个元素不属于任何一个子树，而是属于遍历过程本身，所以需要借助外部的全局变量。返回值无法携带这份信息，或者说携带起来很别扭： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br> <span class="hljs-type">boolean</span> isValid;<br> <span class="hljs-type">long</span> maxVal;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>递归类型1：信息只向上返回（不需要全局变量）</p><ul><li>特点：子问题算完，只把结果返回给父节点，父节点不关心子节点之外的历史。</li><li>典型例子：最大深度&#x2F;是否平衡二叉树&#x2F;是否对称</li></ul></li><li><p>递归类型2：<strong>信息要在兄弟子树之间共享</strong>（需要全局变量）</p><ul><li>例如本题，root需要知道左子树已经访问过的最后一个值。</li></ul></li><li><p>相反，解法二上下界法每一层的信息完整，不需要共享历史，不因此不用定义全局变量。</p></li></ul><h1 id="5-今日收获"><a href="#5-今日收获" class="headerlink" title="5. 今日收获"></a>5. 今日收获</h1><ul><li><strong>递归形参的语义是什么？</strong>形参&#x3D;父问题给子问题的约束，每个子树是自洽的独立问题。</li><li><strong>关于什么时候需要定义全局变量？</strong>子树之间需要共享历史，不属于任何一个独立的子问题时。</li><li>今天引入了二叉搜索树，与普通二叉树不同的有序特性要好好思考利用，就和之前的完全二叉树特性一样，往往是解题的关键。</li><li>学习时长：<span class="label label-primary">3小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>二叉搜索树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day17 | {513.找树左下角的值, 112.路径总和, 106.从中序与后序遍历序列构造二叉树}</title>
    <link href="/cn/day17_leetcode/"/>
    <url>/cn/day17_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第六章二叉树part04，继续练习递归三步曲，注意局部变量什么时候需要回溯、什么时候不需要。</p><span id="more"></span><h1 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a>513. 找树左下角的值</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513. 找树左下角的值</a></li><li>文档讲解：<a href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html">代码随想录–513. 找树左下角的值</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1424y1Z7pn/">怎么找二叉树的左下角？ 递归中又带回溯了，怎么办？| LeetCode：513.找二叉树左下角的值</a></li><li>状态：本题适用于<strong>前序遍历</strong>，但似乎涉及到回溯。</li></ul>          </div><h2 id="1-1-解题分析"><a href="#1-1-解题分析" class="headerlink" title="1.1 解题分析"></a>1.1 解题分析</h2><ul><li><p>要求的最底层的第一个节点值，并不一定是左孩子，我题意就理解错了。久命。</p></li><li><p>等价于求深度最大的第一个叶节点，本题递归使用前序、中序、后序遍历都可以，因为中不做任何处理，只要保证左右 <strong>左</strong>先遍历到即可。</p></li><li><p>分析递归三步曲</p><ol><li><strong>参数和返回值是什么？</strong> 要传入一个根节点，一个depth记录深度。返回void。全局变量result记录结果值。</li><li><strong>确定递归的终止条件。</strong> 当遍历到叶节点时终止递归，同时在这里判断最大深度是否比之前更高，如果是，更新结果值。</li><li><strong>确定单层递归的逻辑。</strong> 前序遍历，中左右，递归左子树，递归右子树，深度+1（一个递归对应一个回溯）</li></ol></li><li><p>层序遍历做这道题很简单。会了跳过。</p></li></ul><h2 id="1-2-解题小结"><a href="#1-2-解题小结" class="headerlink" title="1.2 解题小结"></a>1.2 解题小结</h2><ul><li><p>前序遍历–递归+回溯</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>513. 找树左下角的值      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDepth</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-type">int</span> result;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        preOrder(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (maxDepth &lt; depth) &#123;<br>                result = node.val;<br>                maxDepth = depth;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) &#123;<br>            depth++;<br>            preOrder(node.left, depth);<br>            depth--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) &#123;<br>            depth++;<br>            preOrder(node.right, depth);<br>            depth--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>前序遍历–递归+回溯（回溯隐藏在传参中）</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>513. 找树左下角的值      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDepth</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-type">int</span> result;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        preOrder(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (maxDepth &lt; depth) &#123;<br>                result = node.val;<br>                maxDepth = depth;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) preOrder(node.left, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) preOrder(node.right, depth+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和</a></li><li>文档讲解：<a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">代码随想录–112. 路径总和</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV19t4y1L7CR/">拿不准的遍历顺序，搞不清的回溯过程，我太难了！ | LeetCode：112. 路径总和</a></li><li>状态：路径总和本质上是一个<strong>自顶向下</strong>的问题。适合<strong>先处理当前节点，再处理子树</strong>，是前序遍历的语义。</li></ul>          </div><h2 id="2-1-解题分析"><a href="#2-1-解题分析" class="headerlink" title="2.1 解题分析"></a>2.1 解题分析</h2><ul><li>本题找到一个可行的路径就可以终止，<strong>不需要遍历整个树</strong>。</li><li>计数器参数传入<code>TargetSum</code>，做减法不做加法回溯起来更方便。</li><li>分析递归三步曲<ol><li><strong>参数和返回值是什么？</strong> 要传入一个根节点，一个int类型的计数器；返回值为boolean类型。</li><li><strong>确定递归的终止条件。</strong> 如果遍历到叶子节点并且刚好和为目标值，则返回true，如果遍历到叶子节点但和不等于目标值，返回false。</li><li><strong>确定单层递归的逻辑。</strong> 中左右。注意因为递归函数有返回值，所以当某个父节点调用子节点递归，结果返回true时，找到可行解，继续向上返回true。</li></ol></li></ul><h2 id="2-2-递归函数的返回值"><a href="#2-2-递归函数的返回值" class="headerlink" title="2.2 递归函数的返回值"></a>2.2 递归函数的返回值</h2><ul><li>递归函数什么时候需要返回值？什么时候不需要返回值？<ol><li>第一类：父节点要<strong>根据子节点的结果</strong>来做判断或计算。<ul><li>返回<code>boolean/int/Treenode</code></li><li>子递归结果会被用来判断&#x2F;计算&#x2F;组合</li><li>模板<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(node)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(node.left);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(node.right);<br>    <span class="hljs-keyword">return</span> 某个基于 left / right 的结果;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><ul><li>总结目前写过的题，属于这一类的有：</li><li><table><thead><tr><th>题目</th><th>返回值</th></tr></thead><tbody><tr><td>112路径总和</td><td>boolean</td></tr><tr><td>110平衡二叉树</td><td>int（高度）</td></tr><tr><td>101对称二叉树</td><td>boolean</td></tr><tr><td>404左叶子之和</td><td>int</td></tr></tbody></table></li></ul><ol start="2"><li>第二类：递归只是为了“遍历+修改外部状态”<ul><li>返回<code>void</code></li><li><strong>真正的结果存在：</strong><ul><li><strong>全局变量</strong> </li><li><strong>传入的List&#x2F;StringBuilder中</strong></li></ul></li><li>模板<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(node)</span> &#123;<br>       做一些事;<br>       dfs(node.left);<br>       dfs(node.right);<br>   &#125;<br></code></pre></td></tr></table></figure></li><li>常见的场景包括：收集路径、收集所有结果、存储节点。</li></ul></li></ol></li></ul><h2 id="2-3-关于回溯"><a href="#2-3-关于回溯" class="headerlink" title="2.3 关于回溯"></a>2.3 关于回溯</h2><ul><li><strong>回溯 &#x3D; 改了某个共享变量，用完必须改回去</strong></li><li>本题不需要对count回溯，因为<ul><li><code>count</code>是一个基本类型<code>int</code>；</li><li><strong>Java是值传递</strong></li><li>每一层递归都会得到自己的count副本</li></ul></li></ul><p>因此我改动的是当前栈帧里的<code>count</code>，不是父递归里的<code>count</code>，不需要回溯，如果是List&lt;&gt;数组，比如<strong>路径收集问题</strong>，就需要回溯。</p><ul><li>因为数组是引用类型</li><li>所有递归公用</li><li>不回溯就会污染其他分支</li></ul><p>所以第一题<strong>513. 找树左下角的值</strong>其实也是值传递，不需要回溯，为了学习回溯的思想把这个过程展示出来了。</p><h2 id="2-4-解题小结"><a href="#2-4-解题小结" class="headerlink" title="2.4 解题小结"></a>2.4 解题小结</h2><ul><li><p>前序遍历–递归</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>112. 路径总和      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        targetSum -= root.val;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> targetSum == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(hasPathSum(root.left, targetSum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (hasPathSum(root.right, targetSum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>前&#x2F;中&#x2F;后序遍历–视频中的解法（关键区别是count先减去当前节点的值再进入遍历）</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>112. 路径总和      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> traversal(root, targetSum - root.val);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span> &amp;&amp; traversal(node.left, count - node.left.val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span> &amp;&amp; traversal(node.right, count - node.right.val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h2 id="113-路径总和II"><a href="#113-路径总和II" class="headerlink" title="113. 路径总和II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和II</a></h2><p>本题明确要求收集所有符合条件的路径，递归只是为了遍历，不需要返回值。参数是引用类型，需要回溯。</p><ul><li><p>分析递归三步曲：</p><ol><li><strong>参数和返回值是什么？</strong> 要传入一个根节点，一个int计数器，一个记录路径的数组，一个结果集数组。</li><li><strong>确定递归的终止条件。</strong> 当遍历到叶子节点且count刚好为0时，找到一个可行解，计入结果集数组。</li><li><strong>确定单层递归的逻辑。</strong> 任意遍历，<del>中</del>左右，如果左子树不为空，减去左子树节点的节点值，把节点加入path数组，接着递归调用左子树；右子树一样处理。注意对引用类型进行回溯。</li></ol></li><li><p>第一遍解题，前序+回溯的思路是对的，但有3个小错误，也有涉及JAVA API用法</p><ol><li><strong>路径没有加根节点。</strong> 我在调用前<code>targetSum - root.val</code>，但是没有把<code>root.val</code>加入path路径，导致所有路径都<strong>缺少根节点</strong>；</li><li><strong>左右子树相互污染了count状态。</strong> count作为同一个局部变量，在left分支扣了一次，right分支用的是已经被扣过的count，应该不改当前count；</li><li><span style="color:blue"><strong><code>result.add(path)</code>直接加入引用，没有拷贝。</strong></span> 这代表：<ul><li><code>path</code>是一个对象</li><li>我加入的是<strong>同一个引用</strong></li><li>后续<code>path.pollLast()</code>会修改它</li><li>最终<code>result</code>里所有路径都指向它，并且都为空</li><li><span style="color:blue">正确做法：必须深拷贝</span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br></code></pre></td></tr></table></figure></li></ul></li></ol></li><li><p>总结：<strong>113 &#x3D; 前序遍历 + 回溯 + 深拷贝</strong></p><ul><li>进入节点：<code>path.add</code></li><li>离开节点：<code>path.remove</code></li><li>加入结果：<code>new ArrayList&lt;&gt;(path)</code></li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dfb167e8" role="button" aria-expanded="false" aria-controls="collapse-dfb167e8">        <div class="fold-arrow">▶</div>113. 路径总和II      </div>      <div class="fold-collapse collapse" id="collapse-dfb167e8">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> ans;<br>        path.offerLast(root.val);<br>        preOrder(root, targetSum - root.val, path, ans);<br>        path.pollLast();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> count, LinkedList&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span> &amp;&amp; count == <span class="hljs-number">0</span>) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) &#123;<br>            path.offerLast(node.left.val);<br>            preOrder(node.left, count - node.left.val, path, result);<br>            path.pollLast();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) &#123;<br>            path.offerLast(node.right.val);<br>            preOrder(node.right, count - node.right.val, path, result);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h3 id="2-5-1-JAVA-API-细节"><a href="#2-5-1-JAVA-API-细节" class="headerlink" title="2.5.1 JAVA API 细节"></a>2.5.1 JAVA API 细节</h3><ul><li><p>第一遍我把path定义为<code>LinkedList</code>数组类型，因为需要回溯，但这个类型效率不是最高的（链表不是连续内存，每个节点是对象，前后都有指针内存占用大），在面试中更推荐使用<code>ArrayList + 回溯</code>，或者<code>ArrayDeque</code>循环数组。</p><ul><li><p><code>ArrayList + 回溯</code></p><p>原来可以通过<code>path.size() - 1</code>确定弹出最后一个元素，学到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>path.add(node.val);<br>dfs(...);<br>path.remove(path.size() - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>ArrayDeque + 回溯</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>path.addLast(node.val);<br>dfs(...);<br>path.removeLast();<br></code></pre></td></tr></table></figure></li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8e159bd8" role="button" aria-expanded="false" aria-controls="collapse-8e159bd8">        <div class="fold-arrow">▶</div>113. 路径总和II      </div>      <div class="fold-collapse collapse" id="collapse-8e159bd8">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> ans;<br>        path.add(root.val);<br>        preOrder(root, targetSum - root.val, path, ans);<br>        path.remove(path.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> count, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span> &amp;&amp; count == <span class="hljs-number">0</span>) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) &#123;<br>            path.add(node.left.val);<br>            preOrder(node.left, count - node.left.val, path, result);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) &#123;<br>            path.add(node.right.val);<br>            preOrder(node.right, count - node.right.val, path, result);<br>            path.remove(path.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h3 id="2-5-2-关于path深拷贝"><a href="#2-5-2-关于path深拷贝" class="headerlink" title="2.5.2 关于path深拷贝"></a>2.5.2 关于path深拷贝</h3><ul><li>这句代码的真实含义是：把<code>path</code>这个对象的地址，放进result里。回溯会修改这个引用指向的对象，所以必须用深拷贝保存一份<strong>当时的快照。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>result.add(path);<br></code></pre></td></tr></table></figure></li><li>这行代码做了什么？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path);<br></code></pre></td></tr></table></figure>它会：<ol><li>创建一个<strong>新的ArrayList对象</strong>；</li><li>把<code>path</code>里当前的元素<strong>逐个复制进去</strong>；</li><li>返回一个<strong>和path内容相同，但完全独立的对象</strong></li></ol></li></ul><h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树</a></li><li>文档讲解：<a href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">代码随想录–106. 从中序与后序遍历序列构造二叉树</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1vW4y1i7dn/">坑很多！来看看你掉过几次坑 | LeetCode：106.从中序与后序遍历序列构造二叉树</a></li><li>状态：考研过的都会思路，利用后序遍历找根节点，去分割中序遍历，找到左右子树，递归左右子树找根节点。</li></ul>          </div><h2 id="3-1-解题分析"><a href="#3-1-解题分析" class="headerlink" title="3.1 解题分析"></a>3.1 解题分析</h2><ul><li>题目给了前提条件，<code>inorder</code>和<code>postorder</code>都由不同的值组成。</li><li>本题对我来说，难点在于确定递归的终止条件，只看后序数组（视频讲解），当后序数组为0时，返回空节点；或者当后序数组中有一个元素时，构造好节点之后return。</li><li>做题步骤（画个图分析就清楚了）<ol><li>后序数组为0，空节点；</li><li>后序数组最后一个元素为节点元素</li><li>寻找中序数组位置作为切割点</li><li>切中序数组</li><li>切后序数组</li><li>递归处理左区间右区间</li></ol></li></ul><h2 id="3-2-解题小结"><a href="#3-2-解题小结" class="headerlink" title="3.2 解题小结"></a>3.2 解题小结</h2><ul><li><p>切后序数组的时候，注意是依据中序数组的长度来切分。（举例画图看着写就简单）</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-c21ca059" role="button" aria-expanded="false" aria-controls="collapse-c21ca059">        <div class="fold-arrow">▶</div>106. 从中序与后序遍历序列构造二叉树      </div>      <div class="fold-collapse collapse" id="collapse-c21ca059">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">if</span> (postorder.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(postorder[postorder.length - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (postorder.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i] == postorder[postorder.length - <span class="hljs-number">1</span>]) &#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] inLeft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[index];<br>        System.arraycopy(inorder, <span class="hljs-number">0</span>, inLeft, <span class="hljs-number">0</span>, index);<br>        <span class="hljs-type">int</span>[] inRight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[inorder.length - index - <span class="hljs-number">1</span>];<br>        System.arraycopy(inorder, index + <span class="hljs-number">1</span>, inRight, <span class="hljs-number">0</span>, inRight.length);<br>        <span class="hljs-type">int</span>[] postLeft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[index];<br>        System.arraycopy(postorder, <span class="hljs-number">0</span>, postLeft, <span class="hljs-number">0</span>, index);<br>        <span class="hljs-type">int</span>[] postRight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[inRight.length];<br>        System.arraycopy(postorder, inLeft.length, postRight, <span class="hljs-number">0</span>, inRight.length);<br><br>        root.left = buildTree(inLeft, postLeft);<br>        root.right = buildTree(inRight, postRight);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p><code>System.arraycopy</code>是native方法，本身并不慢，但是我在递归中反复调用它，对于每一层递归：</p><ul><li>都在新建4个数组</li><li>都在复制O(n)的数据</li><li>整个树递归下来，总时间复杂度退化为O(n^2)，出现在树极端不平衡的时候；空间复杂度也很高(大量临时数组)。</li></ul></li><li><p>应该换一种思路，<strong>数组本身不用切，用下标区间来表示子数组</strong>;</p></li><li><p>再加上一个关键优化：<strong>用HashMap记录inorder中每个值的位置</strong>，避免每次O(n)去找根节点。</p></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-98e16488" role="button" aria-expanded="false" aria-controls="collapse-98e16488">        <div class="fold-arrow">▶</div>106. 从中序与后序遍历序列构造二叉树      </div>      <div class="fold-collapse collapse" id="collapse-98e16488">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            indexMap.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> build(inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> postLeft, <span class="hljs-type">int</span> postRight)</span> &#123;<br>        <span class="hljs-keyword">if</span> (postLeft &gt; postRight) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> postorder[postRight];<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> indexMap.get(rootVal);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> index - inLeft;  <span class="hljs-comment">// 错误点：只有个数可以传递，下标并不对齐</span><br><br>        root.left = build(inorder, inLeft, index - <span class="hljs-number">1</span>, postorder, postLeft, postLeft + leftSize - <span class="hljs-number">1</span>);<br>        root.right = build(inorder, index + <span class="hljs-number">1</span>, inRight, postorder, postLeft + leftSize, postRight - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树</a></h2><ul><li>第一遍写还是没搞清楚递归的语义，在递归函数里，我每一层都固定用preOrder[0]当根，但实际上<strong>当前子树的根</strong>应该是<code>preOrder[preLeft]</code>，而不是整个树的第一个元素。前面优化106也是一样。关键是<strong>递归函数中，永远只看当前递归到的那一段子区间</strong>，不要把第一层模拟进去。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-1607c597" role="button" aria-expanded="false" aria-controls="collapse-1607c597">        <div class="fold-arrow">▶</div>105. 从前序与中序遍历序列构造二叉树      </div>      <div class="fold-collapse collapse" id="collapse-1607c597">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            indexMap.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> build(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preLeft, <span class="hljs-type">int</span> preRight, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preLeft &gt; preRight) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[preLeft];<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> indexMap.get(rootVal);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> index - inLeft;<br>        <br>        root.left = build(preorder, preLeft + <span class="hljs-number">1</span>, preLeft + leftSize, inorder, inLeft, index - <span class="hljs-number">1</span>);<br>        root.right = build(preorder, preLeft + leftSize + <span class="hljs-number">1</span>, preRight, inorder, index + <span class="hljs-number">1</span>, inRight);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="4-今日收获"><a href="#4-今日收获" class="headerlink" title="4. 今日收获"></a>4. 今日收获</h1><ul><li>关于JAVA API的深拷贝，对于保存快照的递归题，必须<code>new ArrayList&lt;&gt;()</code>新建一个对象；</li><li>关于递归函数什么时候有返回值？什么时候没有？今天算是系统地总结回顾了一下，感觉<strong>有返回值的题目</strong>更难一些。</li><li>关于什么时候参数需要回溯？什么时候不需要？同样做了系统的总结。</li><li>学习时长：<span class="label label-primary">6小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day14 | {110.平衡二叉树, 257.二叉树的所有路径, 404.左叶子之和, 222.完全二叉树的节点个数}</title>
    <link href="/cn/day14_leetcode/"/>
    <url>/cn/day14_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第六章二叉树part03，思考什么题目适用什么遍历方式，练习递归三部曲。</p><span id="more"></span><h1 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/balanced-binary-tree/">110.平衡二叉树</a></li><li>文档讲解：<a href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录–110.平衡二叉树</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Ug411S7my/">后序遍历求高度，高度判断是否平衡 | LeetCode：110.平衡二叉树</a></li><li>状态：没做出来。</li></ul>          </div><h2 id="1-1-看完代码随想录的想法"><a href="#1-1-看完代码随想录的想法" class="headerlink" title="1.1 看完代码随想录的想法"></a>1.1 看完代码随想录的想法</h2><ul><li>平衡二叉树的定义：一个二叉树每个节点的<strong>左右两个子树的高度差的绝对值不超过1</strong>。</li><li>因为是要求高度，所以用后序遍历比较合适，接着来思考思考递归三部曲：<ol><li><strong>参数是什么？返回值是什么？</strong> 传入一个节点，返回以这个节点为根节点的树的高度，如果这个树已经不平衡了，就返回-1。（体会后序遍历的好处）</li><li><strong>确定终止条件。</strong> 当传入的节点是空时，返回高度为0。</li><li><strong>确定单层递归的逻辑。</strong> 左右中，求该节点左子树和右子树的高度，<span style="color: red">如果某一个子树已经不平衡了，就不需要再计算另外一边，也不应该继续参与高度计算，剪枝！！</span>然后判断两个子树的高度差是否大于1，如果大于一，那以该节点为子树的节点已经不平衡了，返回-1；否则符合平衡二叉树的定义，本层树的高度正常加1。</li></ol></li><li>迭代法本轮精力有限，不去掌握了。</li></ul><h2 id="1-2-解题小结"><a href="#1-2-解题小结" class="headerlink" title="1.2 解题小结"></a>1.2 解题小结</h2><ul><li>第一遍写题没有考虑如果某一个子树已经不平衡的情况，导致计算了错误的高度差。修正了。</li><li>后序遍历    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>110. 平衡二叉树      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> getDepth(root) != -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDepth</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftHeight</span> <span class="hljs-operator">=</span> getDepth(node.left);<br>        <span class="hljs-keyword">if</span> (leftHeight == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightHeight</span> <span class="hljs-operator">=</span> getDepth(node.right);<br>        <span class="hljs-keyword">if</span> (rightHeight == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(Math.abs(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(leftHeight, rightHeight);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></li><li>文档讲解：<a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">代码随想录–257. 二叉树的所有路径</a></li><li>视频讲解：<a href="bilibili.com/video/BV1ZG411G7Dh/">递归中带着回溯，你感受到了没？| LeetCode：257. 二叉树的所有路径</a></li><li>状态：用前序遍历比较合适吧，不过我不知道如何<strong>回溯</strong>。</li></ul>          </div><h2 id="2-1-看完视频的想法"><a href="#2-1-看完视频的想法" class="headerlink" title="2.1 看完视频的想法"></a>2.1 看完视频的想法</h2><ul><li><p>视频给的是<strong>不隐藏回溯过程</strong>的代码写法，一些网上精简的题解会把回溯的过程隐藏掉（藏在<strong>函数调用时的参数赋值里</strong>）。</p></li><li><p>分析递归三部曲</p><ol><li><strong>参数和返回值是什么？</strong> 要传入根节点，记录一条路径用的数组path，和所有结果集的result，不需要返回值。</li><li><strong>确定递归的终止条件。</strong> 当遍历到叶子节点递归终止，此时把path加入结果集。</li><li><strong>确定单层递归的逻辑。</strong> 按照前序遍历（中左右）的顺序，遍历到哪个节点，就把哪个节点加入path路径，接着遍历左子树，遍历出来的时候要对path进行回溯，遍历右子树也是一样的要回溯。</li></ol></li><li><p>细节</p><ol><li>在写递归的时候，终止条件习惯了这么写：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) &#123;<br>    终止处理逻辑<br>&#125;<br></code></pre></td></tr></table></figure>但是本题的终止条件这么写会很麻烦，因为null不一定是到了叶子节点，<strong>不如在找到叶子节点时，开始结束的处理逻辑。</strong></li><li><strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯。</strong></li></ol></li></ul><h2 id="2-2-解题小结"><a href="#2-2-解题小结" class="headerlink" title="2.2 解题小结"></a>2.2 解题小结</h2><ul><li>前序遍历–递归+回溯    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>257. 二叉树的所有路径      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        LinkedList&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        preOrder(root, path, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode node, LinkedList&lt;String&gt; path, List&lt;String&gt; result)</span> &#123;<br>        path.offerLast(String.valueOf(node.val));  <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>            result.add(String.join(<span class="hljs-string">&quot;-&gt;&quot;</span>, path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>            preOrder(node.left, path, result);<br>            path.pollLast();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>            preOrder(node.right, path, result);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/sum-of-left-leaves/">404.左叶子之和</a></li><li>文档讲解：<a href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html">代码随想录–404.左叶子之和</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1GY4y1K7z8/">二叉树的题目中，总有一些规则让你找不到北 | LeetCode：404.左叶子之和</a></li><li>状态：用层序遍历做出来了，但<strong>递归的做法</strong>偷看了单层递归的文字后写出来了。</li></ul>          </div><h2 id="3-1-看完视频的想法"><a href="#3-1-看完视频的想法" class="headerlink" title="3.1 看完视频的想法"></a>3.1 看完视频的想法</h2><ul><li>判断一个叶节点是否是左叶子节点的思路，要借助其父节点，和我想得一样。</li><li>本题适用于<strong>后序遍历</strong>，左右中，让根节点收集其<strong>左子树的左叶子之和</strong>和<strong>右子树的左叶子之和</strong>。分析递归三部曲：<ol><li><strong>参数和返回值是什么？</strong> 要传入根节点，返回值是这个二叉树的左叶子之和。</li><li><strong>确定递归的终止条件。</strong> 当节点为空时，返回0，当节点本身为叶子节点时，也返回0。</li><li><strong>确定单层递归的逻辑。</strong> <span style="color: red">当遇到左叶子节点时，记录数值。然后通过递归求取左子树左叶子之和，和右子树左叶子之和，相加便是整个树的左叶子之和。</span></li></ol></li></ul><h2 id="3-2-解题小结"><a href="#3-2-解题小结" class="headerlink" title="3.2 解题小结"></a>3.2 解题小结</h2><ul><li><p>后序遍历–递归法</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>404. 左叶子之和      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSum</span> <span class="hljs-operator">=</span> sumOfLeftLeaves(root.left);<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.left.left == <span class="hljs-literal">null</span> &amp;&amp; root.left.right == <span class="hljs-literal">null</span>) leftSum = root.left.val;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightSum</span> <span class="hljs-operator">=</span> sumOfLeftLeaves(root.right);<br>        <span class="hljs-keyword">return</span> leftSum + rightSum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>层序遍历-BFS</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>404. 左叶子之和      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.offerLast(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(node.left.left == <span class="hljs-literal">null</span> &amp;&amp; node.left.right == <span class="hljs-literal">null</span>) curSum += node.left.val;<br>                    queue.offerLast(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offerLast(node.right);<br>            &#125;<br>            sum += curSum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222.完全二叉树的节点个数</a></li><li>文档讲解：<a href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html">代码随想录–222.完全二叉树的节点个数</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1eW4y1B7pD/">要理解普通二叉树和完全二叉树的区别！ | LeetCode：222.完全二叉树节点的数量</a></li><li>状态：我<strong>层序遍历</strong>唯手熟尔，本题适合后序遍历，判断左右子树是否是满二叉树，如果是就可以用公式。</li></ul>          </div><h2 id="4-1-解题分析"><a href="#4-1-解题分析" class="headerlink" title="4.1 解题分析"></a>4.1 解题分析</h2><ul><li><p>自己先分析一下递归三部曲（利用完全二叉树的性质）：</p><ol><li><strong>参数和返回值是什么？</strong> 要传入根节点，返回以该节点为根节点的完全二叉树节点个数。</li><li><strong>确定递归的终止条件。</strong> 当节点为空时，返回0；当以该节点为根节点的二叉树是一个满二叉树时，也作为终止条件。</li><li><strong>确定单层递归的逻辑。</strong> 后序遍历，左右中，中间节点+1返回。</li></ol></li><li><p>在写递归算法的时候，遇到一个关键问题：<strong>如何判断一个左子树或者右子树是否是二叉树呢？</strong>（看视频了）</p><ul><li>一直向左、一直向右遍历，<strong>如果深度相同，则一定是一个满二叉树</strong>，可以画图分析。</li></ul></li></ul><h2 id="4-2-解题小结"><a href="#4-2-解题小结" class="headerlink" title="4.2 解题小结"></a>4.2 解题小结</h2><ul><li>普通二叉树-后序遍历</li></ul><p>和昨天做过的求树的最大深度、最小高度是一个模板。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>222. 完全二叉树的节点个数      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNodes(root.left) + countNodes(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li>普通二叉树-层序遍历（BFS）</li></ul><p>这样动脑最少，但每个节点都要遍历，效率很低。而判断满二叉树可以减少对中间节点的遍历。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-738764b7" role="button" aria-expanded="false" aria-controls="collapse-738764b7">        <div class="fold-arrow">▶</div>222. 完全二叉树的节点个数      </div>      <div class="fold-collapse collapse" id="collapse-738764b7">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) queue.offerLast(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>                result++;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offerLast(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offerLast(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li>完全二叉树-后序遍历</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dfb167e8" role="button" aria-expanded="false" aria-controls="collapse-dfb167e8">        <div class="fold-arrow">▶</div>222. 完全二叉树的节点个数      </div>      <div class="fold-collapse collapse" id="collapse-dfb167e8">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> isFullBinaryTree(root);<br>        <span class="hljs-keyword">if</span>(depth != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, depth) - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftCnt</span> <span class="hljs-operator">=</span> countNodes(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightCnt</span> <span class="hljs-operator">=</span> countNodes(root.right);<br>        <span class="hljs-keyword">return</span> leftCnt + rightCnt + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">isFullBinaryTree</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> node.left;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> node.right;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftDepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span>) &#123;<br>            left = left.left;<br>            leftDepth++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right != <span class="hljs-literal">null</span>) &#123;<br>            right = right.right;<br>            rightDepth++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>            <span class="hljs-keyword">return</span> leftDepth + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="5-今日收获"><a href="#5-今日收获" class="headerlink" title="5. 今日收获"></a>5. 今日收获</h1><ul><li>求树的深度，可以转换为求根节点的高度，进而适用于<strong>后序遍历</strong>解题，今天继续练习了递归三部曲，然后遇到题目多思考怎么做为什么。</li><li>左叶子之和这道题，单层递归逻辑二刷时还需要自己来一遍哦。</li><li>学习时长：<span class="label label-primary">3小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day13 | {226.翻转二叉树, 101.对称二叉树, 104.二叉树的最大深度, 111.二叉树的最小深度}</title>
    <link href="/cn/day13_leetcode/"/>
    <url>/cn/day13_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第六章二叉树part02，体会不同的题目适用于不同的遍历方式，先思考递归做法，接着是迭代法。</p><span id="more"></span><h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树</a></li><li>文档讲解：<a href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html">代码随想录–226. 翻转二叉树</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1sP4y1f7q7/">听说一位巨佬面Google被拒了，因为没写出翻转二叉树 | LeetCode：226.翻转二叉树</a></li><li>状态：昨天刷了很多层序遍历（BFS）的题，这题也可以用层序遍历解决。</li></ul>          </div><h2 id="1-1-看完视频的想法"><a href="#1-1-看完视频的想法" class="headerlink" title="1.1 看完视频的想法"></a>1.1 看完视频的想法</h2><ul><li>前序&#x2F;后序遍历都能解决这个问题，遍历到哪个节点，本层递归要做的是交换这个节点的左右孩子，画图跟一下遍历就想清楚了。</li></ul><h2 id="1-2-解法总结"><a href="#1-2-解法总结" class="headerlink" title="1.2 解法总结"></a>1.2 解法总结</h2><ul><li><p>层序遍历（BFS）</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>226. 翻转二叉树      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.offerLast(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>                swap(node);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offerLast(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offerLast(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> node.left;<br>        node.left = node.right;<br>        node.right = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>前序遍历（DFS）–递归法</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>226. 翻转二叉树      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        swapChildren(root);<br>        invertTree(root.left);<br>        invertTree(root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swapChildren</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> node.left;<br>        node.left = node.right;<br>        node.right = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>前序遍历（DFS）–迭代法</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>226. 翻转二叉树      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) stack.offerFirst(root);<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pollFirst();<br>            swapChildren(node);<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) stack.offerFirst(node.right);<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) stack.offerFirst(node.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swapChildren</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> node.left;<br>        node.left = node.right;<br>        node.right = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树</a></li><li>文档讲解：<a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html">代码随想录–101. 对称二叉树</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1ue4y1Y7Mf/">新学期要从学习二叉树开始！ | LeetCode：101. 对称二叉树</a></li><li>状态：检查一个二叉树是否是镜像对称的，就要判断这个二叉树是可以反转的。看了一会没思路。</li></ul>          </div><h2 id="2-1-看完视频的想法"><a href="#2-1-看完视频的想法" class="headerlink" title="2.1 看完视频的想法"></a>2.1 看完视频的想法</h2><ul><li>要判断一个二叉树是否可以反转，需要比较<strong>左子树的外侧节点</strong>和<strong>右子树的外侧节点</strong>是否相同、<strong>左子树的内侧节点</strong>和<strong>右子树的内侧节点</strong>是否相同，然后把这个信息返回给该子树的根节点，让根节点知道它的子树是否是镜像对称，这道题适用于<strong>后序遍历</strong>，并且在递归遍历的过程中，要同时<strong>遍历左</strong>（左右中）、<strong>右</strong>（右左中）<strong>两个子树</strong>哦。<br><img src="https://file1.kamacoder.com/i/algo/20210203144624414.png" alt="比较两个子树的外侧和里侧元素是否都相等"></li></ul><h2 id="2-2-递归法"><a href="#2-2-递归法" class="headerlink" title="2.2 递归法"></a>2.2 递归法</h2><ul><li>再次梳理一遍<strong>递归三部曲</strong>，把逻辑分析清楚。</li></ul><ol><li>确定递归函数的参数和返回值<ul><li>因为我们要比较的是根节点的两个子树是否是可以相互反转的，进而判断这个树是不是对称树，所以<strong>要比较的是两个树</strong>，参数自然也是左子树节点和右子树节点。</li><li>返回值是boolean</li></ul></li><li>确定终止的条件<ul><li>先把左、右节点为空的情况讨论清楚，再来分析都不为空、但值不相同的情况，自然不会造成空指针异常。</li></ul></li><li>确定单层递归的逻辑<ul><li>此时才进入单层递归的逻辑，就是处理左右节点都不为空、并且数值相同的情况。<ul><li>比较两个子树外侧的节点是否对称；</li><li>比较内侧的节点是否对称；</li><li>都对称则返回true，否则返回false。</li></ul></li></ul></li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>101. 对称二叉树      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> compare(root.left, root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">outside</span> <span class="hljs-operator">=</span> compare(left.left, right.right);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">inside</span> <span class="hljs-operator">=</span> compare(left.right, right.left);<br>        <span class="hljs-keyword">return</span> outside &amp;&amp; inside;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="2-3-迭代法"><a href="#2-3-迭代法" class="headerlink" title="2.3 迭代法"></a>2.3 迭代法</h2><ul><li><p>本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前后序的迭代写法了。</p></li><li><p>（看题解之后）我们可以<strong>使用队列</strong>来比较两个树（根节点的左右子树）是否相互翻转。<br><img src="https://file1.kamacoder.com/i/algo/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.gif" alt="用迭代法解决对称二叉树"></p></li><li><p><strong>在定义一个双端队列的实现类时，在Java中，<code>ArrayDeque</code>不允许存null！！！</strong>改用<code>LinkedList</code>作为Deque。</p></li><li><p>迭代法–双端队列数据结构，相当于两个栈</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>101. 对称二叉树      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        deque.offerFirst(root.left);<br>        deque.offerLast(root.right);<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> deque.pollLast();<br>            <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span> || left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            deque.offerFirst(left.left);<br>            deque.offerFirst(left.right);<br>            deque.offerLast(right.right);<br>            deque.offerLast(right.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>迭代法–普通队列数据结构</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>101. 对称二叉树      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        deque.offerLast(root.left);<br>        deque.offerLast(root.right);<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>            <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span> || left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            deque.offerLast(left.left);<br>            deque.offerLast(right.right);<br>            deque.offerLast(left.right);<br>            deque.offerLast(right.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h2 id="2-4-相关题目"><a href="#2-4-相关题目" class="headerlink" title="2.4 相关题目"></a>2.4 相关题目</h2><ul><li>在<code>root</code>的某个子节点处，是否存在一棵树整体结构和值都与<code>subroot</code>完全相同。这其实是两个问题：<ol><li>在root中找一个起点;</li><li>从这个起点开始，判断两颗树是否完全相同。</li></ol></li><li><strong>子树问题 &#x3D; 找起点 + 判等树</strong>; 这两个逻辑，绝对不能写在同一个递归里。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-738764b7" role="button" aria-expanded="false" aria-controls="collapse-738764b7">        <div class="fold-arrow">▶</div>572. 另一棵树的子树      </div>      <div class="fold-collapse collapse" id="collapse-738764b7">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 主函数负责找起点</span><br><span class="hljs-comment">// 辅助函数负责比较两棵树是否相同</span><br><span class="hljs-comment">// 子树问题=找起点+判等树 这两个逻辑一定要拆分，明确递归的职责！</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubtree</span><span class="hljs-params">(TreeNode root, TreeNode subRoot)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 以当前结点为根结点尝试匹配</span><br>        <span class="hljs-keyword">if</span> (isSameTree(root, subRoot)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 否则继续去左右子树找起点</span><br>        <span class="hljs-keyword">return</span> isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode a, TreeNode b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> &amp;&amp; b != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span> &amp;&amp; b == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> &amp;&amp; b == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.val != b.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> isSameTree(a.left, b.left) &amp;&amp; isSameTree(a.right, b.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></li><li>文档讲解：<a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">代码随想录–104. 二叉树的最大深度</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Gd4y1V75u/">二叉树的高度和深度有啥区别？究竟用什么遍历顺序？很多录友搞不懂 | 104.二叉树的最大深度</a></li><li>状态：昨天用层序遍历过了这题。</li></ul>          </div><h2 id="3-1-看完视频的想法"><a href="#3-1-看完视频的想法" class="headerlink" title="3.1 看完视频的想法"></a>3.1 看完视频的想法</h2><ul><li>什么是深度，什么是高度，如何求深度，如何求高度，这里有关系到二叉树的遍历方式。<ul><li>深度：某个节点到根节点的距离</li><li>高度：某个节点到叶子节点的距离</li><li>如何求深度：<strong>前序遍历</strong>的方式一路向下搜索</li><li>如何求高度：<strong>后序遍历</strong>，左右中，反馈给父节点子树的高度</li><li><strong>根节点的高度 &#x3D; 一棵树的最大深度</strong></li></ul></li><li>一道题，适合用什么遍历方式要自己思考，本题如果采用求高度的做法，<strong>从下往上</strong>需要返回信息给父节点，那么单层递归的逻辑就适合用<strong>后序</strong>遍历。</li></ul><h2 id="3-2-解法总结"><a href="#3-2-解法总结" class="headerlink" title="3.2 解法总结"></a>3.2 解法总结</h2><ul><li><p>后序遍历–递归法</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dfb167e8" role="button" aria-expanded="false" aria-controls="collapse-dfb167e8">        <div class="fold-arrow">▶</div>104. 二叉树的最大深度      </div>      <div class="fold-collapse collapse" id="collapse-dfb167e8">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftHeight</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightHeight</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(leftHeight, rightHeight);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>前序遍历–递归法，有回溯的思想</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-5d5d193e" role="button" aria-expanded="false" aria-controls="collapse-5d5d193e">        <div class="fold-arrow">▶</div>104. 二叉树的最大深度      </div>      <div class="fold-collapse collapse" id="collapse-5d5d193e">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        getDepth(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDepth</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        depth++;<br>        result = Math.max(result, depth);<br>        getDepth(node.left, depth);<br>        getDepth(node.right, depth);<br>        depth--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>层序遍历（BFS）</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-8bbf6858" role="button" aria-expanded="false" aria-controls="collapse-8bbf6858">        <div class="fold-arrow">▶</div>104. 二叉树的最大深度      </div>      <div class="fold-collapse collapse" id="collapse-8bbf6858">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.offerLast(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">while</span>(size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offerLast(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offerLast(node.right);<br>            &#125;<br>            maxDepth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxDepth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></li><li>文档讲解：<a href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html">代码随想录–111. 二叉树的最小深度</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1QD4y1B7e2/">看起来好像做过，一写就错！ | LeetCode：111.二叉树的最小深度</a></li><li>状态：层序遍历也可以解决这题，但<strong>递归做法</strong>我还没想过。</li></ul>          </div><h2 id="4-1-看完视频的想法"><a href="#4-1-看完视频的想法" class="headerlink" title="4.1 看完视频的想法"></a>4.1 看完视频的想法</h2><ul><li>本题依然采用后序遍历的做法，求高度，把根节点传入函数，即可求根节点到叶子节点的最小距离。但这里要注意有坑，只有<strong>左右子树都为空，即到达叶子节点</strong>的时候，才是最小深度。</li></ul><h2 id="4-2-解法总结"><a href="#4-2-解法总结" class="headerlink" title="4.2 解法总结"></a>4.2 解法总结</h2><ul><li><p>后序遍历–递归法</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-8e159bd8" role="button" aria-expanded="false" aria-controls="collapse-8e159bd8">        <div class="fold-arrow">▶</div>111. 二叉树的最小深度      </div>      <div class="fold-collapse collapse" id="collapse-8e159bd8">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftHeight</span> <span class="hljs-operator">=</span> minDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightHeight</span> <span class="hljs-operator">=</span> minDepth(root.right);<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightHeight;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftHeight;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.min(leftHeight, rightHeight);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>层序遍历（BFS）</p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-42d133e0" role="button" aria-expanded="false" aria-controls="collapse-42d133e0">        <div class="fold-arrow">▶</div>111. 二叉树的最小深度      </div>      <div class="fold-collapse collapse" id="collapse-42d133e0">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minDepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.offerLast(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">while</span>(size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>                <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">while</span> (!queue.isEmpty()) queue.pollFirst();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offerLast(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offerLast(node.right);<br>            &#125;<br>            minDepth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minDepth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="5-今日收获"><a href="#5-今日收获" class="headerlink" title="5. 今日收获"></a>5. 今日收获</h1><ul><li>遍历节点的顺序和处理节点的顺序是否一致，不一致要引入指针辅助遍历。</li><li>什么样的题目适合<strong>什么样的遍历方式</strong>，这一点我开始慢慢找到感觉了，前序、中序、后序遍历，解题的过程中<strong>多思考用的什么遍历方式，为什么用这个遍历方式</strong>。</li><li>关于Java API，双端队列的实现类<code>ArrayDeque</code>中不能存储<code>null</code>.</li><li>数组、链表、字符串有反转题，今天<strong>二叉树也有反转题</strong>，真是妙啊。</li><li>学习时长：<span class="label label-primary">4小时</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day12 | {1.二叉树的递归遍历, 2.二叉树的迭代遍历, 3.二叉树的层序遍历}</title>
    <link href="/cn/day12_leetcode/"/>
    <url>/cn/day12_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第六章二叉树part01，递归法、迭代法实现二叉树遍历、层序遍历（借助队列数据结构）。</p><span id="more"></span><h1 id="0-理论基础"><a href="#0-理论基础" class="headerlink" title="0. 理论基础"></a>0. 理论基础</h1><ul><li><p>二叉树的种类</p><ol><li>满二叉树</li><li>完全二叉树</li><li>二叉搜索树</li><li>平衡二叉搜索树</li></ol></li><li><p>二叉树的存储方式</p><ol><li>链式存储</li><li>数组存储（了解）</li></ol></li><li><p>二叉树的遍历方式</p><ol><li>深度优先遍历 （前&#x2F;中&#x2F;后序遍历）</li><li>广度优先遍历 （层序遍历）</li></ol></li><li><p>二叉树的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br>    TreeNode() &#123;&#125;<br>    TreeNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br>    TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>递归算法的三要素</p><ol><li><strong>确定递归函数的参数和返回值</strong>： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。一般来说返回值为空，因为我们把返回值保存在一个参数数组里了。</li><li><strong>确定终止条件</strong>： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑</strong>： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol></li></ul><h1 id="1-二叉树的递归遍历"><a href="#1-二叉树的递归遍历" class="headerlink" title="1. 二叉树的递归遍历"></a>1. 二叉树的递归遍历</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历</a></li><li>题目链接：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94. 二叉树的中序遍历</a></li><li>题目链接：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">145. 二叉树的后序遍历</a></li><li>文档讲解：<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">代码随想录–二叉树的递归遍历</a></li><li>状态：学408的时候就会了。</li></ul>          </div><h2 id="1-1-解题过程"><a href="#1-1-解题过程" class="headerlink" title="1.1 解题过程"></a>1.1 解题过程</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>144. 二叉树的前序遍历      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <br>        preOrder(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode cur, List&lt;Integer&gt; res)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        res.add(cur.val);<br>        preOrder(cur.left, res);<br>        preOrder(cur.right, res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>94. 二叉树的中序遍历      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        inOrder(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode cur, List&lt;Integer&gt; res)</span> &#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        inOrder(cur.left, res);<br>        res.add(cur.val);<br>        inOrder(cur.right, res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>145. 二叉树的后序遍历      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        postOrder(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode cur, List&lt;Integer&gt; res)</span> &#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        postOrder(cur.left, res);<br>        postOrder(cur.right, res);<br>        res.add(cur.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="2-二叉树的迭代遍历"><a href="#2-二叉树的迭代遍历" class="headerlink" title="2. 二叉树的迭代遍历"></a>2. 二叉树的迭代遍历</h1><div class="note note-info">            <ul><li>文档讲解：<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">代码随想录–二叉树的迭代遍历</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Zf4y1a77g/">写出二叉树的非递归遍历很难么？（中序）)</a></li><li>状态：记得中序遍历的迭代法和前序遍历不一样</li></ul>          </div><h2 id="2-1-解题过程"><a href="#2-1-解题过程" class="headerlink" title="2.1 解题过程"></a>2.1 解题过程</h2><ul><li>前序遍历的过程借助一个栈实现，因为遍历的结点和要处理的结点（将结点值放入result数组）是一致的，只需注意栈是先进后出的，所以要让右孩子先入栈；</li><li>后序遍历的迭代法可以依据前序遍历reverse出来；</li><li>中序遍历，则额外需要借用一个<strong>cur指针的遍历</strong>来访问结点，栈用于处理结点上的元素。中序遍历迭代法，还需注意一下<strong>循环停止的条件</strong>。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>144. 二叉树的前序遍历      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) queue.offerFirst(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>            res.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offerFirst(node.right);<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offerFirst(node.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>94. 二叉树的中序遍历      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span> || !queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                queue.offerFirst(cur);<br>                cur = cur.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>                res.add(node.val);<br>                cur = node.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-738764b7" role="button" aria-expanded="false" aria-controls="collapse-738764b7">        <div class="fold-arrow">▶</div>145. 二叉树的后序遍历      </div>      <div class="fold-collapse collapse" id="collapse-738764b7">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 前序：中左右 --&gt; 中右左 --&gt; reverse --&gt; 左右中</span><br>    <span class="hljs-comment">// 后序：左右中</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) queue.offerFirst(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>            res.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offerFirst(node.left);<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offerFirst(node.right);<br>        &#125;<br>        Collections.reverse(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="3-二叉树的层序遍历"><a href="#3-二叉树的层序遍历" class="headerlink" title="3. 二叉树的层序遍历"></a>3. 二叉树的层序遍历</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></li><li>文档讲解：<a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">代码随想录– 二叉树的层序遍历</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1GY4y1u7b2/">讲透二叉树的层序遍历 | 广度优先搜索 | LeetCode：102.二叉树的层序遍历</a></li><li>状态：看了视频讲解，又复习了一遍层序遍历的做法。</li></ul>          </div><h2 id="3-1-解题过程"><a href="#3-1-解题过程" class="headerlink" title="3.1 解题过程"></a>3.1 解题过程</h2><p>由于树结点无法直接访问到同一层的结点，因此需要借助一个队列来存储结点，并且注意每层弹出多少个元素，由一开始记录的size决定。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dfb167e8" role="button" aria-expanded="false" aria-controls="collapse-dfb167e8">        <div class="fold-arrow">▶</div>102. 二叉树的层序遍历      </div>      <div class="fold-collapse collapse" id="collapse-dfb167e8">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <span class="hljs-comment">// 二维数组</span><br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.offerLast(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; curLevel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span>(size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>                curLevel.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offerLast(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offerLast(node.right);<br>            &#125;<br>            res.add(curLevel);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day11 | {150.逆波兰表达式求值, 239.滑动窗口最大值, 347.前K个高频元素}</title>
    <link href="/cn/day11_leetcode/"/>
    <url>/cn/day11_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第五章栈与队列part02，单调递减队列，小顶堆（JAVA内置了优先队列默认构建的就是小顶堆）。</p><span id="more"></span><h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150.逆波兰表达式求值</a></li><li>文档讲解：<a href="https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录–150.逆波兰表达式求值</a></li><li>状态：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li></ul>          </div><h2 id="1-1-解题过程"><a href="#1-1-解题过程" class="headerlink" title="1.1 解题过程"></a>1.1 解题过程</h2><ul><li>把运算符作为中间结点，按照<strong>二叉树后续遍历的规则</strong>就能得到逆波兰表达式，逆波兰实际上就是对算法表达式的序列化，以后续遍历的方式。    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>150. 逆波兰表达式求值      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Set&lt;String&gt; op = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tokens.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!op.contains(tokens[i])) &#123;<br>                stack.push(Integer.parseInt(tokens[i]));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> res;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;+&quot;</span>.equals(tokens[i])) &#123;<br>                    res = l + r;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-&quot;</span>.equals(tokens[i])) &#123;<br>                    res = l - r;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;*&quot;</span>.equals(tokens[i])) &#123;<br>                    res = l * r;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res = l / r;<br>                &#125;<br>                stack.push(res);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></li><li>文档讲解：<a href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录–239. 滑动窗口最大值</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1XS4y1p7qj/">单调队列正式登场！| LeetCode：239. 滑动窗口最大值</a></li><li>状态：按照题意去每个长为k的滑动窗口遍历得到最大值，时间复杂度为<code>O(n*k)</code>。</li></ul>          </div><h2 id="2-1-看完代码随想录的想法"><a href="#2-1-看完代码随想录的想法" class="headerlink" title="2.1 看完代码随想录的想法"></a>2.1 看完代码随想录的想法</h2><ul><li><p>单调队列是一种特殊的数据结构，其元素在队列中始终保持<strong>单调递增或单调递减</strong>的规律。它通过双端操作（队首和队尾）维护一个隐含的单调子序列，而非实际存储所有元素，从而在插入或者删除时高效舍弃破坏单调性的无效数据。。</p></li><li><p>看了视频讲解，自己构建一个<strong>单调递减队列</strong>，有如下特性：</p><ul><li>队头始终为当前窗口的最大值；</li><li>入队时，新元素入队之前，会从队尾移除所有比它小的元素；</li><li>出队时，依据整数数组，如果队头&#x3D;&#x3D;nums数组遍历到的元素，则真的执行出队操作。</li></ul></li></ul><h2 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h2><ul><li><p>主要思想是队列没有必要维护窗口里的所有元素，<strong>只需要维护有可能成为窗口里最大值的元素</strong>就可以了，同时保证队列里的元素数值是由大到小的。</p></li><li><p>自定义一个单调递减队列，然后遍历nums数组就好，遍历这一块写得不是很优雅，要完善一下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>239. 滑动窗口最大值      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><br>    Deque&lt;Integer&gt; queue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">(Deque&lt;Integer&gt; queue)</span> &#123;<br>        <span class="hljs-built_in">this</span>.queue = queue;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">popEle</span><span class="hljs-params">(<span class="hljs-type">int</span> ele)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!queue.isEmpty() &amp;&amp; queue.peekFirst() == ele) &#123;<br>            <span class="hljs-keyword">return</span> queue.pollFirst();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushEle</span><span class="hljs-params">(<span class="hljs-type">int</span> ele)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekLast() &lt; ele) &#123;<br>            queue.pollLast();<br>        &#125;<br>        queue.offerLast(ele);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getMaxValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.peekFirst();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">myQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; k; j++) myQueue.pushEle(nums[j]);  <span class="hljs-comment">// 入队k个</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> k; right &lt; nums.length; right++) &#123;<br>            res[left] = myQueue.getMaxValue();  <span class="hljs-comment">// 记录的是进入下一个窗口之前的最大值</span><br>            myQueue.popEle(nums[left]);<br>            left++;<br>            myQueue.pushEle(nums[right]);<br>        &#125;<br>        res[left] = myQueue.getMaxValue();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="347-前K个高频元素"><a href="#347-前K个高频元素" class="headerlink" title="347. 前K个高频元素"></a>347. 前K个高频元素</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">347.前K个高频元素</a></li><li>文档讲解：<a href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html">代码随想录–347.前K个高频元素</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1Xg41167Lz/">优先级队列正式登场！大顶堆、小顶堆该怎么用？| LeetCode：347.前 K 个高频元素</a></li><li>状态：想到一个按Map的value排序的方法。</li></ul>          </div><h2 id="3-1-看完题目的想法"><a href="#3-1-看完题目的想法" class="headerlink" title="3.1 看完题目的想法"></a>3.1 看完题目的想法</h2><ul><li>复盘一遍怎么按照map的value排序：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">99</span>);<br>map.put(<span class="hljs-string">&quot;b&quot;</span>, -<span class="hljs-number">5</span>);<br>map.put(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">128</span>);<br><br>List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.entrySet());<br>list.sort((o1, o2) -&gt; o2.getValue() - o1.getValue());  <span class="hljs-comment">// 自定义降序排序规则</span><br></code></pre></td></tr></table></figure></li><li>第一种解法：    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>347. 前K个高频元素      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 1. 转成list</span><br>        ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.entrySet());<br>        <span class="hljs-comment">// 2. 对value排序</span><br>        list.sort((o1, o2) -&gt; o2.getValue() - o1.getValue());<br>        <span class="hljs-comment">// 3. 取前k个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res[i] = list.get(i).getKey();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h2 id="3-2-看完代码随想录的想法"><a href="#3-2-看完代码随想录的想法" class="headerlink" title="3.2 看完代码随想录的想法"></a>3.2 看完代码随想录的想法</h2><ul><li>（解法二）：只维护一个k个结点的<strong>小顶堆</strong>，最先pop的是根结点（最小的），这样剩下的就是k个最大的。<ul><li>问题是小顶堆怎么写？今天是第一次写啊。</li></ul></li></ul><h3 id="JAVA中怎么构建小顶堆？"><a href="#JAVA中怎么构建小顶堆？" class="headerlink" title="JAVA中怎么构建小顶堆？"></a>JAVA中怎么构建小顶堆？</h3><p>Java中有内置的优先队列<code>PriorityQueue</code>，默认就是小顶堆(Min Heap)。</p><ul><li><p>常用API</p><table><thead><tr><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>插入元素</td><td>offer(e)</td></tr><tr><td>取出并删除堆顶</td><td>poll()</td></tr><tr><td>查看堆顶</td><td>peek()</td></tr><tr><td>当前元素的个数</td><td>size()</td></tr><tr><td>是否为空</td><td>isEmpty()</td></tr></tbody></table></li><li><p>插入的时间复杂度<code>O(logn)</code>、删除的时间复杂度<code>O(logn)</code>、取堆顶<code>O(1)</code></p></li></ul><ol><li>默认构造—小顶堆<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><span class="hljs-comment">//PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(Comparator.naturalOrder());</span><br>minHeap.offer(<span class="hljs-number">3</span>);<br>minHeap.offer(<span class="hljs-number">1</span>);<br>minHeap.offer(<span class="hljs-number">2</span>);<br><br>System.out.println(minHeap.poll()); <span class="hljs-comment">// 1</span><br>System.out.println(minHeap.poll()); <span class="hljs-comment">// 2</span><br>System.out.println(minHeap.poll()); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></li><li>构建大顶堆<ol><li>数值类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());<br></code></pre></td></tr></table></figure></li><li>自定义比较器，按a[0]排序的小顶堆<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure></li></ol></li><li>注意事项：<ol><li>PriorityQueue的遍历不是有序的，<strong>遍历顺序不等于对序</strong>，只有<code>poll()</code>才能保证顺序：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : minHeap) &#123;<br> System.out.println(x);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>堆中不能存放null：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">minHeap.offer(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 空指针异常</span><br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="结合leetcode题解写出小顶堆"><a href="#结合leetcode题解写出小顶堆" class="headerlink" title="结合leetcode题解写出小顶堆"></a>结合leetcode题解写出小顶堆</h3><ul><li>复杂度分析<ul><li>时间复杂度：<code>O(NlogN)</code>，因为我们遍历出现次数数组(长度为N)，由于堆的大小至多为<code>k</code>，因此每次堆操作需要<code>O(logk)</code>的时间，共需<code>O(NlogN)</code>的时间。</li><li>空间复杂度：<code>O(N)</code>，哈希表的大小为<code>O(N)</code>，堆的大小为<code>O(k)</code>，共计<code>O(N)</code>。    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8bbf6858" role="button" aria-expanded="false" aria-controls="collapse-8bbf6858">        <div class="fold-arrow">▶</div>347. 前K个高频元素(优先队列)      </div>      <div class="fold-collapse collapse" id="collapse-8bbf6858">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        Map&lt;Integer, Integer&gt; occur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            occur.put(num, occur.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 定义一个小顶堆</span><br>        <span class="hljs-comment">// 每个数组元素，第一个存放key，第二个存放value</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; e : occur.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> e.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> e.getValue();<br>            <span class="hljs-keyword">if</span> (queue.size() &lt; k) &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, cnt&#125;);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queue.isEmpty() &amp;&amp; queue.peek()[<span class="hljs-number">1</span>] &lt; cnt) &#123;<br>                queue.poll();<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, cnt&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            res[j++] = queue.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul></li></ul><h1 id="4-栈与队列总结"><a href="#4-栈与队列总结" class="headerlink" title="4. 栈与队列总结"></a>4. 栈与队列总结</h1><p>主要还是边写题，边熟悉JAVA语言内置的API</p><ul><li>Deque–模拟栈和队列</li><li>单调递增&#x2F;递减队列–保证队列中的元素始终是单调的，也用Deque自定义这种数据结构实现</li><li>大顶堆&#x2F;小顶堆–在Java中内置了<strong>优先级队列</strong>在实现这个数据结构，对外只提供<code>offer()</code>、<code>poll()</code>、<code>peek()</code>方法，看起来像队列，其实就是一个<strong>披着队列外衣的堆</strong>，只用维护部分数据有序。</li></ul><h1 id="5-Other"><a href="#5-Other" class="headerlink" title="5. Other"></a>5. Other</h1><ul><li>今天打了<strong>第482周的周赛</strong><ul><li>第一题：前缀和数组 + 从后往前遍历取数组元素的最小值；</li><li>第三题：和用哈希表来判断集合中的某个元素是否曾经出现过。判断余数是否陷入死循环。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day10 | {232.用栈实现队列, 225.用队列实现栈, 20.有效的括号，1047.删除字符串中的所有相邻重复项}</title>
    <link href="/cn/day10_leetcode/"/>
    <url>/cn/day10_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第五章栈与队列-part01，熟悉栈和队列的特性，基本应用。</p><span id="more"></span><h1 id="0-JAVA语言的栈与队列"><a href="#0-JAVA语言的栈与队列" class="headerlink" title="0. JAVA语言的栈与队列"></a>0. JAVA语言的栈与队列</h1><ul><li><p>在Java中通常使用<strong>Deque接口</strong>配合<strong>ArrayDeque作为栈或队列</strong>；作为栈时使用 push &#x2F; pop &#x2F; peek，作为队列时使用 offer &#x2F; poll &#x2F; peek，底层是循环数组，性能优于Stack和LinkedList。</p><ol><li>作为栈的使用示例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>stack.push(<span class="hljs-number">10</span>);<br>stack.push(<span class="hljs-number">20</span>);<br>System.out.println(stack.pop());  <span class="hljs-comment">// 20</span><br>System.out.println(stack.peek());  <span class="hljs-comment">// 查看栈顶</span><br></code></pre></td></tr></table></figure></li><li>作为队列的使用示例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>queue.offer(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 入队</span><br>queue.offer(<span class="hljs-number">20</span>); <br>System.out.println(queue.poll());  <span class="hljs-comment">// 出队 10</span><br>System.out.println(queue.peek());  <span class="hljs-comment">// 查看队头 20</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>注意，使用Deque模拟一个栈时，<strong>只用队头（First）</strong>，即通过队头模拟栈顶，<code>push=addFirst</code>。</p><ul><li>API等价表<table><thead><tr><th>栈方法</th><th>Stack<E> API</th><th>Deque<E> API</th></tr></thead><tbody><tr><td>入栈</td><td>push(e)</td><td>addFirst(e) &#x2F; push(e)</td></tr><tr><td>出栈</td><td>pop()</td><td>removeFirst(e) &#x2F; pop()</td></tr><tr><td>查看栈顶</td><td>peek()</td><td>peekFirst() &#x2F; peek()</td></tr><tr><td>是否为空</td><td>empty()</td><td>isEmpty()</td></tr><tr><td>栈大小</td><td>size()</td><td>size()</td></tr></tbody></table></li></ul></li><li><p>同时，关于空指针异常，API</p><ul><li><code>pop()</code></li><li><code>peek()</code></li><li><code>removeFirst()</code>都会抛异常；</li></ul></li><li><p>而使用API</p><ul><li><code>pollFisrt()</code>、</li><li><code>peekFirst()</code>在栈为空时返回null。</li></ul></li><li><p>注意，使用Deque模拟一个单向队列时，<strong>头出尾进</strong>。</p><ul><li>API等价表<table><thead><tr><th>队列方法</th><th>Queue<E> API</th><th>Deque<E> API</th></tr></thead><tbody><tr><td>入队</td><td>offer(e)</td><td>offerLast(e)</td></tr><tr><td>出队</td><td>poll()</td><td>pollFirst(e)</td></tr><tr><td>查看队头</td><td>peek()</td><td>peekFirst()</td></tr><tr><td>是否为空</td><td>empty()</td><td>isEmpty()</td></tr><tr><td>队列大小</td><td>size()</td><td>size()</td></tr></tbody></table></li></ul></li></ul><h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232. 用栈实现队列</a></li><li>文档讲解：<a href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html">代码随想录–232. 用栈实现队列</a></li><li>状态：JAVA语言的双端队列来模拟一个栈，然后看了视频解析。</li></ul>          </div><h2 id="1-1-解题过程"><a href="#1-1-解题过程" class="headerlink" title="1.1 解题过程"></a>1.1 解题过程</h2><ul><li>使用两个栈来模拟一个队列，出队操作时，在<code>stackOut</code>非空的时候，从这个栈中pop一个就行了。</li><li>peek可以复用pop函数代码。    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>232. 用栈实现队列      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; stackIn;<br>    <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        stackIn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        stackOut = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stackIn.push(x);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(stackOut.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span>(!stackIn.isEmpty()) stackOut.push(stackIn.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> pop();  <span class="hljs-comment">// 函数复用</span><br>        stackOut.push(top);<br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈</a></li><li>文档讲解：<a href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html">代码随想录–225. 用队列实现栈</a></li><li>状态：先被提醒了用一个队列就能模拟栈，然后明白了。</li></ul>          </div><h2 id="2-1-解题过程"><a href="#2-1-解题过程" class="headerlink" title="2.1 解题过程"></a>2.1 解题过程</h2><ul><li>对于栈来说，pop和peek的区别只在一个将栈顶元素弹出，另一个不弹出而已，注意代码复用。    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>225. 用队列实现栈      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; queue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.offer(x);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">while</span>(len-- &gt; <span class="hljs-number">1</span>) &#123;<br>            queue.offer(queue.poll());<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stackTop</span> <span class="hljs-operator">=</span> pop();<br>        queue.offer(stackTop);<br>        <span class="hljs-keyword">return</span> stackTop;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></li><li>文档讲解：<a href="https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html">代码随想录–20. 有效的括号</a></li><li>状态：栈的应用。</li></ul>          </div><h2 id="3-1-解题过程"><a href="#3-1-解题过程" class="headerlink" title="3.1 解题过程"></a>3.1 解题过程</h2><ul><li>只是借助了栈的特性，题很简单。</li></ul>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>20. 有效的括号      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[i] == <span class="hljs-string">&#x27;(&#x27;</span> || arr[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> || arr[i] == <span class="hljs-string">&#x27;[&#x27;</span>) stack.push(arr[i]);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(!stack.isEmpty()) &#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-keyword">if</span> (arr[i] == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i] == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li>可以剪枝，如果<strong>括号串长度是奇数</strong>，一定不匹配；另外，左括号和右括号之间的对应关系可以<strong>用HashMap存储</strong>起来，方便匹配。</li></ul><h1 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></li><li>文档讲解：<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">代码随想录–1047. 删除字符串中的所有相邻重复项</a></li><li>状态：栈的应用。</li></ul>          </div><h2 id="4-1-解题过程"><a href="#4-1-解题过程" class="headerlink" title="4.1 解题过程"></a>4.1 解题过程</h2><ul><li>题目说会选择相邻且相同的字母进行删除，符合栈的特性。不过要注意将一个循环数组转为String时，元素取出的方向、用StringBuilder暂存。</li></ul>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>1047. 删除字符串中的所有相邻重复项      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();  <span class="hljs-comment">// LinkedList作实现类也是可以的</span><br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(stack.isEmpty() || stack.peek() != arr[i]) stack.push(arr[i]);<br>            <span class="hljs-keyword">else</span> stack.pop();<br>        &#125;<br>        <span class="hljs-comment">// 转为字符串</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>            sb.append(stack.pollLast());<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.valueOf(sb);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day09 | {151.翻转字符串里的单词, 卡码网：55.右旋转字符串, 28.实现 strStr()，459.重复的子字符串}</title>
    <link href="/cn/day09_leetcode/"/>
    <url>/cn/day09_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第四章字符串-part02，知识点为字符串反转、双指针。</p><span id="more"></span><h1 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151.翻转字符串里的单词</a></li><li>文档讲解：<a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html#%E6%80%9D%E8%B7%AF">代码随想录–151.翻转字符串里的单词</a></li><li>状态：<strong>反转字符串</strong>还没达到理解并灵活使用的程度；Java语言本身的API不熟练。</li></ul>          </div><h2 id="1-1-看完题解的想法"><a href="#1-1-看完题解的想法" class="headerlink" title="1.1 看完题解的想法"></a>1.1 看完题解的想法</h2><ul><li>Java中String是不可变对象，必须转成<code>char[]</code>数组，但其实用<strong>27.移除元素</strong>的思想来<strong>移除多余的空格</strong>，也有两种做法：<ol><li>遇到第一个空格两个指针正常同时往后移动，连续遇到第二个空格时slow指针不移动。</li><li>只保留单词，删除所有空格，遇到非空格、并且<code>slow!=0</code>时，给单词之间手动添加一个空格。</li></ol></li><li>整体思路：<ol><li>去除前导和后导的空格；</li><li>删除多余的空格；</li><li>字符串整体反转一次；</li><li>字符串按照单词局部再反转一次。</li></ol></li></ul><h2 id="1-2-解题过程"><a href="#1-2-解题过程" class="headerlink" title="1.2 解题过程"></a>1.2 解题过程</h2><ul><li><p>我写的第一版用<code>char[]</code>数组的代码如下，执行效率是最高的：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>151.翻转字符串里的单词      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] arrS = s.toCharArray();<br>        <span class="hljs-type">char</span>[] res = delExtraSpace(arrS, <span class="hljs-number">0</span>, arrS.length - <span class="hljs-number">1</span>);<br>        reverse(res, <span class="hljs-number">0</span>, res.length - <span class="hljs-number">1</span>);<br>        reverseEachWord(res);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(res);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(start &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (end &lt; n &amp;&amp; arr[end] != <span class="hljs-string">&#x27; &#x27;</span>) end++;  <span class="hljs-comment">// 找单词末尾</span><br>            reverse(arr, start, end - <span class="hljs-number">1</span>);<br>            start = end + <span class="hljs-number">1</span>;<br>            end++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[left];<br>            arr[left++] = arr[right];<br>            arr[right--] = tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span>[] delExtraSpace(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end) &#123;<br>        <span class="hljs-keyword">while</span>(arr[start] == <span class="hljs-string">&#x27; &#x27;</span>) start++;<br>        <span class="hljs-keyword">while</span>(arr[end] == <span class="hljs-string">&#x27; &#x27;</span>) end--;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> start; fast &lt;= end; fast++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[fast] != <span class="hljs-string">&#x27; &#x27;</span>) arr[slow++] = arr[fast];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[fast - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27; &#x27;</span>) arr[slow++] = arr[fast];<br>        &#125;<br>        <span class="hljs-type">char</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[slow - start];<br>        System.arraycopy(arr, start, newArr, <span class="hljs-number">0</span>, slow - start);<br>        <span class="hljs-keyword">return</span> newArr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>解法二：调用JAVA语言的API：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>调用API版      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.trim();<br>        List&lt;String&gt; list = Arrays.asList(s.split(<span class="hljs-string">&quot;\\s+&quot;</span>));<br>        Collections.reverse(list);<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>解法三：使用StringBuidler来保存字符，执行效率不高：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>StringBuilder版      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> trimSpaces(s);<br>        reverse(sb, <span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br>        reverseEachWord(sb);<br>        <span class="hljs-keyword">return</span> String.valueOf(sb);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(StringBuilder sb)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sb.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(start &lt; n) &#123;<br>            <span class="hljs-keyword">while</span>(end &lt; n &amp;&amp; sb.charAt(end) != <span class="hljs-string">&#x27; &#x27;</span>) end++;<br>            reverse(sb, start, end - <span class="hljs-number">1</span>);<br>            start = end + <span class="hljs-number">1</span>;<br>            end++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title function_">trimSpaces</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(s.charAt(start) == <span class="hljs-string">&#x27; &#x27;</span>) start++;<br>        <span class="hljs-keyword">while</span>(s.charAt(end) == <span class="hljs-string">&#x27; &#x27;</span>) end--;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(start &lt;= end) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(start) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                sb.append(s.charAt(start));<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(start - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(StringBuilder sb, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> sb.charAt(left);<br>            sb.setCharAt(left++, sb.charAt(right));<br>            sb.setCharAt(right--, tmp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>解法四：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>双端队列      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (arr[start] == <span class="hljs-string">&#x27; &#x27;</span>) start++;<br>        <span class="hljs-keyword">while</span> (arr[end] == <span class="hljs-string">&#x27; &#x27;</span>) end--;<br>        Deque&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(start &lt;= end) &#123;<br>            <span class="hljs-keyword">if</span>(word.length() != <span class="hljs-number">0</span> &amp;&amp; arr[start] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                queue.offerFirst(word.toString());<br>                word.setLength(<span class="hljs-number">0</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[start] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                word.append(arr[start]);<br>            &#125;<br>            start++;<br>        &#125;<br>        queue.offerFirst(word.toString());<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, queue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="卡码网：55-右旋转字符串"><a href="#卡码网：55-右旋转字符串" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1065">卡码网：55.右旋转字符串 </a></li><li>状态：对反转的灵活应用，简单。</li></ul>          </div><h2 id="2-1-解题过程"><a href="#2-1-解题过程" class="headerlink" title="2.1 解题过程"></a>2.1 解题过程</h2><ul><li>反转再局部反转。    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>卡码网：55.右旋转字符串      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.next();<br>        <span class="hljs-type">char</span>[] arr = str.toCharArray();<br><br>        Main.reverse(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        Main.reverse(arr, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        Main.reverse(arr, k, arr.length - <span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> chars[left];<br>            chars[left++] = chars[right];<br>            chars[right--] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 实现 strStr()</a></li><li>文档讲解：<a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">代码随想录–28. 实现 strStr()</a></li><li>状态：KMP算法，知道是要根据短的串预先算一个数组，然后进行跳转，具体记不清了。</li></ul>          </div><h2 id="3-1-解题过程"><a href="#3-1-解题过程" class="headerlink" title="3.1 解题过程"></a>3.1 解题过程</h2><ul><li>本题用暴力解法O(n^2)通过了，代码如下：    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>暴力枚举      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-type">char</span>[] longer = haystack.toCharArray();<br>        <span class="hljs-type">char</span>[] local = needle.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; longer.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; local.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (longer[k] == local[j]) &#123;<br>                    cnt++;<br>                    k++;<br>                    <span class="hljs-keyword">if</span>(cnt == local.length) <span class="hljs-keyword">return</span> i;<br>                    <span class="hljs-keyword">if</span>(k &gt;= longer.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt &lt; local.length) &#123;<br>                    cnt = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/repeated-substring-pattern/">459.重复的子字符串</a></li><li>文档讲解：<a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html">代码随想录–459.重复的子字符串</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1cg41127fw/">字符串这么玩，可有点难度！ | LeetCode：459.重复的子字符串</a></li><li>状态：KMP算法，一刷跳过了，容易忘记。</li></ul>          </div><h1 id="5-JAVA-API小结"><a href="#5-JAVA-API小结" class="headerlink" title="5. JAVA API小结"></a>5. JAVA API小结</h1><ul><li><code>str.trim()</code>: 去除字符串前导和后导空格；</li><li><code>str.split(regex, limit)</code>: 依据正则表达式分割字符串，limit表示应用正则表达式的次数；</li><li><code>Collections.reverse(list)</code>: 原地反转一个集合；</li><li><code>System.arrayCopy(strArr, srcPos, desArr, desPos, length)</code>: 快速拷贝一个数组。</li><li><code>String.join(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements)</code>：集合中的元素用指定分隔符分隔</li></ul><h1 id="6-字符串小结"><a href="#6-字符串小结" class="headerlink" title="6. 字符串小结"></a>6. 字符串小结</h1><p><strong>双指针法</strong>是字符串处理的常客。至今为止，我们在做数组、链表、字符串都用到了双指针法，双指针法并不隶属于某一种数据结构，但能够使用它来提高效率，一般是将O(n^2)时间复杂度，降低为O(n)。有时间还是要把<a href="https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html#%E6%95%B0%E7%BB%84%E7%AF%87">双指针的题目</a>再做一做。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day07 | {344.反转字符串, 541.反转字符串II, 15.三数之和，18.四数之和}</title>
    <link href="/cn/day07_leetcode/"/>
    <url>/cn/day07_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第四章字符串-part01，知识点为反转字符串、双指针。</p><span id="more"></span><h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/reverse-string/description/">344.反转字符串</a></li><li>状态：打基础的时候，不要太迷恋库函数。</li></ul>          </div><h2 id="1-1-解题过程"><a href="#1-1-解题过程" class="headerlink" title="1.1 解题过程"></a>1.1 解题过程</h2><ul><li><code>String</code>是不可变对象，而<code>StringBuilder</code>是可变对象，<code>reverse()</code>要求原地修改，所以这行代码等价于本题的实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(String.valueof(s)).reverse();<br><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> sb.toString();<br></code></pre></td></tr></table></figure></li></ul>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>344. 反转字符串      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> s[i];<br>            s[i++] = s[j];<br>            s[j--] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/reverse-string-ii/solutions/946553/fan-zhuan-zi-fu-chuan-ii-by-leetcode-sol-ua7s/">541. 反转字符串II</a></li><li>状态：模拟题。写得还可以再优雅一点。</li></ul>          </div><h2 id="2-1-解题过程"><a href="#2-1-解题过程" class="headerlink" title="2.1 解题过程"></a>2.1 解题过程</h2><ul><li>当需要以固定规律一段一段去处理字符串时，要想想for循环，在遍历字符串时，让<code>i += 2 * k</code>，然后判断是否有需要反转的区间。</li><li>也属于<strong>双指针</strong>的题目，因为有交换操作。之前做的<strong>原地反转链表</strong>题也是哦。</li></ul>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>541. 反转字符串II（优雅）      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[left];<br>            arr[left++] = arr[right];<br>            arr[right--] = tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] str = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> str.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span> * k) &#123;<br>            reverse(str, i, Math.min(i + k, n) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.valueOf(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="卡码网：54-替换数字"><a href="#卡码网：54-替换数字" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/reverse-string/description/">卡码网：54.替换数字</a></li><li>状态：用<code>StringBuilder</code>对象做，简单。</li></ul>          </div><h2 id="3-1-解题过程"><a href="#3-1-解题过程" class="headerlink" title="3.1 解题过程"></a>3.1 解题过程</h2><ul><li>看作业提示，还不明白<strong>后序处理</strong>指什么，看了题解之后觉得还不错啊，又用到了<strong>双指针</strong>的思想。</li><li>具体来说，把本题作为一个数组填充类的问题，通常的<strong>做法是先预先给数组扩容到填充后的大小，然后在从后向前进行操作</strong>。好处是：<ul><li>不用申请新数组。</li><li>从后往前填充，避免了从前往后填充时，每次要将添加元素之后的元素往后移动的问题。</li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>StringBuilder      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        <span class="hljs-type">char</span>[] str = s.toCharArray();<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (str[i] - <span class="hljs-string">&#x27;a&#x27;</span> &gt;=<span class="hljs-number">0</span> &amp;&amp; str[i] - <span class="hljs-string">&#x27;a&#x27;</span> &lt; <span class="hljs-number">26</span>) &#123;<br>                sb.append(str[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                sb.append(<span class="hljs-string">&quot;number&quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println(sb.toString());<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>双指针填充      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> scanner.next();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cntNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i))) cntNum++;<br>        &#125;<br><br>        <span class="hljs-type">char</span>[] newS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[s.length() + cntNum * <span class="hljs-number">5</span>];<br>        System.arraycopy(s.toCharArray(), <span class="hljs-number">0</span>, newS, <span class="hljs-number">0</span>, s.length());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> newS.length - <span class="hljs-number">1</span>, j = s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; ) &#123;<br>            <span class="hljs-keyword">if</span> (Character.isDigit(newS[j])) &#123;<br>                System.arraycopy(<span class="hljs-string">&quot;number&quot;</span>.toCharArray(), <span class="hljs-number">0</span>, newS, i - <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>                i -= <span class="hljs-number">6</span>;<br>                j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                newS[i--] = newS[j--];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(newS));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="3-2-双指针小结"><a href="#3-2-双指针小结" class="headerlink" title="3.2 双指针小结"></a>3.2 双指针小结</h2><p>此时算上本题，我们已经做了7道双指针相关的题目了，分别是：</p><ul><li><a href="https://leetcode.cn/problems/remove-element/description/">27.移除元素</a></li><li><a href="https://leetcode.cn/problems/3sum/description/">15.三数之和</a></li><li><a href="https://leetcode.cn/problems/4sum/description/">18.四数之和</a></li><li><a href="https://leetcode.cn/problems/reverse-linked-list/">206.翻转链表</a></li><li><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142.环形链表II</a></li><li><a href="https://leetcode.cn/problems/reverse-string/description/">344.反转字符串</a></li></ul><h1 id="4-VScode使用"><a href="#4-VScode使用" class="headerlink" title="4. VScode使用"></a>4. VScode使用</h1><ul><li>要一次性选中多行，<code>ctrl+shift+P</code>，输入<code>Toggle Column Selection Mode</code>并执行，确保关闭此模式。</li><li>以上。学习时长: <span class="label label-primary">2h</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day06 | {454.四数相加II, 383.赎金信, 15.三数之和，18.四数之和}</title>
    <link href="/cn/day06_leetcode/"/>
    <url>/cn/day06_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第三章哈希表-part02，知识点为哈希表、双指针、<strong>去重逻辑</strong>训练。</p><span id="more"></span><h1 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454. 四数相加II"></a>454. 四数相加II</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/4sum-ii/description/">454. 四数相加II</a></li><li>状态：两两数组求和，简化为两数之和即可，简单。</li></ul>          </div><h2 id="1-1-解题过程"><a href="#1-1-解题过程" class="headerlink" title="1.1 解题过程"></a>1.1 解题过程</h2><ul><li>这道题给了4个独立的数组，而且不用考虑有重复的4个元素加起来等于0的情况，比较简单。</li></ul>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>454. 四数相加II      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; sum1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer, Integer&gt; sum2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                sum1.put(nums1[i] + nums2[j], sum1.getOrDefault(nums1[i] + nums2[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                sum2.put(nums3[i] + nums4[j], sum2.getOrDefault(nums3[i] + nums4[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; e : sum1.entrySet()) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> e.getKey();<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">time1</span> <span class="hljs-operator">=</span> e.getValue();<br>            res += time1 * sum2.getOrDefault(-num1, <span class="hljs-number">0</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/ransom-note/description/">383. 赎金信</a></li><li>状态：本题和《242.有效的字母异位词》是一个思路，简单。</li></ul>          </div><h2 id="2-1-解题过程"><a href="#2-1-解题过程" class="headerlink" title="2.1 解题过程"></a>2.1 解题过程</h2><ul><li>注意在统计字符个数之前可以<strong>先剪枝</strong>一下。    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>383. 赎金信      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>        <span class="hljs-keyword">if</span>(ransomNote.length() &gt; magazine.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">char</span>[] magArr = magazine.toCharArray();<br>        <span class="hljs-type">char</span>[] ranArr = ransomNote.toCharArray();<br>        <span class="hljs-type">int</span>[] table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; magazine.length(); i++) &#123;<br>            table[magArr[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ransomNote.length(); i++) &#123;<br>            table[ranArr[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (table[i] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/3sum/description/">15. 三数之和</a></li><li>文档讲解：<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录–15. 三数之和</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1GW4y127qo/">梦破碎的地方！| LeetCode：15.三数之和</a></li><li>状态：没做出来。看视频之后写了一版代码，方法是排序+双指针。</li></ul>          </div><h2 id="3-1-解题过程"><a href="#3-1-解题过程" class="headerlink" title="3.1 解题过程"></a>3.1 解题过程</h2><ul><li><p>题目要求找到所有<strong>不重复</strong>且和为0的三元组，官方题解中讨论了<strong>不重复的本质</strong>是什么？</p><ul><li>保持三重循环的大框架不变；</li><li>保证第二重循环枚举到的元素<strong>不小于</strong>当前第一重循环枚举到的元素；</li><li>保证第三重循环枚举到的元素<strong>不小于</strong>当前第二重循环枚举到的元素。</li><li>也就是说我们枚举的三元组 <strong>(a,b,c)</strong> 满足<strong>a≤b≤c</strong>，保证了只有 <strong>(a,b,c)</strong> 这个顺序会被枚举到，减少了重复。</li><li><span class="label label-primary">要实现这一点，我们就要将数组中的元素从小到大进行排序</span>。</li></ul></li><li><p>解决这个问题的第一个关键点，数组排序了；随后第二步考虑对三重循环进行优化，通过双指针的方式，一个递增，一个递减。</p></li><li><p>整体思路有了之后，本题还要注意元素最终可行解的<strong>去重问题</strong>，比如i去重，什么时候可以跳过，注意是continue；在有序数组下，b和c去重条件又是什么。</p></li><li><p>剪枝操作可以进一步优化一下。</p></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>15. 三数之和      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">3</span> || nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// i去重</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] +nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] +nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>]) left++;  <span class="hljs-comment">// b去重</span><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>]) right--;  <span class="hljs-comment">// c去重</span><br>                    left++;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/4sum/description/">18. 四数之和</a></li><li>文档讲解：<a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录–18. 四数之和</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1DS4y147US/">难在去重和剪枝！| LeetCode：18. 四数之和</a></li><li>状态：本题和三数之和的思路相似，基本上解出来了，但在剪枝操作上出错了。</li></ul>          </div><h2 id="4-1-解题过程"><a href="#4-1-解题过程" class="headerlink" title="4.1 解题过程"></a>4.1 解题过程</h2><ul><li><p>题目要求在同一个数组nums中，<strong>避免枚举到重复四元组</strong>，就需要保证每一重循环枚举到的元素不小于其上一重循环枚举到的元素，且在同一重循环中不能多次枚举到相同的元素，为了实现要求：</p><ul><li>数组先从小到大排序；</li><li>同一重循环中，如果当前元素的与上一个元素相同，则跳过当前元素。</li></ul></li><li><p>具体实现过程中，我写的剪枝操作有一点问题，在N数之和里，剪枝只能<code>break/continue</code>，<code>return</code>只能用于整个搜索空间必无解的情况！</p></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>18. 四数之和      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; nums.length - <span class="hljs-number">3</span>; k++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[k] &gt; target &amp;&amp; (nums[k] &gt;= <span class="hljs-number">0</span> || target &gt;= <span class="hljs-number">0</span>)) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k + <span class="hljs-number">1</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; (nums[k] + nums[i] &gt;= <span class="hljs-number">0</span> || target &gt; <span class="hljs-number">0</span>)) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (i &gt; k + <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[k] + nums[i] + nums[left] + nums[right] &gt; target) right--;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[k] + nums[i] + nums[left] + nums[right] &lt; target) left++;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        res.add(Arrays.asList(nums[k], nums[i], nums[left], nums[right]));<br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>]) left++;<br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>]) right--;<br>                        left++;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="5-哈希表总结"><a href="#5-哈希表总结" class="headerlink" title="5. 哈希表总结"></a>5. 哈希表总结</h1><ul><li>想清楚这三个问题，并在需要快速判断一个数是否曾经出现过时，应立即想到用哈希表解题。<ul><li>什么时候使用哈希表？</li><li>使用数组&#x2F;Set&#x2F;还是Map？</li><li>往里面存什么？</li></ul></li><li>N数之和中排序后的<strong>去重思想</strong>，也是这两天的主要收获之一。</li></ul><h1 id="6-Java-API小结"><a href="#6-Java-API小结" class="headerlink" title="6. Java API小结"></a>6. Java API小结</h1><ul><li>Arrays工具类的使用<ul><li><code>Arrays.sort(nums)</code>: 对一个int数组升序排序；</li><li><code>Arrays.asList(T... a)</code>: 构造一个固定长度的list对象，好用。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day05 | {242.有效的字母异位词, 349.两个数组的交集, 202.快乐数，1.两数之和}</title>
    <link href="/cn/day05_leetcode/"/>
    <url>/cn/day05_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第三章哈希表-part01，以O(1)时间快速判断一个元素是否出现在集合里。</p><span id="more"></span><h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/valid-anagram/description/">242. 有效的字母异位词</a></li><li>状态：数组也是简单的哈希表，且题目条件说仅包含小写字母，维护一个长度为26的数组即可，简单。</li></ul>          </div><h2 id="1-1-解题过程"><a href="#1-1-解题过程" class="headerlink" title="1.1 解题过程"></a>1.1 解题过程</h2>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>数组存储      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">char</span>[] sArr = s.toCharArray();<br>        <span class="hljs-type">char</span>[] tArr = t.toCharArray();<br>        <span class="hljs-type">int</span>[] val= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sArr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            val[sArr[i] - <span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">1</span>;<br>            val[tArr[i] - <span class="hljs-string">&#x27;a&#x27;</span>] -= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(val[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>Map存储      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] sArr = s.toCharArray();<br>        <span class="hljs-type">char</span>[] tArr = t.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            map.put(sArr[i], map.getOrDefault(sArr[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            map.put(tArr[i], map.getOrDefault(tArr[i], <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 遍历map</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (entry.getValue() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li>为什么要用Map存储？因为key用来保存出现过的字母，value保存出现的次数。</li></ul><h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></li><li>状态：用HashSet，简单。</li></ul>          </div><h2 id="2-1-解题过程"><a href="#2-1-解题过程" class="headerlink" title="2.1 解题过程"></a>2.1 解题过程</h2><ul><li>主要思想是用哈希表存储元素，可以在<code>O(1)</code>时间内判断一个元素是否在集合中，比暴力的枚举时间复杂度更低。    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>两个数组的交集      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: nums1) &#123;<br>            set1.add(num);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums2) &#123;<br>            <span class="hljs-keyword">if</span> (set1.contains(num)) &#123;<br>                res.add(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数</a></li><li>状态：没做出来。</li></ul>          </div><h2 id="3-1-解题过程"><a href="#3-1-解题过程" class="headerlink" title="3.1 解题过程"></a>3.1 解题过程</h2><ul><li>一开始就是想顺着题目模拟获取下一个平方和的过程，缺乏探索，应该继续考虑以下三钟可能：<ol><li>最终会得到1。</li><li>最终会进入循环。</li><li>值会越来越大，最后接近无穷大。</li></ol></li><li>第三种情况是否可能呢？可以仔细想一想，每一位数的最大数字的next数是多少。排除第三种可能</li><li>第二种可能，循环表示之前出现过的数字<strong>再次出现</strong>，此时无解，其实和昨天的《环形链表判断》一模一样吧，解法有两种：<ol><li>用哈希表检测循环</li><li>用快慢指针检测循环（<code>getNext(n)</code>构成一个隐式的链表）</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>解法一哈希表      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>) &#123;<br>            sum += (k % <span class="hljs-number">10</span>) * (k % <span class="hljs-number">10</span>);<br>            k /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">1</span> &amp;&amp; !seen.contains(n)) &#123;<br>            seen.add(n);<br>            n = getNext(n);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>解法二快慢指针      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>) &#123;<br>            sum += (k % <span class="hljs-number">10</span>) * (k % <span class="hljs-number">10</span>);<br>            k /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slowRunner</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fastRunner</span> <span class="hljs-operator">=</span> getNext(n);<br>        <span class="hljs-keyword">while</span>(fastRunner != <span class="hljs-number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;<br>            slowRunner = getNext(slowRunner);<br>            fastRunner = getNext(getNext(fastRunner));<br>        &#125;<br>        <span class="hljs-keyword">return</span> fastRunner == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></li><li>文档讲解：<a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录–1. 两数之和</a></li><li>状态：对哈希表的使用还是不够熟练。</li></ul>          </div><h2 id="4-1-解题过程"><a href="#4-1-解题过程" class="headerlink" title="4.1 解题过程"></a>4.1 解题过程</h2><ul><li>为什么会想到用<strong>哈希表</strong>？<ul><li><code>target - x</code>能O(1)快速找到，对比暴力的枚举。</li></ul></li><li>为什么用Map？<ul><li>因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标。</li></ul></li><li>map用来存什么的？<ul><li>已经遍历过的元素存入其中。</li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>两数之和      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leave</span> <span class="hljs-operator">=</span> target - nums[i];<br>            <span class="hljs-keyword">if</span> (prev.containsKey(leave)) &#123;<br>                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;prev.get(leave), i&#125;;<br>            &#125;<br>            prev.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="5-Java-API小结"><a href="#5-Java-API小结" class="headerlink" title="5. Java API小结"></a>5. Java API小结</h1><ul><li><p>对于String类型的字符串，不能直接通过下标索引取出字符，一般有两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;leetcode&quot;</span>;<br><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 返回下标为0的字符</span><br><span class="hljs-type">char</span>[] chars = str.toCharArray();  <span class="hljs-comment">// 返回一个字符数组</span><br></code></pre></td></tr></table></figure></li><li><p>对于一个集合类型，如<code>Set</code>集合，要转为<code>int[]</code>数组，可以通过stream流式编程，但要注意两个map函数的区别：</p><ul><li><code>map()</code>: 返回的是<code>Stream&lt;Integer&gt;</code>，由此<code>toArray()</code>返回<code>Object[]</code>;</li><li><code>mapToInt()</code>: 返回的是基本输入流<code>IntStream</code>，由此<code>toArray()</code>返回<code>int[]</code>，不需要再拆箱。</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Set&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br><span class="hljs-comment">// 匿名内部类写法</span><br><span class="hljs-keyword">return</span> res.stream().mapToInt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ToIntFunction</span>&lt;Integer&gt;() &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">applyAsInt</span><span class="hljs-params">(Integer x)</span> &#123;<br>            <span class="hljs-keyword">return</span> x.intValue();<br>        &#125;<br>    &#125;).toArray();<br><br><span class="hljs-comment">// lambda表达式写法</span><br><span class="hljs-keyword">return</span> res.stream().mapToInt(x -&gt; x.intValue()).toArray();<br><br><span class="hljs-comment">// 类名::实例方法</span><br><span class="hljs-keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day04 | {24.两两交换链表中的节点, 19.删除链表的倒数第N个节点, 160. 链表相交，142. 环形链表II}</title>
    <link href="/cn/day04_leetcode/"/>
    <url>/cn/day04_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第二章链表-part02，知识点为快慢双指针、哈希表。</p><span id="more"></span><h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点</a></li><li>文档讲解：<a href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">代码随想录–24. 两两交换链表中的节点</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1YT411g7br/">帮你把链表细节学清楚！ | LeetCode：24. 两两交换链表中的节点</a></li><li>状态：我傻了，这题需要前后4个结点参与链表操作。</li></ul>          </div><h2 id="1-1-看完代码随想录的想法"><a href="#1-1-看完代码随想录的想法" class="headerlink" title="1.1 看完代码随想录的想法"></a>1.1 看完代码随想录的想法</h2><ul><li>需要画图，然后两两交换结点的过程中，这两个结点的<strong>前一个结点</strong>也需要参与更改索引，实现：    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>AC解法      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummyHead;<br>        <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> cur.next.next.next;<br>            cur.next = temp.next;<br>            temp.next.next = temp;<br>            temp.next = temp1;<br>            cur = cur.next.next;  <span class="hljs-comment">// 后移两格</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第N个节点</a></li><li>文档讲解：<a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">代码随想录–19.删除链表的倒数第N个节点</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1vW4y1U7Gf/">链表遍历学清楚！ | LeetCode：19.删除链表倒数第N个节点</a></li><li>状态：快慢指针法，不过注意快指针是先走<code>n+1</code>步，这样慢指针就落在要删除的结点的前一个位置上。</li></ul>          </div><h2 id="2-1-看完代码随想录的想法"><a href="#2-1-看完代码随想录的想法" class="headerlink" title="2.1 看完代码随想录的想法"></a>2.1 看完代码随想录的想法</h2><ul><li>同样是双指针的典型应用，数组和链表的题目前遇到很多双指针的解法了。</li><li>设置一个虚拟头结点，方便统一所有位置的删除逻辑。</li><li>以及注意为了防止<code>fast.next</code>报<strong>空指针异常</strong>，选择在前面n++，然后再进入循环，省去一个if判断。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>删除链表的倒数第N个节点      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummyHead, slow = dummyHead;<br>        n++;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span> &amp;&amp; (<span class="hljs-literal">null</span> != fast)) &#123;<br>            n--;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != fast) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="160-链表相交"><a href="#160-链表相交" class="headerlink" title="160. 链表相交"></a>160. 链表相交</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">160.链表相交</a></li><li>文档讲解：<a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">代码随想录–160.链表相交</a></li><li>状态：做题之前已经提示了数值相同，不一定索引地址相同，本题应该找到地址相同的结点。</li></ul>          </div><h2 id="3-1-解题过程"><a href="#3-1-解题过程" class="headerlink" title="3.1 解题过程"></a>3.1 解题过程</h2><ul><li><p>两次计算链表的长度，然后让长的链表的后半段和短链表对齐，再同步移动，这个思路比较简单，但是时间复杂度是O(n+m)，而且代码太长。</p></li><li><p>（解法一）用哈希表解决这题非常合适，<code>set.contains(Object o)</code>直接判断结点是否重复，就是空间复杂度为O(n)</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>哈希表      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        HashSet&lt;ListNode&gt; mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(headA != <span class="hljs-literal">null</span>) &#123;<br>            mySet.add(headA);<br>            headA = headA.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(headB != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mySet.contains(headB)) &#123;<br>                <span class="hljs-keyword">return</span> headB;<br>            &#125;<br>            headB = headB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>（解法二）链表1长度<strong>A+C</strong>，链表2长度<strong>B+C</strong>，则 A+C+B 一定等于 B+C+A。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>A+C+B=B+C+A      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span>headA, B = headB;<br>        <span class="hljs-keyword">while</span>(A!=B)&#123;<br>            A = A==<span class="hljs-literal">null</span>? headB:A.next;<br>            B = B==<span class="hljs-literal">null</span>? headA:B.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142. 环形链表II"></a>142. 环形链表II</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表II</a></li><li>文档讲解：<a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">代码随想录–142. 环形链表II</a></li><li>状态：没做出来。</li></ul>          </div><h2 id="4-1-解题过程"><a href="#4-1-解题过程" class="headerlink" title="4.1 解题过程"></a>4.1 解题过程</h2><ul><li><p>（解法一）画图设未知变量就清楚了，fast指针不管在圈里转了几圈都无所谓，当slow指针进入入口时，这时候的相对位置才重要。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>快慢双指针      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>         ListNode fast=head;<br>        ListNode slow=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>&amp;&amp;fast.next!=<span class="hljs-literal">null</span>)&#123;<br>            fast=fast.next.next;<br>            slow=slow.next;<br>            <span class="hljs-keyword">if</span>(fast==slow)&#123;<br>                <span class="hljs-keyword">while</span>(slow!=head)&#123;<br>                    slow=slow.next;<br>                    head=head.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>（解法二）哈希表非常简单了，挨个存入哈希Set，存之前判断是否已经在Set中。</p></li><li>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>哈希表      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        HashSet&lt;ListNode&gt; mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mySet.contains(head)) &#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            mySet.add(head);<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="5-链表总结"><a href="#5-链表总结" class="headerlink" title="5. 链表总结"></a>5. 链表总结</h1><ul><li>不管是增删操作，还是查询操作，给链表设置一个统一的虚拟头结点，总是方便的。</li><li>关于原地反转链表，用到了<strong>双指针</strong>，并且需要头结点；</li><li>关于删除倒数第N个结点、环形列表II（解法一），也用到了<strong>双指针</strong>（快慢双指针版）；</li><li>关注链表相交，解法2也是<strong>双指针</strong>；可见双指针思想非常重要。</li><li>如果题目涉及<strong>是否存在重复</strong>问题，<strong>利用哈希表不可重复的特性</strong>也是一种非常优雅而且简单的解法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day02 | {209.长度最小的子数组, 59.螺旋矩阵II, 3.区间和, 4.开发商买土地}</title>
    <link href="/cn/day02_leetcode/"/>
    <url>/cn/day02_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第一章数组-part02，知识点为双指针滑动窗口、模拟题、前缀和。</p><span id="more"></span><h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a></li><li>文档讲解：<a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">代码随想录–209长度最小的子数组</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1tZ4y1q7XE">拿下滑动窗口！ | LeetCode 209 长度最小的子数组</a></li><li>状态：暴力枚举超时</li></ul>          </div><h2 id="1-1-看到题目的想法"><a href="#1-1-看到题目的想法" class="headerlink" title="1.1 看到题目的想法"></a>1.1 看到题目的想法</h2><p>给定一个含有<code>n</code>个正整数的数组和一个正整数<code>s</code>，题目要求找出该数组中满足其和<code>≥ s</code>的长度最小的<strong>连续</strong>子数组，并返回其长度。一开始理解错了题意，以为是先排序再截取前几个元素即可，再读一遍题，其实是要求不能变动数组的相对位置，只想到了两层for循环，枚举出所有符合条件的子区间，记录最小长度。代码如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>暴力解法      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123;<br>                sum += nums[j];<br>                <span class="hljs-keyword">if</span> (sum &gt;= target) &#123;<br>                    ans = Math.min(ans, (j - i + <span class="hljs-number">1</span>));<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 不存在符合条件的子数组返回0</span><br>        <span class="hljs-keyword">return</span> Integer.MAX_VALUE == ans ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="1-2-看完代码随想录的想法"><a href="#1-2-看完代码随想录的想法" class="headerlink" title="1.2 看完代码随想录的想法"></a>1.2 看完代码随想录的想法</h2><ul><li>先看的视频讲解，还是<strong>双指针的思想</strong>，在一个for循环下完成两个for循环的工作，两个指针谁作为循环索引向后移动，需要考虑清楚这个问题。<ul><li>只用一个for循环，那么这个循环的索引，一定是表示<strong>滑动窗口的终止位置</strong>。</li><li><strong>滑动窗口的起始位置</strong>如何移动呢，明显地，当子数组的和超过<code>s</code>时就向后移动，但注意什么时候停止，当和小于<code>s</code>时停止，之间可能不止移动一次！</li></ul></li><li>妙啊！精妙，时间复杂度降低为On，代码如下：    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>滑动窗口      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;  <span class="hljs-comment">// 结束索引</span><br>            sum += nums[j];<br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                ans = Math.min(ans, (j - i + <span class="hljs-number">1</span>));<br>                sum -= nums[i++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.MAX_VALUE == ans ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59. 螺旋矩阵II"></a>59. 螺旋矩阵II</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59.螺旋矩阵II</a></li><li>文档讲解：<a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">代码随想录–59螺旋矩阵II</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1SL4y1N7mV/">一入循环深似海 | LeetCode：59.螺旋矩阵II</a></li><li>状态：模拟题，第一遍自己写写画画，耗时很久还没解出题目。</li></ul>          </div><h2 id="2-1-看到题目的想法"><a href="#2-1-看到题目的想法" class="headerlink" title="2.1 看到题目的想法"></a>2.1 看到题目的想法</h2><ul><li><p>没啥想法，Java打印一个二维数组的循环还咨询了一下GPT，代码如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>打印二维数组      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span>[][] ans = GenerateMatrix.generateMatrix(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] row : ans) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> val : row) &#123;<br>                System.out.printf(<span class="hljs-string">&quot;%3d &quot;</span>, val);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>如果不用矩阵打印，调用<code>Arrays.deepToString(ans)</code>，能看到内部数据。</p></li><li><p>Teacher Shan提供了一种和题解不一样的思路，像贪吃蛇，定义上下左右4种方向，初始化二维数组，初始方向设为右，若下一步的位置超过矩阵边界或者方格已有数据，则顺时针旋转，进入下一个方向，妙啊。</p><ul><li><span class="label label-primary">停止条件：直至填入n*n个元素，计数停止。</span></li></ul></li><li>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>方位法      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span>[][] POS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 右下左上</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">MaxCount</span> <span class="hljs-operator">=</span> n * n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">posIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始方向设为右</span><br>        <span class="hljs-keyword">while</span>(curNum &lt;= MaxCount) &#123;<br>            matrix[x][y] = curNum++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + POS[posIndex][<span class="hljs-number">0</span>], newY = y + POS[posIndex][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(newX &lt; <span class="hljs-number">0</span> || newX &gt;= n || newY &lt; <span class="hljs-number">0</span> || newY &gt;= n || matrix[newX][newY] != <span class="hljs-number">0</span>) &#123;<br>                posIndex = (posIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            &#125;<br>            x = x + POS[posIndex][<span class="hljs-number">0</span>];<br>            y = y + POS[posIndex][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h2 id="2-2-看完代码随想录的想法"><a href="#2-2-看完代码随想录的想法" class="headerlink" title="2.2 看完代码随想录的想法"></a>2.2 看完代码随想录的想法</h2><ul><li>要写出正确的二分法一定要坚持循环不变量的原则；要模拟出本题依然要<strong>坚持循环不变量的原则</strong>。四条边每画一条都要坚持一致的左闭右开原则，看了视频讲解的思路后，写出了第一版代码：    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>左闭右开不变量解法      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startX</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 随着圈数不一样在收缩</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(circle &gt; <span class="hljs-number">0</span>) &#123;<br>            circle--;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startX, j = startY;<br>            <span class="hljs-comment">// 坚持左闭右开原则去处理</span><br>            <span class="hljs-keyword">for</span> (; j &lt; n - offset; j++) &#123;<br>                ans[startX][j] = count++;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (; i &lt; n - offset; i++) &#123;<br>                ans[i][j] = count++;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (; j &gt; startY; j--) &#123;<br>                ans[i][j] = count++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(; i &gt; startX; i--) &#123;<br>                ans[i][j] = count++;<br>            &#125;<br>            <span class="hljs-comment">// 更新值</span><br>            startX++;<br>            startY++;<br>            offset++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 奇数n单独处理，矩阵中心的一个点</span><br>            ans[n/<span class="hljs-number">2</span>][n/<span class="hljs-number">2</span>] = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="3-区间和"><a href="#3-区间和" class="headerlink" title="3. 区间和"></a>3. 区间和</h1><div class="note note-info">            <ul><li>文档讲解：<a href="https://www.programmercarl.com/kamacoder/0058.%E5%8C%BA%E9%97%B4%E5%92%8C.html">代码随想录–3. 区间和</a></li><li>状态：看了题目想了一会，没想到使用<strong>前缀和的算法思想</strong>。</li></ul>          </div><h2 id="3-1-解题过程"><a href="#3-1-解题过程" class="headerlink" title="3.1 解题过程"></a>3.1 解题过程</h2><ul><li>时间原因，看了题目之后继续看了文档题解，看完思路又打开了，前缀和的思想是<strong>重复利用计算过的子数组之和</strong>，从而<strong>降低区间查询需要累加计算的次数</strong>，在涉及计算区间和的问题时非常有用。</li><li>例如：要计算vec数组的<strong>下标2到下标5</strong>之间的累加和，用前缀和数组的<code>p[5]-p[1]</code>就可以了。<br><img src="https://file1.kamacoder.com/i/algo/20240627111319.png" alt="一维数组前缀和示例"></li><li>我的前缀和数组留了一个哨兵的位置，这样可以省略if判断，代码如下：    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>一维数组前缀和      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> cn.leetcode.again;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrefixSum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 同时计算前缀和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            arr[i] = scanner.nextInt();<br>            pre[i + <span class="hljs-number">1</span>] = pre[i] + arr[i];<br>        &#125;<br><br>        System.out.println(Arrays.toString(arr));<br>        System.out.println(Arrays.toString(pre));<br><br>        <span class="hljs-keyword">while</span>(scanner.hasNextInt()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">endIndex</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> pre[endIndex + <span class="hljs-number">1</span>] - pre[startIndex];<br>            System.out.println(ans);<br>        &#125;<br>        scanner.close(); <span class="hljs-comment">// 释放资源</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="4-开发商购买土地"><a href="#4-开发商购买土地" class="headerlink" title="4. 开发商购买土地"></a>4. 开发商购买土地</h1><div class="note note-info">            <ul><li>文档讲解：<a href="https://www.programmercarl.com/kamacoder/0044.%E5%BC%80%E5%8F%91%E5%95%86%E8%B4%AD%E4%B9%B0%E5%9C%9F%E5%9C%B0.html">代码随想录–4. 开发商购买土地</a></li><li>状态：没做出来。</li></ul>          </div><h2 id="4-1-解题过程"><a href="#4-1-解题过程" class="headerlink" title="4.1 解题过程"></a>4.1 解题过程</h2><ul><li>一开始不是很理解题目，一个n*m的土地区域，只能竖着隔开一刀，或者横着隔开一刀，需要求两个子区域内土地总价值之间的最小差距。</li><li>其实分别从x轴和y轴两个方向上来看，设置<strong>两个一维前缀和数组</strong>即可，一个子区域A首先通过前缀和的思想算出累加和，另一个子区域B等于S<sub>total</sub> - S<sub>A</sub></li><li>并且原始的二维矩阵数组没必要保存下来，在输入的过程中已经可以计算两个方向上每行、每列的和。</li><li>随后退化为《第三题–区间和》。    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-738764b7" role="button" aria-expanded="false" aria-controls="collapse-738764b7">        <div class="fold-arrow">▶</div>开发商购买土地      </div>      <div class="fold-collapse collapse" id="collapse-738764b7">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span>[] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <span class="hljs-comment">// 每一行的和</span><br>        <span class="hljs-type">int</span>[] col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>                row[i] += val;<br>                col[j] += val;<br>                total += val;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 按照行分块，枚举数组下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            prefix += row[i];<br>            ans = Math.min(ans, Math.abs(total - prefix * <span class="hljs-number">2</span>));  <span class="hljs-comment">// 有没有可能是一个负数，有可能</span><br>        &#125;<br><br>        <span class="hljs-comment">// 按照列分块</span><br>        prefix = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) &#123;<br>            prefix += col[i];<br>            ans = Math.min(ans, Math.abs(total - prefix * <span class="hljs-number">2</span>));<br>        &#125;<br>        System.out.println(ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="5-今日收获"><a href="#5-今日收获" class="headerlink" title="5. 今日收获"></a>5. 今日收获</h1><ul><li>又理解了一点<strong>双指针的思想</strong>，一个for循环下完成两个for循环的工作，很妙啊。</li><li><strong>前缀和</strong>的算法思想也很妙啊，关于区间求和的问题都可以考虑用这个思路解法维度，开阔了思路。</li><li>数组专题总结：<a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%80%BB%E7%BB%93">4种典型的数组题目</a><ul><li>二分法</li><li>双指针法</li><li>滑动窗口（也是一种双指针）</li><li>模拟行为</li><li>前缀和</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day03 | {203. 移除链表元素, 707.设计链表, 206.反转链表}</title>
    <link href="/cn/day03_leetcode/"/>
    <url>/cn/day03_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第二章链表-part01，知识点为虚拟头结点、双指针原地反转链表、递归写法。</p><span id="more"></span><h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.移除链表元素</a></li><li>文档讲解：<a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录–203移除链表元素</a></li><li>视频讲解：<a href="bilibili.com/video/BV18B4y1s7R9/">手把手带你学会操作链表 | LeetCode：203.移除链表元素</a></li><li>状态：简单的单链表删除</li></ul>          </div><h2 id="1-1-看到题目的想法"><a href="#1-1-看到题目的想法" class="headerlink" title="1.1 看到题目的想法"></a>1.1 看到题目的想法</h2><p>加上虚拟的头结点，统一任意位置结点的删除操作，比较简单，实现如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>AC解法      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">preHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        preHead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> preHead.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> preHead;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (val == p.val) &#123;<br>                <span class="hljs-comment">// 删除结点</span><br>                pre.next = p.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = p;<br>            &#125;<br>            p = p.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> preHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="1-2-看完代码随想录的想法"><a href="#1-2-看完代码随想录的想法" class="headerlink" title="1.2 看完代码随想录的想法"></a>1.2 看完代码随想录的想法</h2><ul><li>设置虚拟头结点的写法，变量定义取名<code>cur</code>和<code>dummy</code>感觉挺好的。</li></ul><h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/design-linked-list/description/">707.设计链表</a></li><li>文档讲解：<a href="https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html">代码随想录–707.设计链表</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1FU4y1X7WD/">帮你把链表操作学个通透！LeetCode：707.设计链表</a></li><li>状态：写了一种单链表的MyLinkedList，挺简单。</li></ul>          </div><h2 id="2-1-解题过程"><a href="#2-1-解题过程" class="headerlink" title="2.1 解题过程"></a>2.1 解题过程</h2><p>注意第一次提交尾插法方法没有考虑到链表本身为空时，会有空指针异常。代码如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>AC解法      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> cn.leetcode.list;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设计单链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode listHead;  <span class="hljs-comment">// 链表虚拟头结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLinkedList</span><span class="hljs-params">()</span> &#123;<br>        listHead = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 链表下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> listHead.next;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= size) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= index - <span class="hljs-number">1</span>; i++) &#123;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p.val;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 头插法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        newNode.next = listHead.next;<br>        listHead.next = newNode;<br>        size++; <span class="hljs-comment">// 更新size</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尾插法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> listHead;  <span class="hljs-comment">// 注意null pointer</span><br>        <span class="hljs-keyword">while</span>(p.next != <span class="hljs-literal">null</span>) &#123;<br>            p = p.next;<br>        &#125;<br>        p.next = newNode;<br>        newNode.next = <span class="hljs-literal">null</span>;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如</span><br><span class="hljs-comment">     * 果 index 等于链表的长度，那么该节点会被追加到链表的末尾。</span><br><span class="hljs-comment">     * 如果 index 比长度更大，该节点将 不会插入 到链表中。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(index == size) &#123;<br>            addAtTail(val);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &gt; size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> listHead.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> listHead;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= index - <span class="hljs-number">1</span> ; i++) &#123;<br>                pre = p;<br>                p = p.next;<br>            &#125;<br>            <span class="hljs-comment">// 执行插入操作</span><br>            newNode.next = pre.next;<br>            pre.next = newNode;<br>            size++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果下标有效，则删除链表中下标为 index 的节点。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= size) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> listHead.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> listHead;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= index - <span class="hljs-number">1</span> ; i++) &#123;<br>            pre = p;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-comment">// 执行删除操作</span><br>        pre.next = p.next;<br>        size--;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/reverse-linked-list/">206.反转链表</a></li><li>文档讲解：<a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">代码随想录–206.反转链表</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1nB4y1i7eL//">帮你拿下反转链表 | LeetCode：206.反转链表 | 双指针法 | 递归法</a></li><li>状态：开了新的连表头，头插法解出来的。</li></ul>          </div><h2 id="3-1-看完视频讲解的想法"><a href="#3-1-看完视频讲解的想法" class="headerlink" title="3.1 看完视频讲解的想法"></a>3.1 看完视频讲解的想法</h2><ul><li>双指针法，原地反转的做法真妙啊，值得学习。</li><li>对照双指针方法写出递归解法。动画如下：<br><img src="https://file1.kamacoder.com/i/algo/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" alt="反转链表"><br>两个版本的代码如下：    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>AC解法      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> cn.leetcode.list;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseList</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 双指针写法，原地反转</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归写法主函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseListV2</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> reverse(head, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode cur, ListNode pre)</span> &#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> pre;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>        cur.next = pre;<br>        <span class="hljs-keyword">return</span> reverse(temp, cur);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法训练营day01 | {704.二分查找, 27.移除元素, 977.有序数组的平方}</title>
    <link href="/cn/day01_leetcode/"/>
    <url>/cn/day01_leetcode/</url>
    
    <content type="html"><![CDATA[<p>第一章数组-part01，知识点为二分查找、双向指针。</p><span id="more"></span><h1 id="0-每日精华"><a href="#0-每日精华" class="headerlink" title="0. 每日精华"></a>0. 每日精华</h1><ul><li><a href="https://www.yuque.com/chengxuyuancarl/cnopdt#">算法训练营每日精华</a> ：有关于for循环、数组越界、递归如何debug的技巧总结，不过还没用上，每一日的题目在这有<strong>额外的精炼总结</strong>，感觉容易遗忘这个资源，记录一下提醒自己。</li></ul><h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h1><div class="note note-success">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a></li><li>文档讲解：<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">代码随想录–704二分查找</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1fA4y1o715/?vd_source=a9e78e47d3e6d67d875c0260caff8550">手把手带你撕出正确的二分法 | 二分查找法 | 二分搜索法 | LeetCode：704. 二分查找</a></li><li>状态：左闭右闭区间做法</li></ul>          </div><h2 id="1-1-看到题目的想法"><a href="#1-1-看到题目的想法" class="headerlink" title="1.1 看到题目的想法"></a>1.1 看到题目的想法</h2><p>有序数组的二分查找，之前已经做过很多次了，结合示例思路清晰，代码如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>AC解法      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, answer = -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                answer = mid;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> answer; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="1-2-看完代码随想录的想法"><a href="#1-2-看完代码随想录的想法" class="headerlink" title="1.2 看完代码随想录的想法"></a>1.2 看完代码随想录的想法</h2><ul><li><p>忽略了一些题目的前提条件，满足二分法的前提条件有：</p><ul><li>数组有序</li><li><strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不唯一！</li></ul></li><li><p><strong>区间的定义</strong>有两种，我习惯的是第一种<strong>左闭右闭</strong>即<code>[left, right]</code>，第二种<strong>左闭右开</strong><code>[left, right)</code>没想到。</p></li><li><p>其次，对比参考写法，我定义了一个冗余变量<code>answer</code>；在计算下标mid时应该考虑溢出问题，因此优化代码如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>第一种改进写法      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(low &lt;= high) &#123;<br>            <span class="hljs-comment">// 防止溢出 int mid = (low + high) / 2;</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>熟悉第二种左闭右开的区间定义，考虑边界处理时，关注<strong>区间定义作为不变量</strong>，练习代码如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>AC解法2      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 左闭右开</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123; <span class="hljs-comment">// 没有等号，因为在左闭右开下==没有意义</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[mid] &gt; target 应该去左边区间寻找，且区间保持左闭右开</span><br>                high = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></li><li>文档讲解：<a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">代码随想录–27移除元素</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV12A4y1Z7LP/?vd_source=a9e78e47d3e6d67d875c0260caff8550">数组中移除元素并不容易！ | LeetCode：27. 移除元素</a></li><li>状态：花了较长的时间解题，一开始就是前后两指针移动，但边界处理想不清楚，Debug时间长。</li></ul>          </div><h2 id="2-1-看到题目的想法"><a href="#2-1-看到题目的想法" class="headerlink" title="2.1 看到题目的想法"></a>2.1 看到题目的想法</h2><p>题目要求给你一个数组nums，<strong>原地移除</strong>所有数值等于<code>val</code>的元素, 然后返回<code>nums</code>中与<code>val</code>不同的元素的数量。还是很好理解的，我和之前快排定位枢轴元素一样，定义了两个指针向中间移动，代码如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>自己的解法      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, answer = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] != val) &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// 找到第一个不等于val的元素</span><br>            <span class="hljs-keyword">while</span>(nums[left] == val &amp;&amp; right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] == val) &#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>                <span class="hljs-comment">// 交换元素</span><br>                nums[left] = nums[right];<br>                nums[right] = val;<br>            &#125;<br>        &#125;<br>        System.out.println(Arrays.toString(nums));<br><br>        <span class="hljs-comment">// 再遍历一遍找下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; j &gt;=<span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != val) &#123;<br>                answer = j + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="2-2-看完代码随想录的想法"><a href="#2-2-看完代码随想录的想法" class="headerlink" title="2.2 看完代码随想录的想法"></a>2.2 看完代码随想录的想法</h2><ul><li><strong>双指针法（快慢指针法）</strong>和我想得不太一样啊，这种数组前移覆盖的方式，写起来很简短清晰。附上定义：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。<br><img src="https://file1.kamacoder.com/i/algo/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="快慢指针法"><br>按照动画，完善代码如下：    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>快慢指针法      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 快慢指针法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElementV2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slowIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;<br>        <span class="hljs-keyword">if</span> (val != nums[fastIndex]) &#123;<br>            nums[slowIndex++] = nums[fastIndex];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slowIndex;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li>我的做法属于相向双指针法，写得不太优雅，有冗余的检索下标操作，需要优化，完善如下：    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>相向双指针法      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 相向双指针法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElementV3</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 将right移动到从右数第一个值不为val的位置</span><br>    <span class="hljs-keyword">while</span>(right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] == val) right--;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-comment">// left位置的元素需要被覆盖，用right元素覆盖</span><br>        <span class="hljs-keyword">if</span> (nums[left] == val) &#123;<br>            nums[left] = nums[right];<br>            right--;<br>        &#125;<br>        left++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h1><div class="note note-info">            <ul><li>题目链接：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977.有序数组的平方</a></li><li>文档讲解：<a href="https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html">代码随想录–977有序数组的平方</a></li><li>视频讲解：<a href="https://www.bilibili.com/video/BV1QB4y1D7ep">双指针法经典题目 | LeetCode：977.有序数组的平方</a></li><li>状态：暴力解题，直接平方之后再快速排序，快排参考了之前考研的刷题记录，还没领悟<strong>双指针思想</strong>。</li></ul>          </div><h2 id="3-1-看到题目的想法"><a href="#3-1-看到题目的想法" class="headerlink" title="3.1 看到题目的想法"></a>3.1 看到题目的想法</h2><p>题目要求给你一个按<strong>非递减顺序</strong>排序的整数数组<code>nums</code>，返回<strong>每个数字的平方</strong>组成的新数组，要求也按<strong>非递减顺序</strong>排序。本来想开三个数组，降低时间复杂度，但考虑到负数平方之后的数组仍然是一个无序的子数组，还是需要用到快排，所以没想到好的解题方法，时间复杂度nlogn。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-738764b7" role="button" aria-expanded="false" aria-controls="collapse-738764b7">        <div class="fold-arrow">▶</div>自己的解法      </div>      <div class="fold-collapse collapse" id="collapse-738764b7">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortedSquares</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 输入：nums = [-4,-1,0,3,10]</span><br><span class="hljs-comment">     * 输出：[0,1,9,16,100]</span><br><span class="hljs-comment">     * 解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="hljs-comment">     * 排序后，数组变为 [0,1,9,16,100]</span><br><span class="hljs-comment">     * 先全部平方然后快排排序一下  复杂度nlogn</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            ans[i] = nums[i] * nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 快排</span><br>        quickSort(<span class="hljs-number">0</span>, ans.length - <span class="hljs-number">1</span>, ans);<br><br>        System.out.println(Arrays.toString(ans));<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> partition(left, right, nums);<br>            quickSort(left, position - <span class="hljs-number">1</span>, nums);<br>            quickSort(position + <span class="hljs-number">1</span>, right, nums);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 确定序列的枢轴元素，并遍历使枢轴左边的元素都比它小，右边都比它大</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * (right - left + <span class="hljs-number">1</span>)) + left;<br>        swap(nums, left, pos);  <span class="hljs-comment">// 交换保证快排性能</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[left]; <span class="hljs-comment">// 枢轴</span><br><br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= nums[right]) &#123;<br>                right--;<br>            &#125;<br>            swap(nums, left, right);<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= nums[right]) &#123;<br>                left++;<br>            &#125;<br>            swap(nums, left, right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// 枢轴</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收数组+两个索引，通过索引交换数组元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> j</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i , <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="3-2-看完代码随想录的想法"><a href="#3-2-看完代码随想录的想法" class="headerlink" title="3.2 看完代码随想录的想法"></a>3.2 看完代码随想录的想法</h2><ul><li>哇，确实数组其实的有序的，只不过负数平方之后可能成为最大数了，那么<strong>数组平方的最大值一定就在数组的两端</strong>，不是最左边，就是最右边，不可能是中间。此时可以考虑使用<strong>双指针法</strong>，看到这里我明白了！非常清晰的解题思路，代码也不难写。<br><img src="https://file1.kamacoder.com/i/algo/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="双指针法"><br>重新敲一遍代码，如下：    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dfb167e8" role="button" aria-expanded="false" aria-controls="collapse-dfb167e8">        <div class="fold-arrow">▶</div>双指针法      </div>      <div class="fold-collapse collapse" id="collapse-dfb167e8">        <div class="fold-content">          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span>[] results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>, k = results.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] * nums[i] &lt;= nums[j] * nums[j]) &#123;<br>                results[k--] = nums[j] * nums[j];<br>                j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                results[k--] = nums[i] * nums[i];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li></ul><h1 id="4-今日收获"><a href="#4-今日收获" class="headerlink" title="4. 今日收获"></a>4. 今日收获</h1><ul><li>一直都很少刷题，今天算是迈出舒适圈了，然后Java是今年学的，在swap交换数组元素那里，没有把数组索引传过去，导致内存中的数组元素没有被更新，这个要注意。</li><li>今天学到了<strong>快慢指针法</strong>、以及有序数组的平方用到的<strong>双指针</strong>思想。</li><li>学习时长：<span class="label label-primary">4小时</span>（题不难，熟悉了一下流程，以及写以后博客的模板花了一点时间）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客优化记录</title>
    <link href="/cn/hexo_new_configeration/"/>
    <url>/cn/hexo_new_configeration/</url>
    
    <content type="html"><![CDATA[<p>今天更换了一个新域名，顺便修改了配置及fluid主题配置、网页访问统计、URL链接优化。</p><span id="more"></span><h1 id="1-域名更换"><a href="#1-域名更换" class="headerlink" title="1.域名更换"></a>1.域名更换</h1><p><img src="https://s2.loli.net/2025/01/25/gz8C7OH362lG1NT.png" alt="解析记录"></p><h1 id="2-MAC风格代码高亮"><a href="#2-MAC风格代码高亮" class="headerlink" title="2.MAC风格代码高亮"></a>2.MAC风格代码高亮</h1><ul><li><p>将<span class="label label-secondary">style</span>修改为<span class="label label-secondary">Night Owl</span>暗色风格；</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://s2.loli.net/2025/01/25/uKUEHeRbjL4xrS7.png" alt="image.png"></div><div class="group-image-wrap"><img src="https://s2.loli.net/2025/01/25/C1HNxa3rZUVf65W.png" alt="image.png"></div></div><div class="group-image-row"></div></div></li><li><p>接着在路径<span class="label label-secondary">myblog/themes/fluid/source/css</span>下新建文件<span class="label label-secondary">mac.styl</span>；</p></li><li><p>在路径<span class="label label-secondary">myblog/_config.fluid.yml</span>中找到<span class="label label-secondary">custom_css</span>选项，改为<span class="label label-secondary">/css/mac.css</span>，原先是相对路径下的<code>iconfont.css</code></p></li><li><p>行内代码颜色，从<code>inherit</code>改为<code>#E05B35</code>，打开路径<span class="label label-secondary">myblog/themes/fluid/source/css/_pages/_base</span>下的<span class="label label-secondary">base.styl</span>文件，找到<code>code</code>配置项。</p></li></ul><h1 id="3-全局字体配置"><a href="#3-全局字体配置" class="headerlink" title="3.全局字体配置"></a>3.全局字体配置</h1><ul><li>fluid主题配置文件下，调整代码字体大小及显示比例。<br><img src="https://s2.loli.net/2025/01/25/65lB8eu3TpCPEUd.png" alt="_config.fluid.yml"></li></ul><h1 id="4-修改post-md的默认布局"><a href="#4-修改post-md的默认布局" class="headerlink" title="4.修改post.md的默认布局"></a>4.修改post.md的默认布局</h1><ul><li><p><a href="https://hexo.io/zh-cn/docs/front-matter">官方文档front-matter</a>中提到并列分类的写法。<br><img src="https://s2.loli.net/2025/01/25/8URkyMEZeAxFNjr.png" alt="并列分类"></p></li><li><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E5%9C%A8%E9%A6%96%E9%A1%B5%E7%9A%84%E5%B0%81%E9%9D%A2%E5%9B%BE">Hexo Fluid用户手册</a><br><img src="https://s2.loli.net/2025/01/25/7xKrnzwjHpmTV15.png" alt="post.md模板"></p></li></ul><h1 id="5-网页访问次数统计"><a href="#5-网页访问次数统计" class="headerlink" title="5.网页访问次数统计"></a>5.网页访问次数统计</h1><ul><li>使用一个第三方服务Leancloud来统计文章的阅读量，具体参考<a href="https://blog.csdn.net/qq_48759664/article/details/119460188">Hexo-fluid主题设置统计博客阅读量</a>。</li></ul><h1 id="6-url链接优化"><a href="#6-url链接优化" class="headerlink" title="6.url链接优化"></a>6.url链接优化</h1><p>找了一下有两种办法，一种是<code>npm install hexo-abbrlink --save</code>安装插件，生成一串永久数字id，适合于到时候搜索引擎收录时用。另一种我简单改一下<code>__config.yml</code>下的永久链接格式。</p><ul><li><a href="https://blog.csdn.net/qq_29654777/article/details/108228155?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-108228155-blog-116612063.235%5Ev43%5Epc_blog_bottom_relevance_base4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-108228155-blog-116612063.235%5Ev43%5Epc_blog_bottom_relevance_base4&utm_relevant_index=4">Hexo折腾系列——永久链接优化</a></li><li><a href="https://blog.csdn.net/qq_45890533/article/details/124185573">Hexo博客url优化</a></li></ul><h1 id="7-压缩静态资源"><a href="#7-压缩静态资源" class="headerlink" title="7.压缩静态资源"></a>7.压缩静态资源</h1><p>博客中有大量 HTML、CSS、JS 文件，这些文件为了阅读方便会加入许多回车和空行，但在页面解析时其实会浪费部分时间，此外如果有许多插图，也会拖慢网页加载，并占据 GitHub 仓库的存储空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs BASH">$ npm install hexo-all-minifier --save  <span class="hljs-comment"># 出现 npm ERR! code ELIFECYCLE 错误</span><br>$ npm install hexo-neat --save <span class="hljs-comment"># 换成这个后成功安装</span><br></code></pre></td></tr></table></figure><p>之后在配置文件<span class="label label-secondary">myblog/_config.yml</span>中增加如下内容就行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs BASH"><span class="hljs-comment"># hexo-neat</span><br><span class="hljs-comment">## Docs: https://github.com/rozbo/hexo-neat</span><br>neat_enable: <span class="hljs-literal">true</span><br><span class="hljs-comment"># 压缩 html</span><br>neat_html:<br>  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>  exclude:<br><span class="hljs-comment"># 压缩 css  </span><br>neat_css:<br>  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>  exclude:<br>    - <span class="hljs-string">&#x27;**/*.min.css&#x27;</span><br><span class="hljs-comment"># 压缩 js</span><br>neat_js:<br>  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>  mangle: <span class="hljs-literal">true</span><br>  output:<br>  compress:<br>  exclude:<br>    - <span class="hljs-string">&#x27;**/*.min.js&#x27;</span><br>    - <span class="hljs-string">&#x27;**/jquery.fancybox.pack.js&#x27;</span><br>    - <span class="hljs-string">&#x27;**/index.js&#x27;</span> <br></code></pre></td></tr></table></figure><ul><li>本次修改主要参考博客，以及之后搜索引擎收录这边也有：<a href="https://hwcoder.top/Hexo-Configuration">Hexo配置与扩展</a></li><li><a href="https://www.jianshu.com/p/ba692a97a602">让你的 Hexo 博客更美观的 N 种配置（基于 Fluid 主题扩展）</a></li><li><a href="https://blog.csdn.net/qq_38652871/article/details/84141469/">font-family常用字体集合</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pycharm连接服务器</title>
    <link href="/cn/remote-server-connection/"/>
    <url>/cn/remote-server-connection/</url>
    
    <content type="html"><![CDATA[<p>记一下pycharm连接远程服务器，步骤。</p><span id="more"></span><h2 id="一、建立远程服务器连接"><a href="#一、建立远程服务器连接" class="headerlink" title="一、建立远程服务器连接"></a>一、建立远程服务器连接</h2><h3 id="1-1-创建远程连接"><a href="#1-1-创建远程连接" class="headerlink" title="1.1 创建远程连接"></a>1.1 创建远程连接</h3><p><img src="https://s2.loli.net/2025/01/07/CpflgDc7yEtmsje.png" alt="image.png"></p><h3 id="1-2-本地-远程项目文件夹映射"><a href="#1-2-本地-远程项目文件夹映射" class="headerlink" title="1.2 本地-远程项目文件夹映射"></a>1.2 本地-远程项目文件夹映射</h3><p><img src="https://s2.loli.net/2025/01/07/INDzQwTGuBPcLdo.png" alt="image.png"></p><h3 id="1-3-验证连接是否成功-调出服务器文件目录"><a href="#1-3-验证连接是否成功-调出服务器文件目录" class="headerlink" title="1.3 验证连接是否成功(调出服务器文件目录)"></a>1.3 验证连接是否成功(调出服务器文件目录)</h3><p><img src="https://s2.loli.net/2025/01/07/15EgjS4FNiIJclZ.png" alt="image.png"></p><h2 id="二、在终端打开SSH连接"><a href="#二、在终端打开SSH连接" class="headerlink" title="二、在终端打开SSH连接"></a>二、在终端打开SSH连接</h2><p><img src="https://s2.loli.net/2025/01/07/rnsW9lGyZ6MKDIO.png" alt="image.png"></p><h2 id="三、新建虚拟环境"><a href="#三、新建虚拟环境" class="headerlink" title="三、新建虚拟环境"></a>三、新建虚拟环境</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>依据requirments安装依赖库      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">conda create --name dc_env <span class="hljs-keyword">python</span>=<span class="hljs-number">3.7</span><br><br><span class="hljs-keyword">cd</span> dc_code/<br><br><span class="hljs-keyword">ls</span> |<span class="hljs-keyword">grep</span> requirements.txt<br><br>conda activate dc_env<br><br>pip install -r requirements.txt -i https://mirrors.aliyun.<span class="hljs-keyword">com</span>/pypi/simple<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="四、本地配置python解释器"><a href="#四、本地配置python解释器" class="headerlink" title="四、本地配置python解释器"></a>四、本地配置python解释器</h2><h3 id="4-1-查询服务器某环境的python解释器路径"><a href="#4-1-查询服务器某环境的python解释器路径" class="headerlink" title="4.1 查询服务器某环境的python解释器路径"></a>4.1 查询服务器某环境的python解释器路径</h3><p><img src="https://s2.loli.net/2025/01/07/u3SUw16PA5rfiCO.png" alt="image.png"></p><h3 id="4-2-本地pycharm配置python解释器"><a href="#4-2-本地pycharm配置python解释器" class="headerlink" title="4.2 本地pycharm配置python解释器"></a>4.2 本地pycharm配置python解释器</h3><p><img src="https://s2.loli.net/2025/01/07/jTiUmEtyvZYqIC5.png" alt="image.png"></p><p><img src="https://s2.loli.net/2025/01/07/a4o8jtLOEnrVleq.png" alt="image.png"></p><p><img src="https://s2.loli.net/2025/01/07/W7Gxe5okwb6T4na.png" alt="image.png"></p><p>OK，环境配置完成，可以按照readme来测试代码了。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://blog.csdn.net/qq_43755954/article/details/143301325">pip install -r requirements.txt下载速度慢</a></li><li><a href="https://www.cnblogs.com/nickchen121/p/11107842.html">Anaconda常用命令</a></li><li><a href="https://blog.csdn.net/qq_45100200/article/details/130355935?ops_request_misc=%257B%2522request%255Fid%2522%253A%25229b52b46ffddd03caa0ba8ef28f39735a%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=9b52b46ffddd03caa0ba8ef28f39735a&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-130355935-null-null.142%5Ev101%5Epc_search_result_base8&utm_term=pycharm%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1018.2226.3001.4187">PyCharm连接远程服务器配置过程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>远程连接</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注意力机制</title>
    <link href="/cn/attention_mechanism/"/>
    <url>/cn/attention_mechanism/</url>
    
    <content type="html"><![CDATA[<p>学习注意力机制的原理和实现代码</p><span id="more"></span><h1 id="1-注意力机制"><a href="#1-注意力机制" class="headerlink" title="1. 注意力机制"></a>1. 注意力机制</h1><p>查询对象Query，被查询对象Value，通过去计算Q和V里的事物的<strong>相似度</strong>(更接近)，来判断哪些东西对Q来说更重要，哪些更不重要。</p><p>Q，$K &#x3D;k_1,k_2,\cdots,k_n$</p><p>通过点乘求内积的方法计算Q和K里的每一个事物的相似度，就可以拿到Q和$k_1$的相似度值$s_1$、Q和$k_2$的相似度值$s_2$、Q和$k_n$的相似度值$s_n$。计算$QK^T$后为避免输入的值差异过大导致Softmax的概率值过于极端，需要<strong>归一化</strong>，归一化的方式是<strong>除以嵌入向量维度的平方根。</strong></p><p>做一层$softmax(s_1, s_2,\cdots,s_n)$就可以得到概率$(a_1,a_2,\cdots,a_n)$，进而找到哪个事物对Q更重要。</p><p><img src="https://s2.loli.net/2024/12/18/ibh63dSvEWmJNG9.png" alt="image.png"></p><p>最后做一个汇总，拿到**经过注意力计算之后的图片$V’$**，现在这张图片中多了一些信息，多了于Q而言更重要、更不重要的信息。</p><p>$V&#x3D;(v_1, v_2, \cdots, v_n)$</p><p>$(a_1,a_2,\cdots,a_n) *+(v_1,v_2,\cdots,v_n)&#x3D;(a_1v_1+a_2v_2+\cdots+a_nv_n)$ &#x3D; V’</p><p><img src="https://s2.loli.net/2024/12/18/No5PiGVS4KZ2A9X.png" alt="image.png"></p><h1 id="2-自注意力机制-Self-attention"><a href="#2-自注意力机制-Self-attention" class="headerlink" title="2. 自注意力机制(Self-attention)"></a>2. 自注意力机制(Self-attention)</h1><p>在注意力机制中，一般来说Key和Value是相等的，或者一定具有某种关系。而Self-Attention中， Query、Key、Value三者是同源的，即K$\approx$V$\approx$Q，来源于同一个X。</p><p><strong>对X分别做三次线性变换，得到Query、Key、Value</strong>，通过X找到X里面的关键点。接下来的步骤和注意力机制一模一样，如图，列表示一个个X词向量，行表示分别要和句子中的每个词做一下相似度计算。</p><p>效果是：给定一个 X，通过自注意力模型，得到一个 Z，这个 Z 就是对 X 的新的表征（词向量），Z 这个词向量相比较 X 拥有了句法特征和语义特征。</p><p><img src="https://s2.loli.net/2024/12/18/mx1Rgsy7Sw9PAk2.png" alt="image.png"><br><img src="https://s2.loli.net/2024/12/18/UpFLilbYhmyWZXg.png" alt="image.png"></p><h1 id="3-多头自注意力-Multi-Head-Self-Attention"><a href="#3-多头自注意力-Multi-Head-Self-Attention" class="headerlink" title="3. 多头自注意力(Multi-Head Self-Attention)"></a>3. 多头自注意力(Multi-Head Self-Attention)</h1><h2 id="3-1-什么是多头"><a href="#3-1-什么是多头" class="headerlink" title="3.1 什么是多头"></a>3.1 什么是多头</h2><p>对于X,我们不是说，直接拿 X 去得到 Z，而是把 X 分成了 8 块（8 头），得到 Z0-Z7，然后把 Z0-Z7 拼接起来，再做一次线性变换（改变维度）得到 Z，使其和原来的X词向量维度一致。</p><h2 id="3-2-有什么作用"><a href="#3-2-有什么作用" class="headerlink" title="3.2 有什么作用"></a>3.2 有什么作用</h2><p>把X切成8个，这样原先在一个位置的X，去了空间上的8个位置，通过对8个点进行寻找(非线性变换，映射到更合理的空间)，找到更合适的位置。</p><p><img src="https://s2.loli.net/2024/12/18/f5kVD6dHu2UhzSn.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Transformer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>度量学习思路整合</title>
    <link href="/cn/metric-learning-refinement/"/>
    <url>/cn/metric-learning-refinement/</url>
    
    <content type="html"><![CDATA[<p>few-shot learning的度量学习方法阅读与总结，目标是找到一篇文章，解决few-shot的以下问题：<br>在基类上，模型学会区分相似和不相似的实例，从而提高下游任务的性能；<br>支持集的样本过少，计算得到的类代表原型和实际期望得到的类原型有较大偏差，如何矫正<strong>有偏的类原型</strong>，进而提高模型分类精度。</p><span id="more"></span><h2 id="1-Prototype-Rectification-for-Few-Shot-Learning"><a href="#1-Prototype-Rectification-for-Few-Shot-Learning" class="headerlink" title="1.Prototype Rectification for Few-Shot Learning"></a>1.Prototype Rectification for Few-Shot Learning</h2><h3 id="1-1-基本信息"><a href="#1-1-基本信息" class="headerlink" title="1.1 基本信息"></a>1.1 基本信息</h3><ul><li><p>2020年，ECCV会议论文</p></li><li><p>无开源源码</p></li><li><p>提出了如何减少类原型的偏置、减少support和query dataset之间的分布差。</p></li></ul><h3 id="1-2-方法记录"><a href="#1-2-方法记录" class="headerlink" title="1.2 方法记录"></a>1.2 方法记录</h3><h4 id="1-2-1-intra-class-bias"><a href="#1-2-1-intra-class-bias" class="headerlink" title="1.2.1 intra-class bias"></a>1.2.1 intra-class bias</h4><p>为了减少实际计算出的原型和真实原型之间的差距，采用<strong>伪标签策略</strong>，补充<code>support set</code>的样本，由此得到更接近真实的原型。具体操作是取<code>top-k</code>个置信度的未标记样本，加上伪标签，加入<code>support set</code>一起计算类代表原型，其中为了避免伪标签错分给原型带来大的误差，使用<strong>加权和的平均作为修改的原型</strong>，权重的计算公式：样本和basic prototypes有更大的余弦相似度，则在修改的原型中有更高占比。</p><div class="note note-info">            <p>伪标签有一个使用前提，即需要一次性给出某个类的所有未标记样本，不适用于一个个给测试样本的情况。在脑电身份识别上，一个人作为一个类，<strong>他的测试样本是否可以一次性获取到？</strong>，决定了伪标签是否适用。</p>          </div><h4 id="1-2-2-cross-class-bias"><a href="#1-2-2-cross-class-bias" class="headerlink" title="1.2.2 cross-class bias"></a>1.2.2 cross-class bias</h4><p>首先两个set被假设为分布在同一个domain中，但<code>support set</code>和<code>quary set</code>之间存在<strong>分布差</strong>，提出为了减少两者的分布差，可以把<code>quary set</code>朝<code>support set</code>移动。具体地，文章提出给每个标准化后的quary feature$\overline{X_q}$添加一个转换参数epilon。<br><img src="https://s2.loli.net/2024/12/09/qnV2rhwZTyjYGM8.png" alt="image.png"></p><div class="note note-info">            <p>减小分布差，脑电身份识别，support set用的是登记session的样本，quary set可能用的是另一个session的样本，由于时变性，两者的分布差肯定是存在的，甚至于同一个session，随着人状态的波动，样本之间估计也存在明显的分布差，这个方法可以一试。</p>          </div><h2 id="2-Free-Lunch-for-Few-shot-Learning-Distribution-Calibration"><a href="#2-Free-Lunch-for-Few-shot-Learning-Distribution-Calibration" class="headerlink" title="2.Free Lunch for Few-shot Learning: Distribution Calibration"></a>2.Free Lunch for Few-shot Learning: Distribution Calibration</h2><h3 id="2-1-基本信息"><a href="#2-1-基本信息" class="headerlink" title="2.1 基本信息"></a>2.1 基本信息</h3><ul><li><p>2021年，ICLR会议论文</p></li><li><p>源码：<a href="https://github.com/ShuoYang-1998/Few_Shot_Distribution_Calibration">Few_Shot_Distribution_Calibration</a></p></li><li><p>提出从语义相似的基类(s)迁移统计数据来校准这些少数样本类的分布，接着<strong>依据新分布的均值和方差随机采样一定数量的样本</strong>，对novel classes的n_way k_shot任务的支持集进行补充，补充后的support set aug输入分类器fit。</p></li></ul><h3 id="2-2-方法记录"><a href="#2-2-方法记录" class="headerlink" title="2.2 方法记录"></a>2.2 方法记录</h3><p>前提假设：假设特征嵌入的每个维度都服从<strong>高斯分布</strong>。</p><p>这篇代码<strong>基类</strong>是有充足样本的类，用别人的SOTA分类模型，取倒数第二层作为特征提取器，用于提取基类和novel类的特征嵌入。接着计算每个基类特征层面的均值向量和协方差。</p><p>测试类(novel classes)用的是轮次训练的方式，例如：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>FSLTask参数      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-comment"># ---- data loading</span><br>    dataset = <span class="hljs-string">&#x27;miniImagenet&#x27;</span><br>    n_shot = <span class="hljs-number">1</span><br>    n_ways = <span class="hljs-number">5</span><br>    n_queries = <span class="hljs-number">15</span><br>    n_runs = <span class="hljs-number">10000</span><br>    n_lsamples = n_ways * n_shot<br>    n_usamples = n_ways * n_queries<br>    n_samples = n_lsamples + n_usamples<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><p>每次从novel classes中抽5个类，每个类有1个support sample，15个query sample。每一次run，对抽取的5个support_data(先转成特征嵌入)分别做分布校准，然后生成若干个数的特征向量作为support集的<strong>补充</strong>，一起输入分类器fit，在query samples上测试，计算acc，最后取10000次run的平均acc。</p><p>分布校准core代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">distribution_calibration</span>(<span class="hljs-params">query, base_means, base_cov, k,alpha=<span class="hljs-number">0.21</span></span>):<br>    dist = []  <span class="hljs-comment"># 计算support sample(变量名叫query)和mean之间的欧式距离</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(base_means)):<br>        dist.append(np.linalg.norm(query-base_means[i]))<br>    index = np.argpartition(dist, k)[:k]  <span class="hljs-comment"># 从数组 dist 中找到前𝑘小的元素的索引</span><br>    mean = np.concatenate([np.array(base_means)[index], query[np.newaxis, :]])<br>    calibrated_mean = np.mean(mean, axis=<span class="hljs-number">0</span>)<br>    calibrated_cov = np.mean(np.array(base_cov)[index], axis=<span class="hljs-number">0</span>)+alpha<br><br>    <span class="hljs-keyword">return</span> calibrated_mean, calibrated_cov<br></code></pre></td></tr></table></figure><div class="note note-primary">            <ol><li>这篇文章在<strong>细粒度数据集CUB</strong>上也应用了DC方法，有超过200种不同的鸟类图片。每个人的脑电虽然说各自有判别性特征，其实还是很相似的细粒度数据，这个方法通过迁移<span class="label label-secondary">k</span>个距离最小的基类的分布，来直接增加支持集的样本，进而提高分类性能。</li><li>要调的超参数多，采样个数、k个基类、离散程度a。</li><li>在脑电上是否有效呢？特征向量都是经过标准化&#x2F;幂变换的。</li></ol>          </div><h2 id="3-Semantic-Based-Implicit-Feature-Transform-for-Few-Shot-Classification"><a href="#3-Semantic-Based-Implicit-Feature-Transform-for-Few-Shot-Classification" class="headerlink" title="3.Semantic-Based Implicit Feature Transform for Few-Shot Classification"></a>3.Semantic-Based Implicit Feature Transform for Few-Shot Classification</h2><h3 id="3-1-基本信息"><a href="#3-1-基本信息" class="headerlink" title="3.1 基本信息"></a>3.1 基本信息</h3><ul><li><p>2024年，International Journal of Computer Vision</p></li><li><p>源码：<a href="https://github.com/pmhDL/SIFT.git">SIFT</a></p></li><li><p>借鉴的是前面分布矫正的论文，同样是通过从基类补充特征向量到novel类上面去，不同的是图像类别标签（如cat、dog），<strong>本身具有语义信息</strong>，可以用不同的词向量来表达。然后通过语义嵌入的相似度来选择最近的基类，而不是前面通过统计特征。</p></li></ul><h3 id="3-2-方法记录"><a href="#3-2-方法记录" class="headerlink" title="3.2 方法记录"></a>3.2 方法记录</h3><ul><li><p>脑电的类别标签纯粹是<span class="label label-secondary">'Person A'</span>、<span class="label label-secondary">'Person B'</span>的形式，并不具有语义信息，所以如果要用，应该采用Free Lunch的方法<strong>做跨时段的分布矫正</strong>。</p></li><li><p>提出了一种原型矫正的方法。适用于transductive setting，即查询样本全部一次给出的情况。通过K-means把查询样本分簇为N类，接着建立路径规划问题的数学模型，为这N个类别确定互相不重复的标签，与初始的每个类原型做平均。</p></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>原型矫正实现      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">updateproto</span>(<span class="hljs-params">Xs, ys, cls_center, way</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;更新原型 (prototype)，并与聚类中心 (cluster center) 结合&quot;&quot;&quot;</span><br>    <br>    <span class="hljs-comment"># 调用 np_proto 计算每个类别的原型</span><br>    proto = np_proto(Xs, ys, way)  <br>    <br>    <span class="hljs-comment"># 计算每个类别原型与所有聚类中心之间的平方欧式距离</span><br>    <span class="hljs-comment"># 使用广播机制，扩展 proto 和 cls_center 的维度后相减</span><br>    dist = ((proto[:, np.newaxis, :] - cls_center[np.newaxis, :, :]) ** <span class="hljs-number">2</span>).<span class="hljs-built_in">sum</span>(<span class="hljs-number">2</span>)  <br>    <br>    <span class="hljs-comment"># 找到每个类别原型距离最近的聚类中心索引</span><br>    <span class="hljs-built_in">id</span> = dist.argmin(<span class="hljs-number">1</span>)  <br>    feat_proto = np.zeros((way, Xs.shape[<span class="hljs-number">1</span>]))  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(way):<br>        <span class="hljs-comment"># 将当前类别的原型和其最近的聚类中心取平均值</span><br>        feat_proto[i] = (cls_center[<span class="hljs-built_in">id</span>[i]] + proto[i]) / <span class="hljs-number">2</span>  <br>    <br>    <span class="hljs-keyword">return</span> feat_proto  <br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h2 id="4-Matching-Feature-Sets-for-Few-Shot-Image-Classification"><a href="#4-Matching-Feature-Sets-for-Few-Shot-Image-Classification" class="headerlink" title="4.Matching Feature Sets for Few-Shot Image Classification"></a>4.Matching Feature Sets for Few-Shot Image Classification</h2><h3 id="4-1-基本信息"><a href="#4-1-基本信息" class="headerlink" title="4.1 基本信息"></a>4.1 基本信息</h3><ul><li><p>2022年，CVPR会议论文</p></li><li><p>源码：<a href="https://lvsn.github.io/SetFeat/">SetFeat-fs</a></p></li><li><p>以Conv4-64骨干网络为例，提出把一张图像输入进去，经过一个Block，就输出一个经<strong>自注意力机制mapper</strong>计算后的特征向量$h_m$，这样处理从一张图片中提取出一组m(4)个特征向量。距离度量用的是负余弦相似度，实际上和原型网络的距离度量很相似，区分在于有多个特征向量，它这里<strong>统一了向量的shape</strong>，相当于在同一个特征空间内，按mapper聚合多个类中心。</p></li></ul><h3 id="4-2-方法记录"><a href="#4-2-方法记录" class="headerlink" title="4.2 方法记录"></a>4.2 方法记录</h3><ul><li><p>如何利用多个不同层提取出的特征向量，核心如下公式所示。<br><img src="https://s2.loli.net/2025/01/09/NMQJKOybilHTAGV.png" alt="image.png"></p></li><li><p><strong>训练流程：</strong>两个阶段，<span class="label label-primary">第一阶段</span>就是正常带FC层的分类器，并且本文是在每个Block后面都接一个FC层，分别训练到这个Block为止的网络，<span class="label label-primary">第二阶段</span>，舍去FC层，应用轮次训练在基类上模拟FSL Task，通过公式6的负对数概率计算loss，反向传播微调编码器的参数。微调结束，最终在novel类上面推理，之前的Free Lunch也是一样的流程。<br><img src="https://s2.loli.net/2025/01/09/eOXMZnHkxYScaRP.png" alt="image.png"></p></li></ul><div class="note note-secondary">            <ol><li>总结一下，它提高原型网络分类精度的手段就是，同一个特征space，一个类别聚合m个类中心。</li><li>感觉第一阶段训练就相当于独立地训练了4个encoder，但是又不独立，前面的参数是要重复使用的，具体要看代码train部分。</li></ol>          </div><div class="note note-info">            <ol><li>这种在预训练阶段，训练一个分类器的做法和我之前看的<strong>有监督对比学习</strong>训练编码器的方式不一样，我的想法是也许可以借用这个metric，然后用SCL的做法分别独立训练出3个encoder。之后可以有两种metric方法，一种是和本文做法一样，投射到同一个特征空间；另一种映射到不同特征空间分别做相似度计算，再求和，作为新的metric。</li><li>还有一个想法是SCL的<strong>encoder很关键，</strong>决定了特征向量的质量，借鉴GoogleNet的多尺度卷积方法，预训练出一个encoder，也可以试一下。</li></ol>          </div><h3 id="4-3-参考博客"><a href="#4-3-参考博客" class="headerlink" title="4.3 参考博客"></a>4.3 参考博客</h3><ul><li><p><a href="https://blog.csdn.net/weixin_43499457/article/details/124595010?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223c42cb44ac6d1d4ee40531845d5a092b%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=3c42cb44ac6d1d4ee40531845d5a092b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-124595010-null-null.142%5Ev101%5Epc_search_result_base8&utm_term=%E7%9B%91%E7%9D%A3%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0&spm=1018.2226.3001.4187">有监督对比学习在分类任务中的应用 Supervised Contrastive Learning</a></p></li><li><p><a href="https://blog.csdn.net/c___c18/article/details/144056112?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%9B%91%E7%9D%A3%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-144056112.142%5Ev101%5Epc_search_result_base8&spm=1018.2226.3001.4187">监督对比学习代码实现与分析（Supervised Contrastive Learning in NLP）</a></p></li><li><p><a href="https://blog.csdn.net/Bluebro/article/details/130035707">主干网络backbone讲解—— Conv4与Resnet12</a></p></li></ul><h2 id="5-BSNet-Bi-Similarity-Network-for-Few-shot-Fine-grained-Image-Classification"><a href="#5-BSNet-Bi-Similarity-Network-for-Few-shot-Fine-grained-Image-Classification" class="headerlink" title="5.BSNet: Bi-Similarity Network for Few-shot  Fine-grained Image Classification"></a>5.BSNet: Bi-Similarity Network for Few-shot  Fine-grained Image Classification</h2><h3 id="5-1-基本信息"><a href="#5-1-基本信息" class="headerlink" title="5.1 基本信息"></a>5.1 基本信息</h3><ul><li><p>2020年，‌IEEE Transactions on Image Processing（TIP）期刊论文</p></li><li><p>源码：<a href="https://github.com/PRIS-CV/BSNet">BSNet</a></p></li><li><p>代码格式简洁，是基于度量学习的图像细粒度分类，提出同时使用余弦相似度和欧式距离两种loss，即在ProtoNet上添加一个余弦相似度的loss，分类精度在图像分类上有所提高。</p></li></ul><div class="note note-light">            <p>最后调优模型的时候可以试一下，有空看代码。</p>          </div> <h2 id="6-Supervised-Contrastive-Learning"><a href="#6-Supervised-Contrastive-Learning" class="headerlink" title="6.Supervised Contrastive Learning"></a>6.Supervised Contrastive Learning</h2><h3 id="6-1-基本信息"><a href="#6-1-基本信息" class="headerlink" title="6.1 基本信息"></a>6.1 基本信息</h3><ul><li><p>2020年，NeurIPS</p></li><li><p>源码：<a href="https://github.com/HobbitLong/SupContrast">SupContrast</a></p></li><li><p>SCL集合了传统度量学习领域的<span class="label label-secondary">Triplet loss</span>、<span class="label label-secondary">N-pair loss</span>两者的特点，提出对一个Anchor除了<strong>考虑多个负样例之外，也同时考虑多个正样例</strong>，设计的损失函数避开了需要显式地调参以挖掘半难样本的需求。</p></li></ul><h3 id="6-2-方法记录"><a href="#6-2-方法记录" class="headerlink" title="6.2 方法记录"></a>6.2 方法记录</h3><ul><li><p>在一个batch中，每一个样本$x$都经过一个数据增强模块$Aug(·)$生成两个随机增强$\bar{x} &#x3D; Aug(x)$，两个增强后的样本标签一样，属于同一个类别。接下来<strong>如何保证随机生成的一个batch有多个样本标签相同呢</strong>，除了数据增强的方式生成正样本对之外，相对于类别个数大小C，batch的<code>batch_size = N</code>要远大于C，这样平均N&#x2F;C，就必定会采样到同一个类的多个样本。</p></li><li><p>代码与对应公式的解释：<a href="https://zhuanlan.zhihu.com/p/670579496">监督对比学习SupConLoss代码学习笔记</a></p></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c51fa20" role="button" aria-expanded="false" aria-controls="collapse-9c51fa20">        <div class="fold-arrow">▶</div>SupContrastLoss      </div>      <div class="fold-collapse collapse" id="collapse-9c51fa20">        <div class="fold-content">          <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Author: Yonglong Tian (yonglong@mit.edu)</span><br><span class="hljs-string">Date: May 07, 2020</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SupConLoss</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;Supervised Contrastive Learning: https://arxiv.org/pdf/2004.11362.pdf.</span><br><span class="hljs-string">    It also supports the unsupervised contrastive loss in SimCLR&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, temperature=<span class="hljs-number">0.07</span>, contrast_mode=<span class="hljs-string">&#x27;all&#x27;</span>,</span><br><span class="hljs-params">                 base_temperature=<span class="hljs-number">0.07</span></span>):<br>        <span class="hljs-built_in">super</span>(SupConLoss, self).__init__()<br>        self.temperature = temperature<br>        self.contrast_mode = contrast_mode<br>        self.base_temperature = base_temperature<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, features, labels=<span class="hljs-literal">None</span>, mask=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Compute loss for model. If both `labels` and `mask` are None,</span><br><span class="hljs-string">        it degenerates to SimCLR unsupervised loss:</span><br><span class="hljs-string">        https://arxiv.org/pdf/2002.05709.pdf</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            features: hidden vector of shape [bsz, n_views, ...].</span><br><span class="hljs-string">            labels: ground truth of shape [bsz].</span><br><span class="hljs-string">            mask: contrastive mask of shape [bsz, bsz], mask_&#123;i,j&#125;=1 if sample j</span><br><span class="hljs-string">                has the same class as sample i. Can be asymmetric.</span><br><span class="hljs-string">        Returns:</span><br><span class="hljs-string">            A loss scalar.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        device = (torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span>)<br>                  <span class="hljs-keyword">if</span> features.is_cuda<br>                  <span class="hljs-keyword">else</span> torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>))<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(features.shape) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;`features` needs to be [bsz, n_views, ...],&#x27;</span><br>                             <span class="hljs-string">&#x27;at least 3 dimensions are required&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(features.shape) &gt; <span class="hljs-number">3</span>:<br>            features = features.view(features.shape[<span class="hljs-number">0</span>], features.shape[<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>)<br><br>        batch_size = features.shape[<span class="hljs-number">0</span>]  <span class="hljs-comment"># batch_size = N</span><br>        <span class="hljs-keyword">if</span> labels <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Cannot define both `labels` and `mask`&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> labels <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> mask <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            mask = torch.eye(batch_size, dtype=torch.float32).to(device)<br>        <span class="hljs-keyword">elif</span> labels <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            labels = labels.contiguous().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> labels.shape[<span class="hljs-number">0</span>] != batch_size:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Num of labels does not match num of features&#x27;</span>)<br>            mask = torch.eq(labels, labels.T).<span class="hljs-built_in">float</span>().to(device)<br>        <span class="hljs-keyword">else</span>:<br>            mask = mask.<span class="hljs-built_in">float</span>().to(device)<br><br>        contrast_count = features.shape[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 视图个数</span><br>        contrast_feature = torch.cat(torch.unbind(features, dim=<span class="hljs-number">1</span>), dim=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 消除视图维度，按batch拼接，得到[N*n_views, feature_dim]</span><br>        <span class="hljs-keyword">if</span> self.contrast_mode == <span class="hljs-string">&#x27;one&#x27;</span>:<br>            anchor_feature = features[:, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 只取第一个视图作为anchor</span><br>            anchor_count = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> self.contrast_mode == <span class="hljs-string">&#x27;all&#x27;</span>:<br>            anchor_feature = contrast_feature  <span class="hljs-comment"># 所有视图作为anchor</span><br>            anchor_count = contrast_count<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Unknown mode: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.contrast_mode))<br><br>        <span class="hljs-comment"># compute logits</span><br>        anchor_dot_contrast = torch.div(<br>            torch.matmul(anchor_feature, contrast_feature.T),  <span class="hljs-comment"># 1.单个 [N, ft_dim] * [ft_dim, N*n_views] = [N, N*n_views]  2.所有 [N*n_views, ft_dim] * [ft_dim, N*n_views] = [N*n_views, N*n_views]</span><br>            self.temperature)<br>        <span class="hljs-comment"># for numerical stability</span><br>        logits_max, _ = torch.<span class="hljs-built_in">max</span>(anchor_dot_contrast, dim=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<br>        logits = anchor_dot_contrast - logits_max.detach()<br><br>        <span class="hljs-comment"># tile mask</span><br>        mask = mask.repeat(anchor_count, contrast_count)<br>        <span class="hljs-comment"># mask-out self-contrast cases</span><br>        logits_mask = torch.scatter(<br>            torch.ones_like(mask),<br>            <span class="hljs-number">1</span>,<br>            torch.arange(batch_size * anchor_count).view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>).to(device),<br>            <span class="hljs-number">0</span><br>        )<br>        mask = mask * logits_mask<br><br>        <span class="hljs-comment"># compute log_prob</span><br>        exp_logits = torch.exp(logits) * logits_mask  <span class="hljs-comment"># [N*n_views, N*n_views]</span><br>        log_prob = logits - torch.log(exp_logits.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>))  <span class="hljs-comment"># [N*n_views, N*n_views]</span><br><br>        <span class="hljs-comment"># compute mean of log-likelihood over positive</span><br>        <span class="hljs-comment"># modified to handle edge cases when there is no positive pair</span><br>        <span class="hljs-comment"># for an anchor point.</span><br>        <span class="hljs-comment"># Edge case e.g.:-</span><br>        <span class="hljs-comment"># features of shape: [4,1,...]</span><br>        <span class="hljs-comment"># labels:            [0,1,1,2]</span><br>        <span class="hljs-comment"># loss before mean:  [nan, ..., ..., nan]</span><br>        mask_pos_pairs = mask.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>)<br>        mask_pos_pairs = torch.where(mask_pos_pairs &lt; <span class="hljs-number">1e-6</span>, <span class="hljs-number">1</span>, mask_pos_pairs)<br>        mean_log_prob_pos = (mask * log_prob).<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>) / mask_pos_pairs  <span class="hljs-comment"># [N*n_views]</span><br><br>        <span class="hljs-comment"># loss</span><br>        loss = - (self.temperature / self.base_temperature) * mean_log_prob_pos <span class="hljs-comment"># [N*n_views]</span><br>        loss = loss.view(anchor_count, batch_size).mean()  <span class="hljs-comment"># 标量</span><br><br>        <span class="hljs-keyword">return</span> loss<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><div class="note note-info">            <p>仿照这篇论文的三个核心模块：<strong>数据增强模块</strong>、编码网络、映射网络，计划对脑电原始数据做Channel Reflection数据增强，以及一个其他数据增强操作，和本文的监督对比loss匹配，Backbone也需要找一个替换。</p>          </div><h2 id="7-Channel-reflection-Knowledge-driven-data-augmentation-for-EEG-based-brain–computer-interfaces"><a href="#7-Channel-reflection-Knowledge-driven-data-augmentation-for-EEG-based-brain–computer-interfaces" class="headerlink" title="7.Channel reflection: Knowledge-driven data augmentation for EEG-based brain–computer interfaces"></a>7.Channel reflection: Knowledge-driven data augmentation for EEG-based brain–computer interfaces</h2><h3 id="7-1-基本信息"><a href="#7-1-基本信息" class="headerlink" title="7.1 基本信息"></a>7.1 基本信息</h3><ul><li><p>2024年，Neural Networks</p></li><li><p>源码：<a href="https://github.com/wzwvv/EEGAug">EEGAug</a></p></li><li><p>提出了一种无需超参数的<strong>通道交换(CR)数据增强</strong>方法，传统的数据增强如添加Noise、Scale、Frep都需要调超参数，并且十分鲁棒，在MI、SSVEP、ERP、癫痫检测4个实验范式下均适用，相比于Baseline(没有数据增强)，分类精度更好。注意经CR数据增强之后，训练数据翻倍。</p></li></ul><h3 id="7-2-方法记录"><a href="#7-2-方法记录" class="headerlink" title="7.2 方法记录"></a>7.2 方法记录</h3>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-05eef982" role="button" aria-expanded="false" aria-controls="collapse-05eef982">        <div class="fold-arrow">▶</div>leftrightflipping_transform      </div>      <div class="fold-collapse collapse" id="collapse-05eef982">        <div class="fold-content">          <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">leftrightflipping_transform</span>(<span class="hljs-params">X, left_mat, right_mat</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Parameters</span><br><span class="hljs-string">    ----------</span><br><span class="hljs-string">    X: torch tensor of shape (num_samples, 1, num_channels, num_timesamples)</span><br><span class="hljs-string">    left_mat: numpy array of shape (a, ), where a is the number of left brain channels, in order</span><br><span class="hljs-string">    right_mat: numpy array of shape (b, ), where b is the number of right brain channels, in order</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns</span><br><span class="hljs-string">    -------</span><br><span class="hljs-string">    transformedX: transformed signal of torch tensor of shape (num_samples, num_channels, num_timesamples)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    num_samples, _, num_channels, num_timesamples = X.shape<br>    transformedX = torch.zeros((num_samples, <span class="hljs-number">1</span>, num_channels, num_timesamples))<br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_channels):<br>        <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">in</span> left_mat:<br>            ind = left_mat.index(ch)<br>            transformedX[:, <span class="hljs-number">0</span>, ch, :] = X[:, <span class="hljs-number">0</span>, right_mat[ind], :]<br>        <span class="hljs-keyword">elif</span> ch <span class="hljs-keyword">in</span> right_mat:<br>            ind = right_mat.index(ch)<br>            transformedX[:, <span class="hljs-number">0</span>, ch, :] = X[:, <span class="hljs-number">0</span>, left_mat[ind], :]<br>        <span class="hljs-keyword">else</span>:<br>            transformedX[:, <span class="hljs-number">0</span>, ch, :] = X[:, <span class="hljs-number">0</span>, ch, :]<br><br>    <span class="hljs-keyword">return</span> transformedX<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li>即根据脑电极通道的索引，位于中线的电极不变，左脑和右脑对称分布的电极做一个交换，类似于图像的翻转操作。除左右手MI想象要调换标签之外，ERP不需要换标签。调用方法如下：</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-90469042" role="button" aria-expanded="false" aria-controls="collapse-90469042">        <div class="fold-arrow">▶</div>调用example      </div>      <div class="fold-collapse collapse" id="collapse-90469042">        <div class="fold-content">          <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-keyword">if</span> dataset == <span class="hljs-string">&#x27;BNCI2014001&#x27;</span>:<br>    left_mat = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">18</span>]<br>    right_mat = [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>]<br>    aug_train_x = leftrightflipping_transform(<br>        torch.from_numpy(train_x).to(torch.float32).reshape(train_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, ch_num, -<span class="hljs-number">1</span>),<br>        left_mat, right_mat).numpy().reshape(train_x.shape[<span class="hljs-number">0</span>], ch_num, -<span class="hljs-number">1</span>)<br>    aug_train_y = <span class="hljs-number">1</span> - train_y  <span class="hljs-comment"># 二分类标签0-1对调</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><ul><li><a href="https://roses.blog.csdn.net/article/details/141632317?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-141632317-blog-128355505.235%5Ev43%5Epc_blog_bottom_relevance_base4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-141632317-blog-128355505.235%5Ev43%5Epc_blog_bottom_relevance_base4&utm_relevant_index=6">​华中科技大学伍冬睿团队提出知识数据融合的通道交换脑电数据增强方法</a></li></ul><h2 id="8-Revisiting-Prototypical-Network-for-Cross-Domain-Few-Shot-Learning"><a href="#8-Revisiting-Prototypical-Network-for-Cross-Domain-Few-Shot-Learning" class="headerlink" title="8.Revisiting Prototypical Network for Cross Domain Few-Shot Learning"></a>8.Revisiting Prototypical Network for Cross Domain Few-Shot Learning</h2><h3 id="8-1-基本信息"><a href="#8-1-基本信息" class="headerlink" title="8.1 基本信息"></a>8.1 基本信息</h3><ul><li><p>2023年，CVPR会议论文</p></li><li><p>源码：<a href="https://github.com/NWPUZhoufei/LDP-Net">LDP-Net</a></p></li><li><p>是基于baseline原型网络的改进，指出全局特征提取器倾向于学习浅显的颜色、形状等简单特征，而<strong>没有学习到这个类不变的、深层的所谓“语义特征”</strong>，作者由此提出了局部全局蒸馏-原型网络，通过建立一个两分支网络对查询图像和其<strong>局部随机多个裁剪增强</strong>进行分类，并利用<strong>知识蒸馏</strong>强制这两个分支保持类原型预测结果一致，使得特征提取网络学到更多的语义信息。</p></li></ul><h3 id="8-2-方法记录"><a href="#8-2-方法记录" class="headerlink" title="8.2 方法记录"></a>8.2 方法记录</h3><ul><li><p>方法在消融实验的结果上可以看出，主要是<strong>局部裁剪的图像要和原始的图像</strong>类标签保持一致这一步起作用，也就是<code>self-image distill</code>，并且“知识蒸馏”是包装过的说法，实际上方法的有效性建立在图像经随机裁剪之后，能关注到更多的细节信息，结合这个分支和原始的整张图像分支，两者共同对特征提取器的参数做反向传播，共同发挥作用。</p></li><li><p>特征提取器首先经预训练。接着值得注意的是为了不同时训练两个分支的模型参数，并且以全局图像为主干，本文提出了用<span class="label label-secondary">Exponential Moving Average (EMA)</span>，一种<strong>加权移动的方法</strong>来更新局部分支的模型参数。<br><img src="https://s2.loli.net/2025/02/16/ClnkRoLwXu6gpDy.png" alt="模型训练图"></p></li></ul><h2 id="9-Cross-session-SSVEP-brainprint-recognition-using-attentive-multi-subband-depth-identity-embedding-learning-network"><a href="#9-Cross-session-SSVEP-brainprint-recognition-using-attentive-multi-subband-depth-identity-embedding-learning-network" class="headerlink" title="9.Cross-session SSVEP brainprint recognition using attentive multi-subband depth identity embedding learning network"></a>9.Cross-session SSVEP brainprint recognition using attentive multi-subband depth identity embedding learning network</h2><h3 id="9-1-基本信息"><a href="#9-1-基本信息" class="headerlink" title="9.1 基本信息"></a>9.1 基本信息</h3><ul><li><p>2024年，Cognitive Neurodynamics</p></li><li><p>使用2s的样本，仅利用1个session的数据做训练，训练和验证集比例设置为8:2，在另一个session上检验有效性。模块包括Deepconvwise、Res2Net、时空注意力、<strong>Attentive Statistic Pooling</strong>。</p></li></ul><h2 id="10-TST-MFL-Two-stage-training-based-metric-fusion-learning-for-few-shot-image-classification"><a href="#10-TST-MFL-Two-stage-training-based-metric-fusion-learning-for-few-shot-image-classification" class="headerlink" title="10.TST_MFL: Two-stage training based metric fusion learning for few-shot image classification"></a>10.TST_MFL: Two-stage training based metric fusion learning for few-shot image classification</h2><h3 id="10-1-基本信息"><a href="#10-1-基本信息" class="headerlink" title="10.1 基本信息"></a>10.1 基本信息</h3><ul><li><p>2024年，Information Fusion</p></li><li><p>源码：<a href="https://github.com/ZitZhengWang/TST_MFL">TST_MFL</a></p></li><li><p>传统的度量学习方法大多只提取<strong>全局特征表示</strong>，一些在元训练阶段结合了<strong>局部特征表示</strong>，而本文提出不仅要在元训练阶段特征融合，也要在预训练阶段特征融合，进一步提高特征的判别性。</p></li></ul><h3 id="10-2-方法记录"><a href="#10-2-方法记录" class="headerlink" title="10.2 方法记录"></a>10.2 方法记录</h3><h4 id="10-2-1-Pre-training-Stage"><a href="#10-2-1-Pre-training-Stage" class="headerlink" title="10.2.1 Pre-training Stage"></a>10.2.1 Pre-training Stage</h4><ul><li>提出了一个双路（dual-path）的预训练网络，采用传统的交叉熵损失在基类上训练一个多分类任务，具体的：<ol><li>全局分类subnet：图像尺寸为84x84，backbone采用ResNet12用于特征提取，最后接全连接层和Softmax计算全局分类损失；</li><li>局部分类subnet：图像尺寸为26x26，backbone也是ResNet12用于局部图像块的特征提取，接了一个8头自注意力层，然后全连接层加Softmax。假设一张图像分割为36块，这36块都属于同一个类别，标签的范围和全局一样是D类，则这36小块每块分别提取特征，独立预测分类标签，计算一个局部分类损失。</li><li>损失函数1和2：全局交叉熵损失$L_{CE}$、平均局部交叉熵损失$L_{LCE}$</li><li>损失函数3：<strong>预测蒸馏损失</strong>$L_{KD}$，改进了知识蒸馏的<strong>KL散度</strong>，让老师（全局预测出来的类标签概率分布）和学生（局部预测出来的平均类标签概率分布）能够相互学习，通过对这两个概率分布取平均，然后作为老师，指导前面两个概率分布靠近这个老师。</li><li>损失函数4：<strong>局部多样性损失</strong>$L_B$，目的是最小化同一张图像的局部块之间的预测概率分布差异。</li></ol></li></ul><h4 id="10-2-2-Meta-training-Stage"><a href="#10-2-2-Meta-training-Stage" class="headerlink" title="10.2.2 Meta-training Stage"></a>10.2.2 Meta-training Stage</h4><ul><li>提出了一个全局-局部度量融合网络，在基类上以轮次训练的方式继续提高小样本分类性能，具体的：<ol><li>保留预训练网络的全局子网特征提取器、局部子网的特征提取器、self-attention模块；</li><li>Global metric subnet：在一个小样本任务中，Support集按照类别计算类原型，Query集中的每个样本转为特征之后，利用<strong>余弦相似度</strong>来计算和每个类原型（N类）的相似度，最后一个Query就是一条相似度向量：$Sim_g \in R^N$；</li><li>Local metric subnet：<ul><li>输入：支持集、查询集样本的局部裁剪块作为输入，每个样本裁剪为$m$块；</li><li>由于可能裁剪到和关键分类信息不相关的背景图像，提出了一个<strong>基于相似度阈值</strong>的局部特征过滤模块，即把局部块提取出的特征和这张图像的全局特征进行余弦相似度对比，如果低于阈值0.2，则把这个局部特征<strong>清零</strong>，达到过滤的效果；</li><li>接着计算相似度，支持集<strong>每类</strong>K个样本，每个样本拆为m个，则一共有Km个局部块，每个经过过滤的Query局部块为m个。挨个计算<strong>余弦相似度</strong>，得到余弦相似度矩阵，即km行m列，然后根据KNN为每个Query局部块（共m个）选出前k个值最大的相似度，求和最后取平均，作为最终的该Query样本和该类的相似度。</li><li>1个Query对应N类，有n个相似度值，组成一条相似度向量$Sim_l$。</li></ul></li><li>Metric Fusion module： 两个权重是可学习的超参数。<br> $$Sim_f &#x3D; w_1 * Sim_g + w_2 * Sim_l$$</li><li>标签的预测最后采用公式：<br> $$\hat{y} &#x3D; \arg\max\limits_{c} Sim_{f}^{(c)}$$</li></ol></li></ul><div class="note note-info">            <ol><li>代码实际上用的是meta-baseline的，创新点是在全局特征表示的基础上，加了一个局部特征表示，<strong>并行蒸馏</strong>。</li><li>局部裁剪用在脑电上有一定作用，但不够明显，计划使用1d卷积模型，并行学习模型并蒸馏。</li><li>小样本分类的度量指标：欧式距离的效果要差于余弦相似度。</li></ol>          </div><h2 id="11-Meta-Baseline-Exploring-Simple-Meta-Learning-for-Few-Shot-Learning"><a href="#11-Meta-Baseline-Exploring-Simple-Meta-Learning-for-Few-Shot-Learning" class="headerlink" title="11.Meta-Baseline: Exploring Simple Meta-Learning for Few-Shot Learning"></a>11.Meta-Baseline: Exploring Simple Meta-Learning for Few-Shot Learning</h2><h3 id="11-1-基本信息"><a href="#11-1-基本信息" class="headerlink" title="11.1 基本信息"></a>11.1 基本信息</h3><ul><li><p>2021年，CVPR oral</p></li><li><p>源码：<a href="https://github.com/yinboc/few-shot-meta-baseline">few-shot-meta-baseline</a></p></li><li><p>主要提出了用整个base数据集训练的<strong>分类器</strong>、和在base数据集上构建fs任务的<strong>meta-training</strong>之间的权衡。当基类上的类别和新类的上未见的类分布相似时，使用meta-training是有帮助的，否则可能对分类器的类可偏移能力负面影响，容易在base类上过拟合。</p></li></ul><h2 id="12-Joint-Distribution-Matters-Deep-Brownian-Distance-Covariance-for-Few-Shot-Classification"><a href="#12-Joint-Distribution-Matters-Deep-Brownian-Distance-Covariance-for-Few-Shot-Classification" class="headerlink" title="12.Joint Distribution Matters: Deep Brownian Distance Covariance for  Few-Shot Classification"></a>12.Joint Distribution Matters: Deep Brownian Distance Covariance for  Few-Shot Classification</h2><h3 id="12-1-基本信息"><a href="#12-1-基本信息" class="headerlink" title="12.1 基本信息"></a>12.1 基本信息</h3><ul><li><p>2022年，CVPR</p></li><li><p>源码：<a href="https://github.com/Fei-Long121/DeepBDC">DeepBDC</a></p></li><li><p>提出。。。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>度量学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
      <tag>metric-learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerPoint技能点</title>
    <link href="/cn/ppt_technique/"/>
    <url>/cn/ppt_technique/</url>
    
    <content type="html"><![CDATA[<h1 id="1-PPT整体展示图表之后局部高亮"><a href="#1-PPT整体展示图表之后局部高亮" class="headerlink" title="1.PPT整体展示图表之后局部高亮"></a>1.PPT整体展示图表之后局部高亮</h1><p><a href="https://www.bilibili.com/video/BV13r4y1c7r1/?vd_source=a9e78e47d3e6d67d875c0260caff8550">步骤教学</a></p><p><img src="https://s2.loli.net/2024/12/07/KUh4etcvqSk2BDd.gif" alt="ppt.gif"></p><h1 id="2-Others"><a href="#2-Others" class="headerlink" title="2.Others"></a>2.Others</h1><ul><li><a href="https://www.freeconvert.com/zh/convert/video-to-gif">视频转GIF工具</a></li><li><a href="https://blog.csdn.net/weixin_38314865/article/details/104440652">PPT立方体形状变薄</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AUC(area under curve)</title>
    <link href="/cn/evaluation-metrics/"/>
    <url>/cn/evaluation-metrics/</url>
    
    <content type="html"><![CDATA[<font size=3><p>电子笔记</p><span id="more"></span><h1 id="1-AUC-area-under-curve"><a href="#1-AUC-area-under-curve" class="headerlink" title="1.AUC(area under curve)"></a>1.AUC(area under curve)</h1><h2 id="1-1什么是AUC"><a href="#1-1什么是AUC" class="headerlink" title="1.1什么是AUC"></a>1.1什么是AUC</h2><p>用于评估分类器的分类效果，对于真实类别为1的样本，分类器预测为1的概率(即TPrate)要大于真实类别为0而预测类别为1的概率(即FPrate)，即AUC&gt;0.5。</p><h2 id="1-2如何计算AUC"><a href="#1-2如何计算AUC" class="headerlink" title="1.2如何计算AUC"></a>1.2如何计算AUC</h2><p>在有M个正样本,N个负样本的数据集里。一共有M*N对样本（一对样本即一个正样本与一个负样本）。统计这M*N对样本里，正样本的预测概率大于负样本的预测概率的个数。<br><img src="https://s2.loli.net/2024/12/09/lj6xh4XCm7oqgDu.png" alt="image.png"></p><h2 id="1-3接口参数含义"><a href="#1-3接口参数含义" class="headerlink" title="1.3接口参数含义"></a>1.3接口参数含义</h2><p><code>roc_auc_score(test_labels, probs, multi_class=&#39;ovr&#39;)</code></p><div class="note note-info">            <ol><li>test_labels: 实际的类别标签，shape是 [N,]</li><li>probs: 每个样本在各个类别上的概率，shape是[N, C]</li><li>指定计算多类别问题的 AUC (<strong>One-vs-Rest 策略</strong>)</li></ol>          </div><h1 id="2-AccuracyCalculator使用"><a href="#2-AccuracyCalculator使用" class="headerlink" title="2.AccuracyCalculator使用"></a>2.AccuracyCalculator使用</h1><p>在<strong>pytorch-metric-learning</strong>中，AccuracyCalculator主要用于计算准确率（如 top-k 准确率）。通过嵌入向量之间的相似度来推测每个样本的类别，并与真实标签进行比较，相同则预测正确。这种方法是基于<strong>最近邻</strong>来判断类别，预测准确率的。</p><p>使用方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> pytorch_metric_learning <span class="hljs-keyword">import</span> losses<br><span class="hljs-keyword">from</span> pytorch_metric_learning.utils.accuracy_calculator <span class="hljs-keyword">import</span> AccuracyCalculator<br><br><span class="hljs-comment"># 初始化 AccuracyCalculator: 参数k值，指定 top-k 精度</span><br>accuracy_calculator = AccuracyCalculator(k=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 计算准确率</span><br>accuracy = accuracy_calculator.calculate(<br>    embeddings=embeddings,  <span class="hljs-comment"># 模型输出的嵌入向量 [batch_size, embedding_dim]</span><br>    labels=labels,          <span class="hljs-comment"># 标签 [batch_size]</span><br>)<br></code></pre></td></tr></table></figure><h1 id="3-资料"><a href="#3-资料" class="headerlink" title="3.资料"></a>3.资料</h1><ul><li><a href="https://www.zhihu.com/question/39840928?from=profile_question_card">AUC如何理解？</a></li><li><a href="https://blog.csdn.net/qq_22238533/article/details/78666436">AUC的计算方法</a></li></ul></font>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>评估指标</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
      <tag>sklearn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EAR-EEG数据集调研</title>
    <link href="/cn/Ear-EEG-Dataset/"/>
    <url>/cn/Ear-EEG-Dataset/</url>
    
    <content type="html"><![CDATA[<font size=3><p>有关<strong>耳脑电</strong>的概述、4个应用类别的可行性、公开数据集的材料调研。</p><span id="more"></span><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>和全头皮脑电类似，ear-EEG同样是通过在皮肤上放置电极记录微小的电压变化，以测量动态的大脑活动。电极传感器可以放置在外耳的不同位置（耳廓、耳甲、耳道），检测设备材料种类很多，测量方式也分干&#x2F;湿电极，但是<strong>与头皮脑电相比，耳脑电的电极部署数量少，且信号幅度(signal amplitude)明显低于头皮脑电</strong>10-20dB。</p><p>耳脑电靠近<strong>颞叶(Temporal Lobe)区域</strong>，这个区域和听觉、语言处理、记忆和情感都相关，在事件相关电位(ERPs)、脑机接口(BCI)、睡眠、癫痫4个领域都已有研究来证明耳脑电信号的可行性。</p><h1 id="2-应用领域"><a href="#2-应用领域" class="headerlink" title="2.应用领域"></a>2.应用领域</h1><h2 id="2-1-事件相关电位"><a href="#2-1-事件相关电位" class="headerlink" title="2.1 事件相关电位"></a>2.1 事件相关电位</h2><p>ERP是测量的大脑对视觉、声音或触觉的短暂刺激的反应。耳脑电被证明可可靠测量几个熟知的ERPs，耳脑电实现的EEG诱发范式大多数与听觉刺激有关，包括<strong>听觉诱发电位</strong>(auditory-evoked potentials，AEPs)和<strong>听觉稳态电位</strong>(multiple auditory-steady responses, ASSR)，以及<strong>SSVEP</strong>。</p><h2 id="2-2-脑机接口"><a href="#2-2-脑机接口" class="headerlink" title="2.2 脑机接口"></a>2.2 脑机接口</h2><p>BCIs是用于解码电生理信号去控制一个外部设备的技术。综述中介绍了多篇paper采集耳脑电然后用于注意力状态鉴别、驾驶员嗜睡分类。</p><h2 id="2-3-睡眠"><a href="#2-3-睡眠" class="headerlink" title="2.3 睡眠"></a>2.3 睡眠</h2><p>耳脑电适合于长期的监测睡眠质量，耳内传感器获取的数据可以被用于睡眠分期的评估，但也提到耳脑电的<strong>amplitude</strong>比标准EEG低。</p><h2 id="2-4-癫痫"><a href="#2-4-癫痫" class="headerlink" title="2.4 癫痫"></a>2.4 癫痫</h2><p>适合长期监测，指出耳脑电适合记录颞叶癫痫信号，并用于癫痫评估。</p><h1 id="3-公开数据集"><a href="#3-公开数据集" class="headerlink" title="3.公开数据集"></a>3.公开数据集</h1><h2 id="3-1-睡眠监测"><a href="#3-1-睡眠监测" class="headerlink" title="3.1 睡眠监测"></a>3.1 睡眠监测</h2><ul><li><a href="https://openneuro.org/datasets/ds004348/versions/1.0.5">Ear-EEG Sleep Monitoring 2017 (EESM17)</a></li></ul><p>睡眠监测数据集，包含9名受试者的夜间脑电图记录。这些recording包括<strong>脑电图、眼电图和下巴肌电图，以及 14 个耳部脑电图电极</strong>。</p><p>label分为两类，1:wake; 2:sleep</p><h2 id="3-2-运动想象"><a href="#3-2-运动想象" class="headerlink" title="3.2 运动想象"></a>3.2 运动想象</h2><ul><li><a href="https://ieee-dataport.org/open-access/ear-eeg-recording-brain-computer-interface-motor-task">Ear-EEG Recording for Brain Computer Interface of Motor Task</a></li></ul><p>左&#x2F;右手抓握运动想象数据集，包括6个受试者。耳部脑电图与头皮脑电图同时记录。8个耳电极放置在前耳道和后耳道（标记为 xF、xB）<br>以及耳甲的两个上部和下部位置（标记为 xOU 和 xOD）。所有耳部和头皮电极均以头皮REF电极为参考。<br>头皮GRD电极用作接地参考。以1000 Hz采样信号，然后用0.5 Hz至100 Hz之间的带通滤波器和陷波滤波器进行滤波。</p><h2 id="3-3-SSVEP"><a href="#3-3-SSVEP" class="headerlink" title="3.3 SSVEP"></a>3.3 SSVEP</h2><ul><li><a href="http://deepbci.korea.ac.kr/opensource/opendb/">EEG Dataset for SSVEP using Ear-EEG and Scalp-EEG</a></li></ul><p>数据集是韩国的一个网站，需要申请：<br><img src="https://s2.loli.net/2024/11/28/XMAbZFmxgo6rzfL.png" alt="image.png"></p><ul><li><a href="https://ieeexplore.ieee.org/abstract/document/8758838">论文_包含实验范式</a></li></ul><h3 id="3-3-1-论文摘要"><a href="#3-3-1-论文摘要" class="headerlink" title="3.3.1 论文摘要"></a>3.3.1 论文摘要</h3><p>耳-脑电对电极位置有自然的限制(例如，限制在耳内或耳周围)，无法充分获取信息丰富的大脑信号。在特定的BCI范式中，不利用<strong>耳周围颞叶的脑信号</strong>，实现可靠的耳-脑电性能是困难的。<br>例如，<strong>稳态视觉诱发电位(SSVEPs)主要产生于枕区，在耳-脑电中具有明显的衰减和扭曲幅度。</strong>因此，保持高水平的解码精度对于基于耳-脑电的SSVEP BCI是具有挑战性和必要的。<br>本文首先研究了在SSVEP范式下，利用枕区估计的目标脑电信号，采用线性和非线性回归方法来提高耳-脑电解码精度。…</p><h3 id="3-3-2-实验范式"><a href="#3-3-2-实验范式" class="headerlink" title="3.3.2 实验范式"></a>3.3.2 实验范式</h3><p>实验一共3个session，前两个session同时记录头皮脑电和耳脑电，第3个session只记录耳脑电。刺激频率有3种，一次trial范式如图所示。<br><img src="https://s2.loli.net/2024/11/28/EtQj2Y6CcBbxryN.png" alt="image.png"></p><p>11个subjects，采样频率500hz，0.3-50 Hz的带通滤波器和60Hz陷波滤波器。</p><ul><li>session1 和 session2，每类刺激50个trial，一共150trial。</li><li>session3，只获取耳-脑电图信号，每个类20个trial，一共60个trial。</li><li>三个session是不在<strong>不同的天</strong>获得的。</li></ul><p><img src="https://s2.loli.net/2024/11/28/hEjdCFwfsqXQLW5.png" alt="image.png"></p><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4.参考资料"></a>4.参考资料</h1><ul><li><a href="https://en.wikipedia.org/wiki/Ear-EEG#History">Ear-EEG_wikipedia</a></li><li><a href="http://deepbci.korea.ac.kr/wp-content/uploads/2019/05/Discription.pdf">韩国ssvep数据集的范式说明</a></li><li>Ear-EEG Devices for the Assessment of Brain  Activity: A Review</li></ul></font>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>耳脑电</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ear-EEG</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象实现文件下载系统</title>
    <link href="/cn/netdisk_server/"/>
    <url>/cn/netdisk_server/</url>
    
    <content type="html"><![CDATA[<p>Server端代码</p><span id="more"></span><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># @Time    : 2024/8/24 9:46</span><br><span class="hljs-comment"># @Author  : Proton</span><br><span class="hljs-comment"># @FileName: netdisk_server.py</span><br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ip, port</span>):<br>        self.s_listen:socket = <span class="hljs-literal">None</span><br>        self.ip = ip<br>        self.port = port<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tcp_init</span>(<span class="hljs-params">self</span>):<br>        self.s_listen = socket(AF_INET, SOCK_STREAM)<br>        self.s_listen.bind((self.ip, self.port))<br>        self.s_listen.listen(<span class="hljs-number">128</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">self</span>):<br>        new_client, client_addr = self.s_listen.accept()<br>        <span class="hljs-built_in">print</span>(client_addr)<br>        user = User(new_client)<br>        user.deal_command()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    每一个user对象对应一个客户端</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, new_client</span>):<br>        self.user: socket = new_client<br>        self.username = <span class="hljs-literal">None</span><br>        self.path = os.getcwd()  <span class="hljs-comment"># 存储连上的用户的路径</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train_send</span>(<span class="hljs-params">self, content_bytes</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        以开火车的形式发送，先发长度，再发内容</span><br><span class="hljs-string">        :param content:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        content_len_bytes = struct.pack(<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-built_in">len</span>(content_bytes))<br>        self.user.send(content_len_bytes+content_bytes)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train_recv</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        开火车接收，先接收文件名/内容长度，4B，再接收文件名/内容</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        train_head_bytes = self.user.recv(<span class="hljs-number">4</span>)<br>        train_head_len = struct.unpack(<span class="hljs-string">&#x27;I&#x27;</span>, train_head_bytes)<br>        <span class="hljs-comment"># 为什么不decode，因为不一定是文本，也可能是音乐or电影</span><br>        <span class="hljs-keyword">return</span> self.user.recv(train_head_len[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deal_command</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 接收命令应该以开火车的形式收</span><br>            command = self.train_recv().decode(<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>            <span class="hljs-keyword">if</span> command[:<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;ls&#x27;</span>:<br>                self.do_ls()<br>            <span class="hljs-keyword">elif</span> command[:<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;cd&#x27;</span>:<br>                self.do_cd(command)<br>            <span class="hljs-keyword">elif</span> command[:<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;pwd&#x27;</span>:<br>                self.do_pwd()<br>            <span class="hljs-keyword">elif</span> command[:<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;rm&#x27;</span>:<br>                self.do_rm(command)<br>            <span class="hljs-keyword">elif</span> command[:<span class="hljs-number">4</span>] == <span class="hljs-string">&#x27;puts&#x27;</span>:<br>                self.puts_file()<br>            <span class="hljs-keyword">elif</span> command[:<span class="hljs-number">4</span>] == <span class="hljs-string">&#x27;gets&#x27;</span>:<br>                self.gets_file(command)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;wrong command.&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_ls</span>(<span class="hljs-params">self</span>):<br>        data = <span class="hljs-string">&#x27;&#x27;</span><br>        cur_list = os.listdir(<span class="hljs-string">&#x27;.&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cur_list:<br>            data += i + <span class="hljs-string">&#x27; &#x27;</span>*<span class="hljs-number">5</span> + <span class="hljs-built_in">str</span>(os.stat(i).st_size) + <span class="hljs-string">&#x27;\n&#x27;</span><br>        self.train_send(data.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_cd</span>(<span class="hljs-params">self, command</span>):<br>        path = command.split()[<span class="hljs-number">1</span>]<br>        os.chdir(path)<br>        self.path = os.getcwd()<br>        self.train_send(self.path.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_pwd</span>(<span class="hljs-params">self</span>):<br>        self.train_send(self.path.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_rm</span>(<span class="hljs-params">self, command</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        深度优先遍历，实现删除非空文件夹</span><br><span class="hljs-string">        :param command:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        rm_target = command.split()[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> os.path.isdir(rm_target) <span class="hljs-keyword">and</span> os.listdir(rm_target):  <span class="hljs-comment"># 若为非空目录</span><br>            file_list = os.listdir(rm_target)  <span class="hljs-comment"># 继续先删深处的文件</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> file_list:<br>                self.do_rm(command + <span class="hljs-string">&#x27;/&#x27;</span> + i)<br>            os.rmdir(rm_target)  <span class="hljs-comment"># 最后再删掉当前这个已经空了的目录</span><br>        <span class="hljs-keyword">elif</span> os.path.isdir(rm_target) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> os.listdir(rm_target):  <span class="hljs-comment"># 空目录</span><br>            os.rmdir(rm_target)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 普通文件</span><br>            os.remove(rm_target)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">puts_file</span>(<span class="hljs-params">self</span>):<br>        data = self.train_recv()<br>        file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;f[复件]&#x27;</span>, mode=<span class="hljs-string">&#x27;wb&#x27;</span>)<br>        file.write(data)<br>        file.close()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gets_file</span>(<span class="hljs-params">self, command</span>):<br>        file_name = command.split()[<span class="hljs-number">1</span>]<br>        my_file = <span class="hljs-built_in">open</span>(file_name, mode=<span class="hljs-string">&#x27;rb&#x27;</span>)  <span class="hljs-comment"># 字节流形式打开二进制文件</span><br>        data = my_file.read()<br>        self.train_send(data)<br>        my_file.close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    s = Server(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">2000</span>)<br>    s.tcp_init()<br>    s.task()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Socket通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>epoll多路复用</title>
    <link href="/cn/epoll-based-socket/"/>
    <url>/cn/epoll-based-socket/</url>
    
    <content type="html"><![CDATA[<font size=3><p>为了实现及时聊天，即两方可以任意向对方发送连续的多条消息的功能，需要使用epoll。在内核中，socket对象缓冲区recv()、标准输入缓冲区input()都分配了一段内存，内存对应一个<strong>整型编号</strong>（数组下标），这个编号就是<strong>文件描述符file describer</strong>。</p><span id="more"></span><p>我们创建epoll对象，注册要监控的fd和事件类型，让epoll去监控哪几个缓冲区发生了指定事件，以列表的形式主动报告给用户进程。</p><h1 id="1-使用epoll编写即时聊天"><a href="#1-使用epoll编写即时聊天" class="headerlink" title="1.使用epoll编写即时聊天"></a>1.使用epoll编写即时聊天</h1><details><summary>服务器代码</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> select<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tcp_server</span>():<br>    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    s_addr = (<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">2000</span>)<br>    server.bind(s_addr)<br>    server.listen(<span class="hljs-number">128</span>)  <span class="hljs-comment"># 被动监听，激活端口</span><br>    new_client, new_client_addr = server.accept()<br>    <span class="hljs-built_in">print</span>(new_client_addr)<br>    epoll = select.epoll()  <span class="hljs-comment"># 创建一个epoll对象</span><br>    <span class="hljs-comment"># 注册要监控的缓冲区，发生指定事件向用户进程汇报</span><br>    epoll.register(new_client.fileno(), select.EPOLLIN)<br>    epoll.register(sys.stdin.fileno(), select.EPOLLIN)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 一直等只会在这里卡住，谁的缓冲区有数据，就填写到eventslist，列表里变存元组 (fd, 事件)</span><br>        events_list = epoll.poll(-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> fd,event <span class="hljs-keyword">in</span> events_list:<br>            <span class="hljs-keyword">if</span> fd == new_client.fileno():<br>                <span class="hljs-comment"># recv缓冲区有数据</span><br>                data = new_client.recv(<span class="hljs-number">100</span>).decode(<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>                <span class="hljs-keyword">if</span> data:<br>                    <span class="hljs-built_in">print</span>(data)<br>                <span class="hljs-keyword">else</span>:<span class="hljs-comment"># 一旦对端断开，recv不会卡主，会返回空,内核会把client标记为一直可读</span><br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;对方断开了&#x27;</span>)<br>                    <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">elif</span> fd == sys.stdin.fileno():<br>                <span class="hljs-comment"># input缓冲区有数据</span><br>                <span class="hljs-keyword">try</span>:  <span class="hljs-comment"># 按ctrl d让服务器断开</span><br>                    data = <span class="hljs-built_in">input</span>()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;不想输入了，I want leave&#x27;</span>)<br>                    <span class="hljs-keyword">return</span><br>                new_client.send(data.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))<br>    server.close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    tcp_server()<br><br></code></pre></td></tr></table></figure></details><p><img src="https://s2.loli.net/2024/08/22/XPfIjBzTDE5MmiH.png" alt="即时聊天测试结果"></p><h1 id="2-使用epoll实现聊天室"><a href="#2-使用epoll实现聊天室" class="headerlink" title="2.使用epoll实现聊天室"></a>2.使用epoll实现聊天室</h1><div class="note note-info">            <p>实现多人聊天，</p><ol><li>新增客户端断开后可以再次连接，服务器端不会退出（epoll解除绑定、关闭client对象）;</li><li>新建一个client列表，存储每个客户端对象，循环遍历查看缓冲区有无数据；</li><li>文件协议设计，聊天室增加用户名功能。</li></ol>          </div><p><img src="https://s2.loli.net/2024/08/23/UaLvRpJhrT8jtC9.png" alt="聊天室测试结果"></p><h1 id="3-持续发送多个文件，协议设计"><a href="#3-持续发送多个文件，协议设计" class="headerlink" title="3.持续发送多个文件，协议设计"></a>3.持续发送多个文件，协议设计</h1><div class="note note-warning">            <p>使用TCP连接发送文件时，首先要以<strong>字节流</strong>形式传送，如果持续发送多个文件，文件名1+文件1内容+文件名2+文件2内容+。。。存在<strong>粘包</strong>问题，两次发送的报文挨在一起，分不开。</p>          </div><p>我们采用<strong>开火车的方式</strong>解决粘包，如下所示。</p><ol><li>小火车</li></ol><ul><li>火车头填写长度：字节数，python需pack为4字节整型数</li><li>火车车厢填写内容：字符串字节流</li></ul><table><thead><tr><th align="center"></th><th align="center">文件名</th><th align="center">文件内容</th></tr></thead><tbody><tr><td align="center">车头</td><td align="center">文件名长度(4B)</td><td align="center">文件内容总长度(4B)</td></tr><tr><td align="center">车厢</td><td align="center">文件名</td><td align="center">文件内容</td></tr></tbody></table><p><strong>Python的struct模块</strong>，提供了一种机制，能将int、float等基本数据类型打包成字符串（实际上相当于其他语言的字节流），可以在网络上传输，而接收端也可以通过解包还原出初始的数据。</p><ul><li><p>pack(fmt, var1, var2,…)<br>按照给定的格式(fmt)，把数据封装成字符串(实际上类似于C结构体的字节流);</p></li><li><p>unpack(fmt, string)<br>按照给定的格式(fmt)解析字节流(string)，<strong>返回</strong>解析出来的<strong>tuple</strong>元组;</p></li><li><p>calcsize(fmt)<br>计算给定的格式(fmt)占用多少字节的内存</p></li><li><p><a href="https://blog.csdn.net/yzy1103203312/article/details/78238004">Python中的struct模块</a></p></li></ul><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ul><li>写代码的时候对不确定的代码实现效果，<strong>自己动手写一个简单的例子</strong>验证一下就可以，这样就不至于代码写了一大堆，不确定错误在哪里。</li></ul><p><img src="https://s2.loli.net/2024/08/23/gY1eD3LfumUjVsb.png" alt=".png"></p></font>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Socket通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>socket</tag>
      
      <tag>epoll</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
